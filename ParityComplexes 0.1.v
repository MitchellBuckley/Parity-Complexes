
(* Written by Mitchell Buckley 13/06/2014 *)

Require Import Ensembles Constructive_sets.
Require Import myFiniteDefs.
Require Import Relations.
Require Import mySetoids.
Require Import Utf8_core.
Require Import Max Le.
Require Import Arith.
Require Import Setoid.
Require Import Recdef.
Require Import PreparityComplexes. 

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Parity Complex Definitions                           *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Module Type ParityComplex.
 
  Declare Module C : PreParity.
  Import C.
  Module PPT := PreParityTheory C.
  Import PPT.

  Axiom axiom1 :
    forall (x : carrier), 
      Union (Plus (plus x)) (Minus (minus x)) == Union (Plus (minus x)) (Minus (plus x)).

  Axiom axiom2a :
    forall x, well_formed (plus x).

  Axiom axiom2b :
    forall x, well_formed (minus x).

  Axiom axiom3a:
    forall x y : carrier, 
      triangle x y -> triangle y x -> x = y.

  Axiom axiom3b:
    forall x y z : carrier, 
    triangle x y ->
    (~ (In (plus z) x /\ In (minus z) y) /\ ~ (In (plus z) y /\ In (minus z) x)).

  Hint Resolve axiom2a axiom2b.

End ParityComplex.

Module ParityComplexTheory (M : ParityComplex).

  Import M.
  Import C.
  Import PPT. 

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma weird_lemma_1 : forall X Y n k,
   Included X (sub Full_set n) ->
   Included Y (sup Full_set k) ->
    ~(n <= k) -> (forall y, In X y /\ In Y y -> False).
  Proof with intuition.
    intros...
    assert (dim y = n)...
    assert (dim y <= k)... apply H0...
    rewrite H2 in H5...
  Qed.

  Lemma well_formed_sup : forall S n, well_formed S -> well_formed (sup S n).
  Proof with intuition.
    intros. 
    apply (well_formed_Included S)... 
  Qed. 

  Lemma well_formed_sub : forall S n, well_formed S -> well_formed (sub S n).
  Proof with intuition.
    intros. 
    apply (well_formed_Included S)... 
  Qed.

  Lemma minimal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set n)
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X y m) -> m = y).
  Proof with intuition.    
    refine (strong_induction _ _ _)...
   
    - apply Cardinality_one_Singleton in H. 
      inversion H; clear H.
      exists x... rewrite H1... 
    
    - assert (Inhabited X).
        apply Cardinal_Sn in H0... 
      inversion H2; clear H2.
   
      set (Z := (fun y => triangle_rest X y x)).

      assert (Z ⊆ X) as SS. 
        unfold Z, Included, In at 1... inversion H2... 

      assert (Finite Z /\ Inhabited Z). 
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0... 
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0... 
        exists x... unfold Z, In at 1... left... 

      assert (exists k, Cardinal Z (S k)) as K. 
        apply Finite_Inhabited_Cardinal_Sn... 
        inversion K as [k L]; clear K... 
    
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L... 
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n). 
          assert (S (S k) <= S (S n))... 
            refine (Cardinal_le Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n... 

        inversion H2; clear H2.
    
        * assert (X == Z). 
            apply (Cardinal_eq_Included_Same_set (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧ 
             (∀ y : carrier, y ∈ W → triangle_rest W y m → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply Cardinal_Setminus... rewrite H6... 
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
 
          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ). 
            apply axiom3a. apply (rest_implies_full X). rewrite H12...
            apply (rest_implies_full X). assert (In X maxZ)... apply H7. rewrite H2 in H11... 
          rewrite <- H11 in H7... 
          unfold W, In at 1, Setminus in H7...
          induction H10... 
            left... 
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear x0 H15.
            assert (z = x). 
            apply axiom3a. apply (rest_implies_full X). assert (In Z z)... 
            rewrite <- H2... apply triangle_rest_in_set in H12... 
            apply (rest_implies_full X). apply (tr_trans _ _ y)... 
            rewrite H13 in H7. 
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
          
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z y m → m = y)) as M.
          refine (H (S k) _ _ _ n0 _ )... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          induction H10.  
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ z)...
            apply (tr_trans _ _ y)... 
  Qed.

  Lemma maximal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set n)
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y).
  Proof with intuition.   
    refine (strong_induction _ _ _)...
   
    - apply Cardinality_one_Singleton in H. 
      inversion H; clear H.
      exists x... rewrite H1... 
    
    - assert (Inhabited X).
        apply Cardinal_Sn in H0... 
      inversion H2; clear H2.
   
      set (Z := (fun y => triangle_rest X x y)).

      assert (Z ⊆ X) as SS. 
        unfold Z, Included, In at 1... 
        apply triangle_rest_in_set in H2...

      assert (Finite Z /\ Inhabited Z). 
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0... 
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0... 
        exists x... unfold Z, In at 1... left... 

      assert (exists k, Cardinal Z (S k)) as K. 
        apply Finite_Inhabited_Cardinal_Sn... 
        inversion K as [k L]; clear K... 
    
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L... 
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n). 
          assert (S (S k) <= S (S n))... 
            refine (Cardinal_le Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n... 

        inversion H2; clear H2.
    
        * assert (X == Z). 
            apply (Cardinal_eq_Included_Same_set (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧ 
             (∀ y : carrier, y ∈ W → triangle_rest W m y → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply Cardinal_Setminus... rewrite H6... 
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
 
          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ). 
            apply axiom3a. 
            apply (rest_implies_full X). assert (In X maxZ)... apply H7. 
            rewrite H2 in H11...
            apply (rest_implies_full X). rewrite H12... 
          rewrite <- H11 in H7... 
          unfold W, In at 1, Setminus in H7...
          apply triangle_rest_equiv in H10...
          apply triangle_rest_equiv.
          induction H10... 
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear z H15.
            assert (x0 = x). 
            apply axiom3a. apply (rest_implies_full X). assert (In Z x0)... 
            rewrite <- H2... 
            apply triangle_rest_equiv in H12.
            apply triangle_rest_in_set in H12... 
            apply triangle_rest_equiv.
            right with y... 
            apply (rest_implies_full X). 
            assert (In Z x0)... rewrite <- H2. 
            apply triangle_rest_equiv in H12. apply triangle_rest_in_set in H12... 
            rewrite H13 in H7. 
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
          
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z m y → m = y)) as M.
          refine (H (S k) _ _ _ n0 _)... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          apply triangle_rest_equiv in H10.
          apply triangle_rest_equiv.
          induction H10.  
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ x0)...
            apply triangle_rest_equiv...
            right with y...
  Qed.

  Lemma minimal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X -> 
         ∀ n : nat,
         X ⊆ sub Full_set n -> 
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X y m → m = y).
  Proof with intuition.
    intros X H1. 
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn... 
    inversion H; clear H. 
    apply (minimal_exists x)...
  Qed.

  Lemma maximal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X -> 
         ∀ n : nat,
         X ⊆ sub Full_set n -> 
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X m y → m = y).
  Proof with intuition.
    intros X H1. 
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn... 
    inversion H; clear H. 
    apply (maximal_exists x)...
  Qed.

  Lemma wf_maximal_exists : 
    forall X n, Finite X /\ Inhabited X /\ (X ⊆ sub Full_set (S n)) -> 
      well_formed X -> 
        exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    idtac... 
        unfold well_formed in H0... 
        inversion H; clear H... 
        set (Z := fun s => triangle_rest X x s).
        assert (Finite Z /\ Inhabited Z)... 
          apply (Finite_Included'' X)...
          unfold Z, Included, In at 1... apply triangle_rest_in_set in H... 
          assert ((triangle_rest X x x0) \/ ~(triangle_rest X x x0))...
            apply triangle_rest_dec... 
          exists x... unfold Z, In at 1... left... 
        assert (∃ m : carrier, m ∈ Z ∧ (∀ y : carrier, y ∈ Z → triangle_rest Z m y → m = y)). 
          refine (maximal_exists' _ _ (S n) _ )...
          apply (Included_trans _ X)... unfold Z. crush. apply triangle_rest_in_set in H... 
          unfold Z, Included...
        inversion H as [m K]; clear H. 
        exists m...
        unfold Z, In at 1 in H...
        apply triangle_rest_in_set in H... 
        constructor... 
        apply In_Intersection in H8... 
        inversion H10; clear H10...
        assert (less m x1).
          exists x0...
        assert (m = x1). 
          apply H7... 
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          right with x1... left...
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          rewrite H12 in H8.
          inversion H8... apply In_Intersection in H13...
  Qed.
 
  Lemma PlusMinus_Inhabited : 
    forall X n,
      Included X (sub Full_set (S n)) -> 
      Finite X -> 
      Inhabited X ->
      Inhabited (PlusMinus X).
  Proof with intuition.
    intros...
    assert (Finite (PlusMinus X))...
    apply Finite_Empty_or_Inhabited in H2... 
    exfalso. rename H3 into H2. 
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X m y) -> m = y)).
      refine (maximal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (plus max)). 
      apply plus_Inhabited. apply H in H2. subsuptac... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d). 
    apply H3. 
    unfold PlusMinus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Plus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less max r). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ r)... left...
    rewrite H9 in H7; unfold less in H7... 
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)... 
    idtac... 
  Qed.

  Lemma MinusPlus_Inhabited : 
    forall X n,
      Included X (sub Full_set (S n)) -> 
      Finite X -> 
      Inhabited X ->
      Inhabited (MinusPlus X).
  Proof with intuition.
    intros...
    assert (Finite (MinusPlus X))...
    apply Finite_Empty_or_Inhabited in H2... 
    exfalso. rename H3 into H2. 
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X y m) -> m = y)).
      refine (minimal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (minus max)). 
      apply minus_Inhabited. apply H in H2. subsuptac... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d). 
    apply H3. 
    unfold MinusPlus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Minus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less r max). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ max)... left...
    rewrite H9 in H7; unfold less in H7... 
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)... 
    idtac... 
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 1                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_1_1 : 
    forall x, 
    (Plus (plus x)) ∩ (Minus (minus x)) == (Empty_set) == (Plus (minus x)) ∩ (Minus (plus x))
    /\
    (MinusPlus (minus x)) == Intersection (Minus (minus x)) (Minus (plus x)) == (MinusPlus (plus x))
    /\
    (PlusMinus (minus x)) == Intersection (Plus (minus x)) (Plus (plus x))   == (PlusMinus (plus x)).
  Proof with repeat basic; auto.
    remember axiom3b as axiom3b. clear Heqaxiom3b.
    assert (H: forall x y, (In (Plus (plus x)) y /\ In (Minus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus, In in H0.  
      unfold Minus, In in H1...
      rename x0 into v. rename x1 into w. 
      assert (less w v).
        unfold less. refine (Inhabited_intro  _ _ u _)... 
      assert (triangle w v). 
        right with v...  left... 
      apply (axiom3b _ _ x) in H4...

    assert (K: forall x y, (In (Minus (plus x)) y /\ In (Plus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus in H2. unfold In in H2. 
      unfold Minus in H1. unfold In in H1...
      rename x0 into v. rename x1 into w. 
      assert (less v w).
        unfold less. refine (Inhabited_intro _ _ u _)... 
      assert (triangle v w). 
        right with w... 
        left... 
      apply (axiom3b _ _ x) in H5...

    intros; split; split.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (H x x0)...
    symmetry.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (K x x0)...
 
    split; unfold MinusPlus, Same_set, Included... rename x0 into y.
    assert (In (Union (Plus (minus x)) (Minus (plus x))) y).
      rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0... 
    apply In_Complement... apply (K x x0)...

    unfold Same_set, Included...
    apply In_Complement... apply (H x x0)...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0... 

    split; unfold PlusMinus, Same_set, Included...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (H x x0)...
    
    unfold Same_set; unfold Included...
    apply In_Complement... apply (K x x0)...
    assert (In (Union (Plus (minus x)) (Minus (plus x))) x0).
    rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0... 
  Qed.

  Lemma Prop_1_2 :
    forall u v x,
    triangle u v ->
    In (plus x) v ->
    (minus u) ∩ (Plus (minus x)) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included... 
     - unfold Plus in H3. 
       unfold In at 1 in H3... 
       rename x1 into w. 
       assert (less w u). 
         exists x0... 
       assert (triangle w v). 
         right with u...
       exfalso. 
       apply (axiom3b _ _ x) in H5...
     - inversion H1. 
     - inversion H1.
  Qed.

  Lemma Prop_1_2_dual :
       forall u v x : carrier,
       triangle v u -> v ∈ minus x -> plus u ∩ Minus (plus x) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included... 
     - unfold Minus in H3. 
       unfold In at 1 in H3... 
       rename x1 into w. 
       assert (less u w). 
         exists x0... 
       assert (triangle v w). 
         unfold triangle.
         apply clos_rt_rt1n_iff.
         apply clos_rt_rtn1_iff. 
         refine (Relation_Operators.rtn1_trans _ _ v u w _ _)... 
         apply clos_rt_rtn1_iff. 
         apply clos_rt_rt1n_iff...
       exfalso. 
       apply (axiom3b _ _ x) in H5...
     - inversion H1. 
     - inversion H1.
  Qed.

  Lemma Prop_1_3 : 
    forall R S', Finite R ->
      tight R -> well_formed S' -> R ⊆ S' -> is_a_segment R S'.
  Proof with repeat basic; auto.
    unfold is_a_segment.
    unfold tight.
    unfold well_formed.
    unfold triangle. 
    intros R S' RFin... 
    assert (exists m, (dim x = S m)) as K.
      inversion H4... apply plus_dim in H8. exists (dim x0). auto.  
    rename x into w. rename y into u. rename z into v.
    assert (dim w = dim u) as J. apply equal_dim. unfold triangle. 
      right with u... left... 
    inversion H4 as [y]...
    assert (minus u ∩ PlusMinus R == Empty_set) as L.
      apply (H u v). 
      apply (rest_implies_full S')...
      assumption.  
    assert (~(In (PlusMinus R) y)) as M.
      unfold not; intros... assert (In (Empty_set) y). 
      rewrite <- L... inversion H11. unfold not in M.
    assert (In (Plus R) y) as N.
      unfold Plus. unfold In. exists w...
    assert (In (Minus R) y) as P. 
      assert (y ∈ Minus R \/ ~(y ∈ Minus R)). 
        apply all_decidable...
      inversion H0. assumption. exfalso. apply M.
      unfold PlusMinus...
    inversion P as [z]...
    assert (u = z).
      refine (H3 _ _ _ x _ _ _)...   
      assert (forall T u' v', In T v' -> triangle_rest T u' v' -> In T u') as Q...
        inversion H13... 
      apply (Q _ u v)...
      rewrite <- J. apply H8. 
      apply minus_dim in H12. rewrite <- H12. rewrite <- H8.
      apply plus_dim in H9...
      unfold perp in H0...
      apply Disjoint_Intersection_condition in H14. 
      inversion H14. apply (H0 y)...
      rewrite H0...
  Qed.

  Lemma xplus_is_tight :
    forall x, tight (plus x).
  Proof with repeat basic; auto.
    unfold tight; intros.
    assert (Intersection (minus u) (Plus (minus x)) == Empty_set) as A. 
      apply (Prop_1_2 u v)...
    assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as B. 
      apply (Prop_1_1 x). 
    rewrite <- B. 
    rewrite <- Intersection_trans. 
    rewrite A.
    unfold Same_set, Included; split; intros... inversion H1. 
  Qed.

  (* Section 2 *)
  
  Lemma Observation_p322 :
    forall (T Z : Ensemble carrier),
    well_formed (Union T Z) ->
    Disjoint T Z ->
    Perp T Z. 
  Proof with repeat basic; auto.
    intros T Z WF Disj. remember (Union T Z) as S'.
    unfold well_formed in WF... 
    rename H into WF0.
    rename H0 into WFSn. 
    rename H1 into Disj.
    unfold Perp...

    apply Disjoint_Intersection_condition. constructor. unfold not in *. 
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Plus in PT. unfold In in PT.
    unfold Plus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (x0 = x1). 
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left... 
    apply H. assumption. 
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H6. 
    inversion H6 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
 
    apply Disjoint_Intersection_condition. constructor. unfold not in *. 
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Minus in PT. unfold In in PT.
    unfold Minus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (x0 = x1). 
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left... 
    apply H. assumption. 
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H7. 
    inversion H7 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Cells                                                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

    Definition Same_pair (A B: Ensemble carrier * Ensemble carrier) : Prop.
  inversion A as [M  P ].
  inversion B as [M' P'].
  exact (M == M' /\ P == P').
  Defined.

  Hint Unfold Same_pair.

  Notation " F === G" := (Same_pair F G) (at level 89).

  Definition is_a_cell (G : Ensemble carrier * Ensemble carrier) : Prop.
  inversion G as [M P]. 
  exact ( Inhabited M  /\ Inhabited P /\
    well_formed M /\ well_formed P /\
    Finite M /\ Finite P /\
    (M moves M to P) /\ (P moves M to P)).
  Defined.

  Definition celldim (G : Ensemble carrier * Ensemble carrier) (n : nat) : Prop.
    inversion G as [M P]. 
    exact (setdim (Union M P) n).
  Defined.

  Definition source (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sup M n , sub M n ∪ sup P (n-1)).
  Defined.

  Definition target (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sub P n ∪ sup M (n-1) , sup P n ).
  Defined.

  Definition composable (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Prop :=
    target n A === source n B. 

  Definition composite (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
   inversion A as [M P].
   inversion B as [N Q].
   exact ((M ∪ (N ∩ √(sub N n))), ((P ∩ √(sub P n)) ∪ Q)).
  Defined.

  Definition receptive (S : Ensemble carrier) : Prop :=
    (forall x, (Plus (minus x)) ∩ (Plus (plus x)) ⊆ S ->
       (Inhabited (S ∩ (Minus (minus x))) -> False) ->
       (Inhabited (S ∩ (Minus (plus x))) -> False))  /\ 
    (forall x, (Minus (plus x)) ∩ (Minus (minus x)) ⊆ S ->
       (Inhabited (S ∩ (Plus (plus x))) -> False) ->
       (Inhabited (S ∩ (Plus (minus x))) -> False)).

  Definition cell_receptive (G : Ensemble carrier * Ensemble carrier) : Prop.
    inversion G as [M P].
    exact (receptive M /\ receptive P).
  Qed.

  Hint Unfold is_a_cell.

  Definition is_a_cell' (S T : Ensemble carrier) := is_a_cell (S, T). 

  Hint Unfold is_a_cell'.

  Add Parametric Morphism : (is_a_cell') with 
    signature (@Same_set carrier) ==> (@Same_set carrier) ==> (iff) as is_a_cell_Same_set.
  Proof with intuition.
    intuition. 
    symmetry in H.
    symmetry in H0.
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H... 
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H). 
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
 
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H... 
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H). 
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
  Qed.

  Lemma is_a_cell_Same_set_compat : forall (S S': Ensemble carrier), 
    S == S' -> forall T T', T == T' -> (is_a_cell (S, T) <-> is_a_cell (S', T')).
  Proof.
    intros.
    fold (is_a_cell' S T).
    fold (is_a_cell' S' T').
    rewrite H, H0.
    intuition. 
  Qed.

  Lemma Same_set_is_a_cell : forall S T, 
    is_a_cell (S, T) -> forall S' , S == S' -> forall T', T == T' -> is_a_cell (S', T').
  Admitted. 

  (* I think this must be Prop_3_3 and i'm a bit confused *)
  Axiom cells_are_receptive : forall M P, is_a_cell (M, P) -> receptive M /\ receptive P.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma cell_has_dim : forall M P, is_a_cell (M, P) -> exists m, celldim (M, P) m.
  Proof with repeat basic; auto.
    intros.
    unfold is_a_cell in H...
    assert (Finite (Union M P)). 
    apply Finite_Union.
    apply all_decidable... 
    assumption.
    assumption. 
    apply Finite_carrier_have_max_dim_element in H6.
    inversion H6 as [m]; clear H6... 
    exists (dim m).
    unfold celldim. 
    unfold setdim.
    intros...
    inversion H8; apply H9...
    inversion H0. 
    apply (Inhabited_intro _ _ x). 
    left...
  Qed.

  Lemma target_dim : forall M P, is_a_cell (M, P) -> forall m, 
    (celldim (target m (M, P)) m).
  Proof with intuition.
    intros...
    unfold target, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1... 
    apply (le_trans _ (m-1))... 
  Qed.

  Lemma source_dim : forall M P, is_a_cell (M, P) -> forall m, 
    celldim (source m (M, P)) m.
  Proof with intuition.
    intros...
    unfold source, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (m-1))...
  Qed.

 Lemma cell_dim_n_property : 
    forall M P, is_a_cell (M, P) -> forall n, celldim (M, P) n -> sub M n == sub P n.
  Proof with intuition.
    intros M P K n J.
    unfold is_a_cell in K... unfold moves_def in *...
    unfold sub, Same_set, Included, In...

    fold (In P x). rewrite H6.
    repeat basic. left... apply In_Complement. unfold not... 
    unfold In, Minus in H7. inversion H7; clear H7... apply minus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...

    fold (In M x). rewrite H9.
    repeat basic. left... apply In_Complement. unfold not... 
    unfold In, Plus in H7. inversion H7; clear H7... apply plus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...
  Qed.     

  Lemma M_n_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        Inhabited (sub M (S n)) ->
        Inhabited (sub M (  n)).
  Proof with intuition. 
    intros...

    assert (exists m, In (sub M (S n)) m /\ (forall y, In (sub M (S n)) y -> (triangle_rest (sub M (S n)) y m) -> (m = y))).
      refine (minimal_exists' _ _ (S n) _)...
      refine (Finite_sub M _ (S n)). apply H.
      unfold sub, Included... unfold In at 1. unfold In at 1 in H1...
    inversion H1 as [w J]; clear H1...
    assert ( MinusPlus (sub M (S n)) ⊆ sub M n). 
      assert (MinusPlus M ⊆ M). 
        unfold is_a_cell in H...
        apply Prop_2_1... exists P... 
      unfold MinusPlus, Plus, Minus, sub, Included... 
      apply In_Intersection in H4...
      unfold In at 1 in H5. unfold Complement, not, In at 1 in H6.
      unfold In at 1...
      apply H3. unfold MinusPlus...
      apply In_Intersection...
      inversion H5 as [p Q]; clear H5.
      exists p... unfold In in H4...
      apply In_Complement... apply H6.
      unfold In at 1. unfold Plus, In at 1 in H4. inversion H4 as [t T].
      exists t...
      unfold In at 1...
      apply plus_dim in H8.
      inversion H5 as [y Y]; clear H4...
      unfold In at 1 in H4...
      apply minus_dim in H9. rewrite <- H8, H9...
      inversion H5 as [y Y]; clear H5...
      unfold In at 1 in H4...
    assert (Finite (sub M n)). 
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso. 
    assert (MinusPlus (sub M (S n)) == Empty_set). 
      apply (Included_Empty_set _ (sub M n))...
    assert (forall x, In (Minus (sub M (S n))) x -> (In (Plus (sub M (S n)))) x)...
      assert (x ∈ Plus (sub M (S n)) \/ ~(x ∈ Plus (sub M (S n))))... 
        apply all_decidable... 
        apply Plus_Finite. apply Finite_sub... apply H.
      exfalso. 
      assert (In (MinusPlus (sub M (S n))) x); unfold MinusPlus...
      rewrite H4 in H7. inversion H7...
    assert (Inhabited (minus w))... 
      apply minus_Inhabited. assert (dim w = (S n))... apply H1. rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Plus (sub M (S n))). 
      apply H6... exists w...
    unfold Plus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less z w). 
      unfold less. exists p... 
    assert (w = z). 
      apply H2... apply (tr_trans _ _ w)... left...
    subst. unfold less in H9...
  Qed.

  Lemma P_n_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        Inhabited (sub P (S n)) ->
        Inhabited (sub P (  n)).
  Admitted. (* as above *)

  Lemma M_n_Empty_set : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        sub M (  n) == Empty_set ->
        sub M (S n) == Empty_set.
  Proof with intuition. 
    intros...
    assert (Finite (sub M (S n))).
      unfold is_a_cell in H... 
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (M_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma P_n_Empty_set : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        sub P (  n) == Empty_set ->
        sub P (S n) == Empty_set.
  Proof with intuition. 
    intros...
    assert (Finite (sub P (S n))).
      unfold is_a_cell in H... 
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (P_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma M_0_not_empty : 
    forall M P, 
      is_a_cell (M, P) -> 
       ((sub M 0) == Empty_set) -> False.
  Proof with intuition. 
    unfold not... 
    assert ( forall n, ((sub M n) == Empty_set))...
      induction n...
      apply (M_n_Empty_set M P)... 
    unfold is_a_cell in H...
    inversion H2 as [z W]...
    assert (Inhabited (sub M (dim z)))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma P_0_not_empty : 
    forall M P, 
      is_a_cell (M, P) -> 
       ((sub P 0) == Empty_set) -> False.
  Proof with intuition. 
    unfold not... 
    assert ( forall n, ((sub P n) == Empty_set))...
      induction n...
      apply (P_n_Empty_set M P)... 
    unfold is_a_cell in H...
    inversion H as [z W]...
    assert (Inhabited (sub P (dim z)))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma M_0_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      exists z, (sub M 0) == Singleton z.
  Proof with intuition. 
    intros.
    assert (Inhabited (sub M 0)).
      assert (Finite (sub M 0)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (M_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H2...
        apply H0. apply J. 
      rewrite H1... 
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma P_0_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      exists z, (sub P 0) == Singleton z.
  Proof with intuition. 
    intros.
    assert (Inhabited (sub P 0)).
      assert (Finite (sub P 0)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (P_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H3...
        apply H0. apply J. 
      rewrite H1... 
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma M_0_Inhabited' : 
    forall M P, 
      is_a_cell (M, P) -> Inhabited (sub M 0).
  Proof with intuition. 
    intros.
    assert (Finite (sub M 0))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso. 
    apply (M_0_not_empty M P)...
  Qed.

  Lemma P_0_Inhabited' : 
    forall M P, 
      is_a_cell (M, P) -> Inhabited (sub P 0).
  Proof with intuition. 
    intros.
    assert (Finite (sub P 0))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso. 
    apply (P_0_not_empty M P)...
  Qed.

  Lemma source_is_a_cell : forall (m : nat) (M P : Ensemble carrier), 
    is_a_cell (M, P) -> 
    celldim (M, P) (S m) -> 
    forall n, 
      n <= m -> 
      is_a_cell (source n (M, P)).
  Proof with intuition.
    intros m M P MPcell MPdim n nltm.
    unfold source.
    
    destruct n.
    - apply (Same_set_is_a_cell (sub M 0) (sub M 0))... 
        apply M_0_Inhabited in MPcell. 
        inversion MPcell; clear MPcell. 
      apply (Same_set_is_a_cell (Singleton x) (Singleton x))... 
      assert (dim x = 0) as dimx.
        assert (In (sub M 0) x)... rewrite H...
      unfold is_a_cell... 
        exists x...
        exists x...
 
      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...

    assert (sup P (0 - 1) == Empty_set) as AA. admit. (* coding issue *)
    rewrite AA. 
    rewrite Empty_set_ident_right...

    - rewrite Sn_minus_1. 
      unfold is_a_cell in *...

  + assert (Inhabited (sub M 0)). 
      assert (exists z, (sub M 0) == Singleton z). apply (M_0_Inhabited M P). unfold is_a_cell... 
      inversion H6; clear H6. exists x... rewrite H8... 
    inversion H6. exists x... repeat subsuptac... rewrite H10...

  + assert (Inhabited (sub P 0)). 
      assert (exists z, (sub P 0) == Singleton z). 
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8... 
    inversion H6. exists x... right. repeat subsuptac... rewrite H10...

  + apply well_formed_sup... 
      
  + apply well_formed_Union...
      apply well_formed_sub... 
      apply well_formed_sup... 
      assert (dim x = S n)...
      assert (dim y <= n)...
      rewrite <- H8, H6 in H11...

  + apply Finite_Union...

  + unfold moves_def in *...
    rewrite <- (sup_Plus M (n)).
    rewrite <- (sup_Minus M (n)).
    unfold Same_set, Included. repeat (basic; intuition).
      left. apply (sub_sup_Included M (S n))...
      rewrite H6 in H10. unfold sup, In at 1 in H10...
      repeat (basic; intuition). 
      left. subsuptac...
      apply In_Complement... repeat (subsuptac; intuition). rewrite H12 in H13... 
      apply In_Complement...
      rewrite H6 in H10. unfold sup, In at 1 in H10...
      apply In_Intersection in H11... 
      unfold sup, In at 1 in H7...
      unfold sup, In at 1 in H7...
      inversion H12; clear H12... clear H7 m0.
      right. rewrite H6... subsuptac... repeat (basic; intuition). apply In_Complement...
      right. assert (Included (PlusMinus M) P). apply Prop_2_1_dual... exists M...
      unfold sup, In at 1... apply H10. unfold PlusMinus... basic... apply H7. 
      apply In_Complement... 
    rewrite <- (sup_Plus M (n)).
    rewrite <- (sup_Minus M (n)).
    unfold Same_set, Included. repeat (basic; intuition).
      unfold sup, In at 1 in H7... 
      inversion H11; clear H11... 
      left. left. unfold sup, In at 1...
      clear H7 m0. 
      rewrite H8 in H10... 
      rewrite (Union_trans). right. rewrite <- sup_Union. 
      unfold sup, In at 1... apply In_Intersection in H10...
      apply In_Complement... rewrite H8 in H7... rewrite (sup_Intersection) in H7. 
      basic... unfold sup, In at 1 in H10...
      unfold sup, In at 1 in H12...
      apply (sub_sup_Included M (S n))...
      rewrite H8. unfold sup, In at 1...
      basic... left. apply (sup_Included P n)... 
      apply In_Complement...
      assert (Included (MinusPlus M) M). apply Prop_2_1... exists P...
      unfold sup, In at 1...  apply H10... unfold MinusPlus... 
      basic...  apply H7. apply In_Complement...

  + unfold moves_def in *...
    rewrite Plus_Union, Minus_Union.
    rewrite <- Union_Complement_compat.
    unfold Same_set, Included. repeat (basic; intuition).
      left. apply (sub_sup_Included M (S n))...
      unfold sup, In at 1 in H10...
      inversion H11; clear H11...  
      rewrite H6 in H7; repeat (basic; intuition). right; left... rewrite <- sub_Plus... 
      rewrite H5 in H7; repeat (basic; intuition). left... unfold sup, In at 1... 
      right; right... unfold Plus, In at 1 in H7... inversion H7; clear H7... exists x0... 
      unfold sup, In at 1...  assert (S (dim x) = dim x0)...  rewrite <- H11... 
      apply In_Complement... assert (dim x = S n)... assert (dim x = n)...
      apply (Minus_dim (sub M (S n)) Full_set)... rewrite H12 in H11... 
      unfold sup, In at 1 in H10... 
      rewrite H6 in H7... rewrite <- sub_Minus... apply In_Intersection in H7...
      apply In_Complement...      apply H12...  apply H7...
      apply In_Complement... assert (dim x = S n)... 
      unfold Minus, In at 1 in H7... inversion H7; clear H7... assert (dim x0 <= n)... 
      assert (S (dim x) = dim x0)... rewrite <- H14, H11 in H12...
      unfold sup, In at 1 in H10... rewrite H5 in H7... apply In_Intersection in H7... 
      apply In_Complement... apply H12... unfold Minus, In at 1 in H7... 
      inversion H7; clear H7... exists x0... apply H7... 
      unfold sup, In at 1 in H11... 
      inversion H13; clear H13... 
      inversion H14; clear H14... rewrite H8 in H10; repeat (basic; intuition)... exfalso. apply H7...
      rewrite <- sub_Minus... subst. rewrite H9 in H10; repeat (basic; intuition)... right... 
      exfalso. apply H12... rewrite <- sup_Minus...
      right... unfold sup, In at 1... apply (Prop_2_1_dual M P)... exists M...
      unfold PlusMinus. basic... apply (Plus_Included (sub M (S n)))... apply In_Complement... apply H7...
      rewrite <- sub_Minus... subsuptac... rewrite <- sub_Plus in H10... rewrite <- sub_Plus in H10...  assert (dim x = n)...
      rewrite H11...  
      right... unfold sup, In at 1... apply (Prop_2_1_dual P P)... exists M...
      unfold PlusMinus. basic... apply (Plus_Included (sup P (n)))... apply In_Complement... apply H12...
      unfold Minus, In at 1...  unfold Minus, In at 1 in H11... inversion H11; clear H11... 
      exists x0... assert (S (dim x) = dim x0)... subsuptac... rewrite <- H13... 
      unfold Plus, In at 1 in H10...  inversion H10...  assert (dim x1 <= n)...
      assert (S (dim x) = dim x1)... rewrite H18... 
      apply (le_trans _ (S (dim x)))... 
      apply (Plus_dim' (sup P n))...
    rewrite Plus_Union, Minus_Union.
    rewrite <- Union_Complement_compat.
    unfold Same_set, Included. repeat (basic; intuition).
      unfold sup, In at 1 in H7...
      inversion H11; clear H11... left; left...
      inversion H12; clear H12...  
      rewrite H8 in H10; repeat (basic; intuition). left;right... right; left...
      rewrite <- sub_Minus...
      rewrite H9 in H10; repeat (basic; intuition). left;right... right;right... 
      rewrite <- sup_Minus...
      apply In_Complement... rewrite <- sub_Plus in H10... repeat (subsuptac)...
      rewrite H8 in H11; repeat (basic; intuition)...
      apply In_Complement... unfold sup, In at 1 in H7... 
      rewrite H9 in H11. apply In_Intersection in H11... apply H13... apply (Plus_Included (sup P n))...
      repeat (subsuptac)... rewrite H13... 
      unfold sup, In at 1 in H10... unfold sup, In at 1...
      inversion H13; clear H13... rewrite H6 in H11; repeat (basic; intuition)... exfalso.
      apply H7... rewrite <- sub_Plus... 
      rewrite H5 in H11; repeat (basic; intuition)... exfalso.
      apply H12... unfold Plus, In at 1 in H11. inversion H11; clear H11... exists x0... subsuptac... 
      assert (S (dim x) = dim x0)... rewrite <- H13, <- H14...
      rewrite <- sub_Minus  in H10... 
      repeat (subsuptac)... assert (Included (MinusPlus M) M). 
      apply (Prop_2_1 M M)... exists P...  apply H10... unfold MinusPlus; repeat (basic; intuition)... 
      apply In_Complement...  apply H7... rewrite <- sub_Plus... rewrite H13... 
      assert (S (dim x) <= n). apply (Minus_dim' (sup P n))... 
      repeat (subsuptac)... assert (Included (MinusPlus P) M). 
      apply (Prop_2_1 P M)... exists P...  apply H13... unfold MinusPlus; repeat (basic; intuition)... 
      unfold Minus, In at 1 in H10. inversion H10; clear H10... exists x0... apply H10... 
      apply In_Complement...  apply H12... 
      unfold Plus, In at 1 in H14. inversion H14; clear H14... exists x0... subsuptac... 
      assert (S (dim x) = dim x0)... rewrite <- H15...
  Qed.

  Lemma target_is_a_cell : forall (n : nat) (M P : Ensemble carrier), 
    is_a_cell (M, P) -> is_a_cell (target n (M, P)).
  Proof with intuition.
    admit. (* as above *)
  Qed.

  Lemma maximal_property :
    forall X, Finite X -> Inhabited X -> forall n, Included X (sub Full_set n) 
      -> exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    intros X hyp1 hyp2 n hyp3.
    assert (exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y)) as hyp4.
      refine (maximal_exists' _ _ n _)...
    inversion hyp4 as [m]; clear hyp4...
    exists m...
    apply Disjoint_Intersection_condition. 
    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H...
      unfold Minus, In at 1 in H3...
      inversion H3 as [z]; clear H3...
      assert (less m z). unfold less. exists x... 
      assert (m = z). apply H1... apply (tr_trans _ _ z)... left... 
      rewrite H5 in H; unfold less in H... pose (plus_minus_Disjoint z)...
      inversion d... inversion H. apply (H6 x0)...
    inversion H.
  Qed.

  Lemma Finite_eq_decidable : forall T, @Finite carrier T -> forall R, Finite R -> ((T == R) \/ ~(T == R)).
  Proof with intuition.
    intros T TFin.
      induction TFin; intros. 
      - apply Finite_Empty_or_Inhabited in H... 
        right...
        rewrite <- H in H0; inversion H0...
      - assert ((In R x) \/ ~(In R x))...
          apply all_decidable...
        + assert (R == Add (Setminus R (Singleton x)) x).
            apply add_subtract...
          assert (A == (Setminus R (Singleton x)) ∨ (A == (Setminus R (Singleton x)) → False))...
            apply IHTFin...
            apply Setminus_Finite'...
          * left...
            rewrite H4...
          * right...
            apply H4...
            rewrite <- H3...
            unfold Same_set, Included, Setminus...
            unfold In at 1...
            inversion H6; clear H6. apply H; rewrite H7...
            unfold In at 1 in H5...
            unfold Add in H6... apply In_Union in H6... 
        + right... apply H2...  rewrite <- H1... 
      - rewrite H...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 3                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_3_1 :
    forall x M P, 
      (plus x) moves M to P ->
      receptive M ->
      (minus x) moves M to P.
  Proof with intuition. 
    intros. 
    assert (exists P', plus x moves M to P'). 
      exists P... 
    apply Prop_2_1 in H1...
    assert (MinusPlus (minus x) == MinusPlus (plus x)).
      remember (Prop_1_1 x) as prop_1_1. 
      apply (Same_set_trans _ (Minus (minus x) ∩ Minus (plus x))). apply prop_1_1. apply prop_1_1. 
    assert (MinusPlus (minus x) ⊆ M). unfold Included...
    assert (Disjoint M (Plus(minus x))). 
      unfold receptive in H0... constructor... 
      apply (H6 x). 
      Focus 3. apply (Inhabited_intro _ _ x0)...
      Focus 2. intros... inversion H7; clear H7... 
      unfold moves_def in H... rewrite H9 in H8...
        rewrite Intersection_trans in H8. repeat basic...
      unfold moves_def in H... unfold Included...
        assert ((In (Plus (plus x)) x1) \/ ~(In (Plus (plus x)) x1))... apply all_decidable... 
        pose (Prop_1_1 x)... exfalso. assert (In (Empty_set) x1). rewrite <- H12...
        apply In_Intersection... apply In_Intersection in H... inversion H14.
        rewrite H8... apply In_Intersection... right... apply In_Intersection in H...
    assert (exists Y, minus x moves M to Y). 
      apply Prop_2_1... 
    inversion H6 as [P']; clear H6.
    assert (P == P'). 
      unfold moves_def in H7... 
      rewrite H6. 
      symmetry. 
      rewrite I_U_dist_r. 
      pose (Prop_1_1 x)... 
      unfold PlusMinus in H7. rewrite H7. 
      unfold moves_def in H... 
      rewrite H12.
      rewrite I_U_dist_r.
      assert ((Plus (plus x) ∩ √Minus (plus x)) == (Plus (minus x) ∩ Plus (plus x))).        
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... assert (In (Empty_set) x0)... rewrite H11. apply In_Intersection...
      assert ((M ∩ √Minus (plus x)) == (M ∩ √Minus (plus x) ∩ √Plus (minus x))). 
        unfold Same_set; unfold Included; repeat (basic; intuition).
          apply In_Complement... apply (H17 x0)...
      assert ((M ∩ √Minus (minus x)) == (M ∩ √Minus (minus x) ∩ √Plus (plus x))). 
        unfold Same_set; unfold Included; repeat (basic; intuition). 
        apply In_Complement... apply (H5 x0). apply In_Intersection... 
      rewrite H, H16, H17. 
      repeat rewrite (Intersection_trans M _ _). 
      repeat rewrite Union_Complement_compat.
      rewrite (Union_sym (Minus (minus x)) _). 
      rewrite (axiom1 x).
      rewrite (Union_sym _ (Minus (plus x)))...
      
    unfold moves_def in *... 
      rewrite H6... 
      rewrite H6... 
  Qed.

  Lemma Prop_3_3 : (forall M P : Ensemble carrier, is_a_cell (M, P) -> cell_receptive (M, P)).
  Proof with intuition.
  Admitted. (* this is not straight-forward *)
   
  Definition Lemma_3_2_b_st : nat -> nat -> Prop := 
    (fun n => (fun m => 
    forall (X : Ensemble carrier), 
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S n))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M n))) ->
    is_a_cell ( (sup M (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)), (sup P (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)) )
    /\ (Minus X ∩ (sub M n)) == Empty_set))).

  Definition Lemma_3_2_c_st : nat -> nat -> Prop := 
    (fun n => (fun m => 
    forall (X : Ensemble carrier), 
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S n))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M n))) ->
    is_a_cell ( (sup M (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)) ∪ X, P ∪ X)
    ))).

  Lemma Lemma_3_2_b_n_0 : forall n, Lemma_3_2_b_st n 0.
  Proof with intuition.
    intros n.
    unfold Lemma_3_2_b_st.
    intros X Xcard. 
    assert (X == Empty_set) as XEmpty. 
      apply Cardinality_zero_Empty_set; assumption.
    assert (Finite X) as XFinite.
      apply (Cardinal_are_Finite 0)...
    intros M P H. 
    inversion H as [MPcell MPdim]; clear H. 
    intros H.
    inversion H as [Xdim K]; clear H. 
    inversion K as [Xwf Xcond]; clear K. 
    split. 

    (* is_a_cell' *)
    assert (Minus X == Empty_set) as MXE. 
      rewrite XEmpty.
      unfold Minus, Same_set, Included, In... inversion H...
    assert (Plus X == Empty_set) as PXE. 
      rewrite XEmpty.
      unfold Plus, Same_set, Included, In... inversion H...
    assert (sup M (n - 1) ∪ ((sub M (n) ∪ Minus X) ∩ √Plus X) == M) as MM. 
      rewrite MXE, PXE. 
      rewrite Complement_Empty_set. 
      rewrite Empty_set_ident_right. 
      rewrite Full_set_ident_right.
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush. 
        assert (dim x <= (n)).
          unfold celldim in *...
        inversion H0; [right | left]... 
          basic... rewrite Sn_minus_1...
    assert (sup P (n - 1) ∪ ((sub M (n) ∪ Minus X) ∩ √Plus X) == P) as PP.
      rewrite MXE, PXE. 
      rewrite Complement_Empty_set. 
      rewrite Empty_set_ident_right. 
      rewrite Full_set_ident_right.
      rewrite (cell_dim_n_property M P).
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= (n)).
          unfold celldim in *...
        inversion H0; [right | left]... 
          basic... rewrite Sn_minus_1...
    assumption. 
    assumption. 
    symmetry in MM; symmetry in PP.
    apply (is_a_cell_Same_set_compat M _ MM P _ PP)... 

    (* Disjoint *)
    apply Disjoint_Intersection_condition.
    constructor. 
    unfold not; intros. 
    basic...
    unfold In, Minus in H0...
    inversion H0 as [z J]...
    assert (In Empty_set z). rewrite <- XEmpty... 
    inversion H3.
  Qed.

  Lemma Lemma_3_2_b_0_1 : Lemma_3_2_b_st 0 1.
  Proof with intuition.
    unfold Lemma_3_2_b_st.
    intros X Xcard M P J K.
    inversion J as [MPcell MPdim]; clear J.
    inversion K as [Xdim L]; clear K.
    inversion L as [Xwf Xcond]; clear L.
    apply Cardinality_one_Singleton in Xcard. 
    inversion Xcard as [x Xsing]; clear Xcard.
    set (Y := ((sub M 0 ∪ Minus X) ∩ √Plus X)).
    
    assert (dim x = 1) as dimx. 
      rewrite Xsing in Xdim.
      autounfold with * in Xdim... apply Xdim... 
    assert (sub M 0 == plus x) as subM0. 
      assert (exists d, sub M 0 == Singleton d).
      apply dim_0_Singleton. 
      apply (M_0_Inhabited' M P)...
      apply MPcell. inversion H as [f L]; clear H.
      assert (plus x == Singleton f). apply Included_Singleton.
      apply plus_Inhabited. rewrite dimx...
      rewrite <- L.
      assert (PlusMinus X == plus x). 
      unfold PlusMinus. rewrite Xsing.
      assert (Plus (Singleton x) ∩ √Minus (Singleton x) == PlusMinus (Singleton x)).
      unfold PlusMinus...
      rewrite H.
      rewrite PlusMinus_Singleton...
      rewrite <- H... rewrite <- H in L...
    assert (Y == minus x) as Ydef. 
      unfold Y. 
      rewrite Xsing, subM0, Plus_Singleton, Minus_Singleton.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_left.
      apply Intersection_Included_left.
      apply Disjoint_property_right.
      apply plus_minus_Disjoint.
    assert (sup M (0 - 1) == Empty_set) as supM0. admit. (* coding issue *)
    assert (sup P (0 - 1) == Empty_set) as supP0. admit. (* coding issue *)
    assert (sup M (0 - 1) ∪ Y == minus x) as HypA.
      unfold is_a_cell in MPcell...
      rewrite supM0, Ydef. 
      rewrite Empty_set_ident_left.
      reflexivity.
    assert (sup P (0 - 1) ∪ Y == minus x) as HypB.
      unfold is_a_cell in MPcell...
      rewrite supP0, Ydef. 
      rewrite Empty_set_ident_left.
      reflexivity.

    split.

    apply (is_a_cell_Same_set_compat _ _ HypA _ _ HypB).
    unfold is_a_cell... 
        apply minus_Inhabited. rewrite dimx. auto.
        apply minus_Inhabited. rewrite dimx. auto. 
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.

      rewrite Xsing, Minus_Singleton, subM0.
      apply Disjoint_Intersection_condition.
      apply Disjoint_sym. apply plus_minus_Disjoint.
  Qed.


  Lemma Lemma_3_2_Step_1' :
    forall n m, (Lemma_3_2_b_st n m) -> (Lemma_3_2_c_st n m).
  Proof with intuition.
    unfold Lemma_3_2_b_st, Lemma_3_2_c_st. 
    intros n m Hyp1 X Xcard M P J K. 
    assert (Finite X) as XFin. apply (Cardinal_are_Finite m)...
    set (Y := ((sub M n ∪ Minus X) ∩ √Plus X))...
    assert (is_a_cell
               (sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X),
                sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X))
             ∧ Minus X ∩ sub M n == Empty_set) as Hyp2.
    apply Hyp1...
    intuition. 
    unfold is_a_cell in *... 
    
    apply (Inhabited_Included (sup M (n - 1) ∪ Y)). assumption. 
    apply Union_Included_cancel_right. reflexivity.

    apply (Inhabited_Included (P)). assumption. 
    apply Union_Included_cancel_right. reflexivity.
      
    (* This whole argument is predicated on the fact that both parts of the union are
       well-formed and that the Intersection is (dimenion-wise) empty *)
    unfold well_formed in *...
    apply In_Union in H28... 
    apply In_Union in H29... 
      exfalso. assert (dim y = S n)...
      rewrite H27 in H29. inversion H29.
    apply In_Union in H29... 
      exfalso. assert (dim x = S n)...
      rewrite H26 in H29. inversion H29.
    apply In_Union in H26...
    apply In_Union in H27...
      refine (H23 _ _ _ n0 _ _ _)... 
      exfalso. 
      assert (dim y = S n)...
      apply In_Union in H30...
        assert (dim x <= n). apply (le_trans _ (n-1))...    
        rewrite H11, <- H28, H27 in H30...
        assert (dim x = n). unfold Y in H31. 
        apply In_Intersection in H31... 
        apply In_Union in H30... 
        inversion H31... assert (dim x0 = S n)... 
        rewrite H11, <- H28, H27 in H30...
    apply In_Union in H27...
      exfalso. 
      assert (dim x = S n)... 
      apply In_Union in H26...
        assert (dim y <= n). apply (le_trans _ (n-1))...    
        rewrite H28, <- H11, H27 in H26...
        assert (dim y = n). unfold Y in H31. 
        apply In_Intersection in H31... 
        apply In_Union in H26... 
        inversion H31... assert (dim x0 = S n)...
        rewrite H28, <- H11, H27 in H26...
        refine (H21 _ _ _ n0 _ _ _)... 

    (* as above *)
    unfold well_formed in *...
    apply In_Union in H28... 
    apply In_Union in H29...
      assert (dim y = S n)... 
      rewrite H27 in H29. inversion H29.
    apply In_Union in H29...
      assert (dim x = S n)... 
      rewrite H26 in H29. inversion H29.
    apply In_Union in H26... 
    apply In_Union in H27...
      refine (H24 _ _ _ n0 _ _ _)... 
      exfalso. 
      assert (dim y = S n)... 
      assert (dim x <= n)... assert (dim x = S n)... rewrite H11, <- H28...
      rewrite H32 in H31...
    apply In_Union in H27...
      exfalso. assert (dim y <= n)... assert (dim x = S n). intuition. 
      assert (dim y = S n). rewrite H28, <- H11, H31... rewrite H32 in H27; apply (le_Sn_n n)...
      refine (H21 _ _ _ n0 _ _ _)...
      
    apply Finite_Union... 
    apply Finite_Union...

    unfold Y. 
    assert ((sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((M ∪ Minus X) ∩ √Plus X))) as JA. admit. (* coding issue *)
    assert ((sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((P ∪ Minus X) ∩ √Plus X))) as JB. admit. (* coding issue *)
    rewrite JA, JB in *.
    unfold moves_def in *...
    rewrite (Plus_Union _ X).
    rewrite (Minus_Union _ X).
    rewrite <- (Union_Complement_compat _ (Minus X)). 
    rewrite Union_trans. rewrite (Union_sym X _). 
    rewrite (Union_trans _ _ X).
    rewrite <- (Union_trans _ _ (Plus X ∪ X)).
    rewrite <- Intersection_trans.
    rewrite I_U_dist_r. 
    rewrite <- H19.
    unfold Same_set, Included; repeat (basic; intuition).  
      assert ((In (Plus X) x) \/ ~(In (Plus X) x))... apply all_decidable... 
      right. repeat (basic; intuition). apply In_Complement... 
        assert (dim x = n)... apply (Plus_dim X)... 
        unfold Minus, In at 1 in H20... inversion H20; clear H20... 
        repeat (basic; intuition). assert (dim x0 <= n)...
        assert (S (dim x) = dim x0)... rewrite <- H31, H27 in H28...
        assert (S (dim x0) = dim x1)... assert (dim x1 = (S n))...
        assert (S (dim x) = dim x0)... 
        rewrite H27 in H33. rewrite H32, H33 in H28... 
      right. apply In_Intersection... apply In_Complement... 
        assert (dim x = S n)...  
        unfold Minus, In at 1 in H20... inversion H20; clear H20... 
        repeat (basic; intuition). assert (dim x0 <= n)...
        assert (S (dim x) = dim x0)... rewrite <- H30, H26 in H27...
        assert (S (dim x0) = dim x1)... assert (dim x1 = (S n))...
        assert (S (dim x) = dim x0)... 
        rewrite H26 in H32. rewrite <- H31, <- H27 in H32...
      apply In_Complement... assert (In (sub M n) x)... 
        rewrite (cell_dim_n_property M P)... unfold sub, In at 1...
        apply (Minus_dim X Full_set)... unfold is_a_cell... 
        assert (In Empty_set x)... rewrite <- H5. apply In_Intersection... 
      apply In_Complement... 
        assert (dim x = S n)... assert ( dim x = n)... apply (Minus_dim X Full_set)... rewrite H27 in H26...
      left. assert (In (sub M n) x)... apply H4... unfold PlusMinus; basic... 
        rewrite (cell_dim_n_property M P) in H25... apply H25... unfold is_a_cell... 

    rewrite (Plus_Union _ X).
    rewrite (Minus_Union _ X).
    rewrite <- (Union_Complement_compat _ (Plus X)). 
    rewrite (Union_trans _ X). rewrite <- (Union_trans X). rewrite (Union_sym (X ∪ Minus ((M ∪ Minus X) ∩ √Plus X)) (Minus X)).
    rewrite <- (Union_trans P).
    rewrite (Intersection_sym (√Plus ((M ∪ Minus X) ∩ √Plus X)) (√Plus X)). 
    rewrite <- Intersection_trans.
    rewrite (I_U_dist_r _ (P ∪ Minus X)). 
    rewrite H23 at 1. 
    unfold Same_set, Included; repeat (basic; intuition). 
      right.
        apply In_Intersection... 
        apply In_Complement... 
        assert (dim x = n)... apply (Plus_dim X (n))... 
        assert (S (dim x) <= n). apply (Minus_dim' _ n) in H25... 
        unfold Included... unfold sup, In at 1... repeat (basic; intuition).
        assert (dim x0 = n)... apply (Minus_dim X Full_set (n))... rewrite H29... 
        rewrite H27 in H28...
      right. repeat (basic; intuition). 
        apply In_Complement... 
         assert (dim x = S n)... 
         assert (dim x = n)... apply (Plus_dim _ n) in H20... 
         rewrite H26 in H27... 
        apply In_Complement... 
         assert (dim x = S n)... 
         assert (dim x <= n)... apply (Plus_dim' _ n) in H20...
         unfold Included... unfold sup, In at 1... repeat (basic; intuition).
         assert (dim x0 = n)... apply (Minus_dim X Full_set (n))... rewrite H28... 
         rewrite H26 in H27...

    unfold Y. 
    assert ((sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((M ∪ Minus X) ∩ √Plus X))) as JA. admit. (* coding issue *)
    assert ((sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((P ∪ Minus X) ∩ √Plus X))) as JB. admit. (* coding issue *)
    rewrite JA, JB in *.
    unfold moves_def in *...

    rewrite (Union_trans _ X _).
    rewrite (Union_sym X _).
    rewrite <- (Union_trans _ _ X).
    rewrite I_U_dist_r.
    assert (X ∩ √Minus (P ∪ X) == X) as G. 
      unfold Same_set, Included; repeat (basic; intuition). apply In_Complement... 
      refine (weird_lemma_1 X (Minus (P ∪ X)) (S n) n _ _ _ x _)...
      unfold sup, Included... unfold In at 1... inversion H26; clear H26... 
      assert (S (dim x0) = dim x1)... basic... 
      assert (dim x1 <= n)... apply (le_trans _ (S (dim x0))). constructor... 
      rewrite H27... 
      assert (dim x1 = (S n))... rewrite <- H27 in H26... 
      inversion H26... 
    rewrite G. clear G. 
    apply Union_mor...
    assert (P == (((P ∪ Minus X) ∩ √Plus X) ∩ √Minus X) ∪ (P ∩ Plus X)) as G. 
      unfold Same_set, Included; repeat (basic; intuition). 
      assert ((In (Plus X) x) \/ ~(In (Plus X) x))... apply all_decidable... 
      left. basic... apply In_Complement... 
      assert (dim x = n)... apply (Minus_dim _ Full_set n) in H25... 
      assert (In (sub M n) x)... rewrite (cell_dim_n_property M P)... unfold is_a_cell... 
      assert (In Empty_set x)... rewrite <- H5... 
    rewrite G; clear G.
    rewrite H17 at 1.
    repeat (rewrite (Plus_Union)).
    repeat (rewrite (Minus_Union)).
    rewrite <- (Union_Complement_compat _ (Minus X)).
    admit. (* ?? *)
(*
    Notation "A # B -# C" := (Intersection (Union A (Minus B)) (Complement (Plus  C))) (at level 89). 
    Notation "A @ B -@ C" := (Intersection (Union A (Plus  B)) (Complement (Minus C))) (at level 89). 
*)

    rewrite (Plus_Union _ X).
    rewrite (Minus_Union _ X).
    rewrite <- (Union_Complement_compat _ (Plus X)). 
    admit. (* ?? *) 
  Qed.

  Lemma Lemma_3_2_Step_2' :
    forall n, ((Lemma_3_2_b_st n 1) -> (forall m, Lemma_3_2_b_st n (S m))).
  Proof with intuition.
    intros n hypothesis_for_1 m.

    induction m. assumption.
 
    unfold Lemma_3_2_b_st in *. 
    intros X Xcard M P H J.
    inversion H as [MPcell MPdim]; clear H.
    inversion J as [Xdim K]; clear J.
    inversion K as [Xwf Xcond]; clear K.

    assert (exists x, In X x /\ Disjoint (plus x) (Minus X)) as R.  (* maximal *)
      apply (wf_maximal_exists X (n))...
      apply (Cardinal_are_Finite (S (S m)))...
      apply Cardinal_Sn in Xcard... 
    inversion R as [x xcond]; clear R. 
    inversion xcond as [xinX disj]; clear xcond.
    assert (dim x = S n) as dimx. idtac...

    assert (plus x ⊆ sub M n) as K. 
      apply (Included_trans _ (PlusMinus X))...
        unfold PlusMinus. rewrite <- (Intersection_idemp (plus x)).
        apply Intersection_Included_compat...
          unfold Included, Plus, In... exists x...
        apply Disjoint_property_left...

    assert (is_a_cell
                 (sup M (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
                 sup P (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
               ∧ Minus (Singleton x) ∩ sub M n == Empty_set).
        apply hypothesis_for_1...
        apply Cardinality_Singleton_is_one.
        unfold Included... inversion H; subst... 
        rewrite PlusMinus_Singleton...
    inversion H as [LA LB]; clear H.
    
    set (N :=  sup M (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Q :=  sup P (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))). 
    set (Z := Intersection X (Complement (Singleton x))).
    set (Y' := (sub N n ∪ (Minus Z)) ∩ √Plus Z).
    set (Y  := (sub M n ∪ (Minus X)) ∩ √Plus X). 
    assert (X == Union (Singleton x) Z) as XZrel. 
      unfold Z. 
      rewrite Union_sym. rewrite U_I_dist_r. 
      rewrite Full_set_property. rewrite Full_set_ident_right. 
      unfold Same_set, Included... apply In_Union in H... inversion H0. rewrite <- H...
      intuition. 

    assert (Cardinal Z (S m) /\ Z ⊆ sub Full_set (S n) /\ well_formed Z) as Zproperties.
      idtac...
      unfold Z. rewrite <- Setminus_is_Intersection_Complement. 
      apply Cardinal_Setminus...
      apply (Included_trans _ X _)... 
      unfold Z. 
      apply Intersection_Included_cancel_right... 
        unfold Z. apply (well_formed_Included X)...
        apply Intersection_Included_cancel_right...
    inversion Zproperties as [Zcard T].
    inversion T as [Zdim Zwf]. clear T Zproperties. 

    split.

    assert (is_a_cell ((sup N (n - 1)  ∪ Y'), (sup Q (n - 1) ∪ Y')) /\ Minus Z ∩ sub N n == Empty_set) as AA.
      apply (IHm Z)...
        unfold celldim, N, Q, setdim...
          apply In_Union in H...
          apply In_Union in H0...
            apply (le_trans _ (n-1))...
          apply In_Intersection in H...
          apply In_Union in H0...
          assert (dim x0 = n)... rewrite H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
          apply In_Union in H0...
            apply (le_trans _ (n-1)). repeat subsuptac... idtac...
          apply In_Intersection in H...
          apply In_Union in H0...
          assert (dim x0 = n)... rewrite H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...

        assert (sub N n == Intersection (Union (sub M n) (minus x)) (Complement (plus x))) as JA.
            unfold N. 
            rewrite sub_Union.
            rewrite sub_Intersection. rewrite sub_Union.
            rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left...
            rewrite sub_idemp.
            rewrite Minus_Singleton.
            rewrite Plus_Singleton.
            unfold Same_set, Included;
              repeat basic...
              right. 
              repeat subsuptac... 
              repeat subsuptac... 
              repeat subsuptac... 
        assert (PlusMinus Z ⊆ Intersection (Union (PlusMinus X) (minus x)) (Complement (plus x))) as JB. 
          unfold PlusMinus.
          rewrite XZrel.
          rewrite Plus_Union. 
          rewrite Minus_Union.
          rewrite Plus_Singleton. 
          rewrite Minus_Singleton.
          rewrite <- Union_Complement_compat.
          unfold Included; repeat (basic; intuition). 
          assert ((In (minus x) x0) \/ ~(In (minus x) x0))... 
            assert (Finite (minus x))... assert (decidable (minus x))... apply H3. 
            apply In_Complement; unfold not... 
            unfold Plus, Z, In at 1 in H1. 
            inversion H1 as [d SS]...
            apply In_Intersection in H3...
            unfold well_formed in Xwf...
            assert (x = d). 
            refine (H7 _ _ _ n _ _ _)... unfold perp in H8... 
            assert (In Empty_set x0). rewrite <- H9. apply In_Intersection... inversion H8. rewrite H8 in H6. 
            apply In_Complement in H6; unfold not in H6... 
        
      rewrite JA, JB.
        apply Intersection_Included_compat...
        apply Union_Included_compat...

      assert (sup N (n-1) == sup M (n-1)) as J1.
        unfold N.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1... 
        repeat subsuptac...
        apply In_Intersection in H1... 
        apply In_Union in H2... 
        repeat subsuptac...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1. 
        rewrite H5 in H3. exfalso... apply qwer'' in H3... 

      assert (sup Q (n-1) == sup P (n-1)) as J2.
        unfold Q.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1... 
        repeat subsuptac...
        apply In_Intersection in H1... 
        apply In_Union in H2... 
        assert (dim x0 = n)...  rewrite H2 in H3. exfalso. apply qwer'' in H3...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1. 
        rewrite H5 in H3. exfalso... apply qwer'' in H3... 

      assert (Y == Y') as J3. 
        unfold Y, Y', N.    
        rewrite XZrel.
        rewrite Minus_Union.
        rewrite Plus_Union.
        rewrite <- Union_Complement_compat.
        rewrite sub_Union. 
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left.
        rewrite sub_Intersection. rewrite sub_Union. rewrite sub_idemp. rewrite sub_Minus.
        rewrite <- Intersection_trans.
        rewrite <- Union_trans.
        rewrite I_U_dist_r.
        assert (sub (Singleton x) (S n) == (Singleton x)) as WW. 
          unfold Same_set, Included... subsuptac... subsuptac...
          inversion H1. rewrite <- H2...
        rewrite WW. clear WW.
        rewrite Minus_Singleton, Plus_Singleton.
          unfold Same_set, Included... 
            repeat (basic; intuition). 
            left... left... 
            repeat (basic; intuition). 
            left... apply In_Intersection... repeat subsuptac...
            left...
            right... apply In_Intersection... 
            unfold Z in H1. unfold Minus, In at 1 in H1. 
            inversion H1 as [z T]; clear H1... 
            apply In_Complement; unfold not... 
            apply (H2 x0). apply In_Intersection... exists z... apply In_Intersection in H1...

      fold (is_a_cell' (sup N (n - 1) ∪ Y') (sup Q (n - 1) ∪ Y')) in AA.
      rewrite J1, J2, <- J3 in AA... 
    fold N in LA. 
    fold Q in LA.

    assert (celldim (N, Q) n) as NQdim.
      unfold celldim, N, Q. 
      setdimtac.
      rewrite dimx... 
      rewrite dimx... 
    assert (sub N n == (sub M n ∪ (minus x)) ∩ √(plus x)). 
      unfold N. 
      rewrite Minus_Singleton, Plus_Singleton.
      unfold Same_set, Included, sub, sup; repeat (basic; intuition)... 
        exfalso. rewrite H2 in H3... apply qwer'' in H3...
        right; basic...
    assert (Minus Z ∩ sub N n == Empty_set).
      apply (IHm Z Zcard N Q)...
      rewrite H.
      unfold PlusMinus, Z, Included; repeat (basic; intuition)... 
        inversion H2; clear H2...
        assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
          apply all_decidable... 
          left; apply Xcond... 
          unfold PlusMinus; repeat basic... exists x1...
          apply In_Complement... 
          apply H3... inversion H2; clear H2... 
          exists x2; repeat basic...
          apply In_Complement...
          inversion H7; clear H7...
          rewrite <- H9 in *...
          apply In_Complement...
          inversion H2... 
          apply In_Intersection in H5...
          assert (x = x1)... unfold well_formed in Xwf...
          refine (H8 _ _ _ n _ _ _)...
          unfold perp in H9... assert (In (Empty_set) x0)...
          rewrite <- H10...
    assert (Disjoint (sub M n) (minus x)).
      rewrite Disjoint_Intersection_condition.
      rewrite Intersection_sym.
      rewrite Minus_Singleton in LB...
    assert ((sub N n ∪ (plus x)) ∩ √(minus x) == sub M n). 
      rewrite H. 
      rewrite U_I_dist_r. 
      rewrite Full_set_property... 
      rewrite Full_set_ident_right.
      repeat (rewrite I_U_dist_r). 
      rewrite Empty_set_property...
      rewrite Empty_set_ident_right.
      assert (Included (minus x) (√(sub M n))).
        apply Disjoint_property_right... 
      apply Complement_Included_compat in H2... 
      rewrite Complement_Complement_compat in H2...
      assert (Included (minus x) (√(sub M n))).
        apply Disjoint_property_right... 
      unfold Same_set, Included; repeat (basic; intuition)...
       apply all_decidable... apply Finite_sub... apply MPcell. 
    rewrite <- H2. 
    rewrite XZrel. 
    rewrite Minus_Union.
    rewrite Minus_Singleton. 
    rewrite <- Intersection_trans.  
    rewrite I_U_dist_l. 
    rewrite (I_U_dist_r (sub N n)). 
    rewrite (I_U_dist_r (plus x)).
    rewrite H0; clear H0.
    unfold Same_set, Included... 
    exfalso; repeat (basic; intuition)...
    apply (H1 x0)... basic...
    apply (Minus_Included Z X)... rewrite XZrel...
  Qed.

  Lemma Lemma_3_2_Step_3' :
    forall n, (forall m , Lemma_3_2_b_st (n - 1) m) -> (Lemma_3_2_b_st n 1).  
  Proof with intuition.
    intros n Hyp1.

    induction n.
    (* n = 0 *)
    apply Lemma_3_2_b_0_1.

    (* n > 0 *)
    rewrite (Sn_minus_1 n) in *.
    intros X Xcard M P K L.
    inversion K as [MPcell MPdim]; clear K.
    inversion L as [Xdim J]; clear L.
    inversion J as [Xwf Xcond]; clear J.
    assert (Finite X) as XFin. apply (Cardinal_are_Finite 1)...

    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    assert (In X x) as xinX. rewrite Xsing...

    assert (plus x ⊆ sub M (S n)) as plusxdim.
      assert (PlusMinus X == plus x) as K. 
        unfold PlusMinus. rewrite Xsing. 
        rewrite Plus_Singleton, Minus_Singleton. 
        apply Intersection_Included_left. apply Disjoint_property_left.
        apply plus_minus_Disjoint.
      rewrite <- K... 
    set (Y := (sub M (S n) ∪ Minus X) ∩ √Plus X).

    set (S' := (fun z =>  ~(In (plus x) z) /\ exists w, In (plus x) w /\ triangle_rest (sub M (S n)) z w)).
    set (T  := Setminus ((Setminus (sub M (S n))) S') (plus x)). 
    assert ((sub M (S n)) == S' ∪ (plus x) ∪ T) as DisjUnion. 
      unfold Same_set, Included...
        assert (In (plus x) x0 \/ ~(In (plus x) x0))... apply Finite_are_decidable...
        assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)))... 
          apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left; left. unfold S', In at 1... 
        right. unfold T, Setminus... unfold In at 1... unfold In at 1... unfold S', In at 1 in H0... 
        apply In_Union in H... apply In_Union in H0... unfold S', In at 1 in H... inversion H1; clear H1...
        inversion H2... unfold T, Setminus in H0; repeat (basic; intuition)...
    assert (Disjoint (plus x) S') as DisjMS'. 
      unfold S', Setminus. constructor... apply In_Intersection in H... 
      unfold In at 1 in H1...
    assert (Disjoint (plus x) T) as DisjMT. 
      unfold T, Setminus. constructor... apply In_Intersection in H... 
      unfold In at 1 in H1...
    assert (Disjoint T S') as DisjTS'. 
      unfold T, S', Setminus. constructor... 
      apply In_Intersection in H... 
      unfold In at 1 in H1... 
      unfold In at 1 in H0...
      unfold In at 1 in H1... 
    assert (is_initial_segment S' (sub M (S n))) as S'initial. 
      unfold is_initial_segment. 
      split. unfold S', Included...
      unfold In at 1 in H... inversion H1; clear H1... induction H2... 
      unfold S'... unfold In at 1 in H0... unfold In at 1... apply H1...
      inversion H2 as [w E]; clear H2... 
      assert (is_a_segment (plus x) (sub M (S n)))... apply Prop_1_3... apply xplus_is_tight. 
      apply (well_formed_Included M). apply MPcell. unfold Included, sub, In...
      apply weird_lemma_4 in H4...
      refine (H6 y w _ _ _)...
      inversion H2 as [a A]; exists a... 
      apply (triangle_rest_trans _ _ z)...
    assert (is_final_segment T (sub M (S n))) as Tfinal. 
      unfold is_final_segment. 
      split. unfold T, Setminus, Included, In...
      unfold T... unfold Setminus, In at 1 in H0... unfold In at 1 in H1... 
      unfold Setminus, In at 1... unfold In at 1... apply triangle_rest_in_set in H... apply H3. 
      unfold is_initial_segment in S'initial... apply (H5 y z)...
      assert (is_initial_segment (Union S' (plus x)) (sub M (S n))). 
        unfold is_initial_segment... rewrite DisjUnion. unfold Included...
        apply In_Union in H5... left.
        unfold is_initial_segment in S'initial... apply (H7 y0 z0)...
        assert ((y0 ∈ plus x) \/ ~(y0 ∈ plus x))... apply Finite_are_decidable... left. unfold S', In at 1... exists z0...
      unfold is_initial_segment in H4... assert (y ∈ S' ∪ plus x). apply (H6 y z)...
      apply In_Union in H4...
    assert (Finite S') as S'Fin. 
      apply (Finite_Included'' (sub M (S n)))... apply Finite_sub. apply MPcell. 
      unfold S', Included, In ... inversion H1; clear H1... inversion H2... 
      assert ((In (plus x) x0) \/ ~(In (plus x) x0))... apply Finite_are_decidable...
      right... unfold S', In at 1 in H0...
      assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)))... 
        apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left... unfold S', In at 1... right...  apply H2. unfold S', In at 1 in H0...
    assert (Finite T) as TFin. 
      unfold T. apply Setminus_Finite'... 
      apply Setminus_Finite'... 
      apply Finite_sub. apply MPcell.
    assert (sub T (S n) == T) as Tdim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold T, Setminus in H... unfold In at 1, In at 1 in H...
    assert (sub S' (S n) == S') as S'dim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold S', Setminus in H... unfold In at 1 in H...
      inversion H1; clear H1...
      apply triangle_rest_in_set in H2...

    assert ((S' ∪ plus x moves sub M n
               to (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x))
              ∧ (T moves (sub P n ∪ Minus T) ∩ √Plus T to sub P n)
                ∧ (sub P n ∪ Minus T) ∩ √Plus T ==
                  (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)). 
    apply Prop_2_4'... apply Finite_Union...
    rewrite <- DisjUnion...
    pose (moves_by_dim M M P) as I. inversion I; clear I... apply H... apply MPcell...
    apply (Included_trans _ (PlusMinus (sub M (S n)))).
     unfold T, PlusMinus.
     repeat (rewrite Setminus_is_Intersection_Complement)... 
     unfold Included; repeat (basic; intuition)... 
     inversion H3... exists x1... repeat (basic; intuition)...
     apply In_Complement... apply H4...
     rewrite Intersection_trans.
     rewrite Union_Complement_compat. 
     inversion H0... exists x1... repeat (basic; intuition)...
     inversion H3...              repeat (basic; intuition)...
       apply In_Complement... apply In_Union in H5... 
       unfold S', In at 1 in H12...
       inversion H13; clear H13...
       apply (H1 x3)... apply In_Intersection... 
       unfold is_final_segment in Tfinal... 
       refine (H15 x2 _ _ _). apply (tr_trans _ _ x1)... exists x0... 
       unfold T, In at 1; repeat (basic; intuition)... 
       rewrite DisjUnion in H8; repeat (basic; intuition)...
       assert (In T x1)...
       unfold is_final_segment in Tfinal... 
       refine (H13 x2 _ _ _)... apply (tr_trans _ _ x1)... exists x0... 
       left... unfold T, Setminus in H8... unfold In at 1, In at 1 in H8; repeat (basic; intuition)... 
    rewrite sub_PlusMinus...
    apply sub_Included_compat. 
    apply Prop_2_1_dual... apply MPcell... exists M... apply MPcell...
    unfold Perp. 
    apply Perp_thing...
    apply Disjoint_three... 
    apply Disjoint_sym... 
    rewrite <- DisjUnion.
    pose (well_formed_by_dimension M).
    inversion i. apply H.
    apply MPcell... 
    apply Finite_Union... 
    assert (dim b = S n). rewrite <- Tdim in H1...
    assert (dim a = S n). apply In_Union in H0... rewrite <- S'dim in H2...
    rewrite H, H2...

    set (B := (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)). 
    fold B in H. 
    assert (sub B n == B) as Bdim. 
      unfold Same_set, Included, sub... 
        unfold In at 1 in H1... 
        unfold In at 1... 
        unfold B in H1... 
        repeat (basic; intuition)...
        inversion H1; clear H1...
        assert (dim x1 = S n)...
          apply In_Union in H1...
          rewrite <- S'dim in H6...
        assert (S (dim x0) = dim x1)...
        rewrite H6 in H9...

    assert ((S' moves sub M n to (sub M n ∪ Plus S') ∩ √Minus S')
              ∧ (plus x moves (B ∪ Minus (plus x)) ∩ √Plus (plus x) to B)
                ∧ (B ∪ Minus (plus x)) ∩ √Plus (plus x) ==
                  (sub M n ∪ Plus S') ∩ √Minus S') as JJJ.
    apply Prop_2_4'... 
    unfold B, Included, PlusMinus... 
      rewrite Plus_Union. 
      rewrite Minus_Union. 
      rewrite <- Union_Complement_compat. 
      repeat (basic; intuition)...
      apply In_Complement... apply H7... exfalso.
      inversion H6... inversion H1...
        assert (less x1 x2)... exists x0...
        apply (H5 x1)... basic... 
        unfold is_initial_segment in S'initial...
        apply (H14 _ x2)... apply (tr_trans _ _ x2)... left...
    unfold Perp. 
    apply Perp_thing...
    apply Disjoint_sym... 
    apply (well_formed_Included M).
    apply MPcell...
    apply (Included_trans _ (sub M (S n)))...
    rewrite DisjUnion...
    assert (dim a = S n). rewrite <- S'dim in H3...
    assert (dim b = S n). assert (S (dim b) = dim x)... 
    rewrite H1, H5...
    set (A := (sub M n ∪ Plus S') ∩ √Minus S'). 
    fold A in JJJ. 
    assert (sub A n == A) as Adim. 
      unfold Same_set, Included, sub... 
        unfold In at 1 in H2... 
        unfold In at 1... 
        unfold A in H2... 
        repeat (basic; intuition)...
        inversion H2; clear H2...
        assert (dim x1 = S n)...
          rewrite <- S'dim in H2...
        assert (S (dim x0) = dim x1)...
        rewrite H9 in H12...

    inversion H as [movesMtoB [movesBtoP Bdef]]. 
    clear H. symmetry in Bdef. rewrite <- Bdef in movesBtoP. 
    inversion JJJ as [movesMtoA [movesAtoB Adef]].
    clear JJJ. symmetry in Adef. rewrite <- Adef in movesAtoB. 
 
    assert (dim x = S (S n)) as xdim. 
      idtac...

    set (tM := sub P (n) ∪ sup M (n - 1)).
    set (tP := sup P (n)).
    assert (is_a_cell (tM, tP)) as tMPcell.
      unfold tM, tP. apply target_is_a_cell... 
    assert (celldim (tM, tP) (n)) as tMPdim. 
      apply target_dim...
    assert (sub tM n == sub P n) as targetrel. 
        unfold tM... 
        rewrite sub_Union. rewrite sub_idemp. rewrite sub_sup_Empty_set... 
      
(*
    assert (is_a_cell ((sup M (n - 1) ∪ B ∪ T          , sup P (n) ∪ T))        ).
    assert (is_a_cell ((sup M (n - 1) ∪ B              , sup P (n - 1) ∪ B))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ A ∪ (plus x)   , sup P (n) ∪ (plus x))) ).
    assert (is_a_cell ((sup M (n - 1) ∪ A              , sup P (n - 1) ∪ A))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n) ∪ S' , sup P (n) ∪ S'))       ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n)      , sup P (n - 1) ∪ (sub M n))) ).
  *)  (* I don't know what this is for, leave it until i'm sure the lemma works *)

    assert (exists mT, Cardinal T mT). apply Cardinality_exists. assumption.
      inversion H as [mT Tcard]; clear H.
    

    (* is a cell (M + B + T) (P + T) *)
    assert (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T) ∪ T, tP ∪ T))) as T1.
      apply (Lemma_3_2_Step_1' _ mT)...
      unfold Included... subsuptac... 
      assert (In (sub M (S n)) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion... 
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P n)). apply Prop_2_1_dual... 
      exists B... apply H0...
    
    (* is a cell (M + B) (P + B) *)
    assert (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)  , sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T))) 
       /\ (Minus T) ∩ sub tM n == Empty_set) as T2.
      apply (Hyp1 mT)...
      unfold Included... subsuptac... 
      assert (In (sub M (S n)) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion... 
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P n)). apply Prop_2_1_dual... 
      exists B... apply H0...
    
    assert (exists mplusx, Cardinal (plus x) mplusx). 
      apply Cardinality_exists...
      inversion H as [mplusx plusxcard]; clear H.

    (* is a cell (M + A + x) (P + B + x) *)
    assert (is_a_cell
             ((sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n) ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ (plus x),
             (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) ∪ (plus x))) as plusx1. 
      apply (Lemma_3_2_Step_1' _ mplusx)...
      unfold celldim... 
        setdimtac.
        unfold T; setdimtac.
        unfold T; setdimtac.
        unfold Included, sub... unfold In at 1... 
      rewrite targetrel. 
      rewrite <- Bdef. 
      assert (sub ((sup tM (n - 1) ∪ B)) n == B).
        rewrite sub_Union... rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...  
    
    assert (is_a_cell
               (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n ∪ Minus (plus x)) ∩ √Plus (plus x)),
               sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n ∪ Minus (plus x)) ∩ √Plus (plus x)))
             ∧ Minus (plus x) ∩ sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n == Empty_set) as plusx2.
      apply (Hyp1 mplusx)... 
      unfold celldim... 
        setdimtac... 
        unfold T; setdimtac... 
        unfold T; setdimtac... 
      unfold Included... 
      rewrite targetrel. 
      rewrite <- Bdef.
      assert (sub ((sup tM (n - 1) ∪ B)) n == B). 
        rewrite sub_Union. 
        rewrite sub_sup_Empty_set... 
        rewrite Empty_set_ident_left... 
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...  
    
    assert (exists mS', Cardinal S' mS'). 
      apply Cardinality_exists...
    inversion H as [mS' S'card]; clear H.

    assert (is_a_cell
        ((sup (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S')) ∪ S', (sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
           ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
               ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ S')) as S'1.
      apply (Lemma_3_2_Step_1' _ mS')...
      unfold celldim... setdimtac... 
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (Included_trans _ (sub M (S n))). rewrite DisjUnion...
        apply sub_Included'... 
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      unfold Included; intros. 
      rewrite sub_Union at 1. right.
      assert (PlusMinus S' ⊆ A). apply Prop_2_1_dual...
      exists (sub M n)... apply H4 in H3; clear H4.
      rewrite Adef in H3...
      unfold sub at 1, In at 1...  assert ((sub (sup tM (n - 1) ∪ B) n == B)). 
        rewrite sub_Union. rewrite Bdim. 
        rewrite sub_sup_Empty_set...
      rewrite H4... repeat (basic; intuition). rewrite Bdef in H3.
      repeat (basic; intuition). unfold T, Minus, Setminus, sub, In in H3. 
      inversion H3; clear H3... apply minus_dim in H10. rewrite H13 in H10. inversion H10...
      unfold Minus, In at 1 in H3. inversion H3... assert (dim x = S (S n))...
      apply minus_dim in H10. 
      apply plus_dim in H9. assert (S (S (dim x0)) = S (S n))... rewrite <- H7.
      rewrite H10... inversion H11... 

    assert (is_a_cell
        (sup (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S'),
        sup (sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
           ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
               ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S'))
      ∧ Minus S' ∩ sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n == Empty_set)
    as S'2.
      apply (Hyp1 mS')...
      unfold celldim... setdimtac...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (Included_trans _ (sub M (S n))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      rewrite sub_Union.
      rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left.
      assert (sub ((sub (sup tM (n - 1) ∪ B) n ∪ Minus (plus x)) ∩ √Plus (plus x)) n == (B ∪ Minus (plus x)) ∩ √Plus (plus x)).
        rewrite sub_Union at 1. 
        rewrite Union_trans. 
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        rewrite Bdim.
        unfold Same_set, Included...
          unfold sub, In at 1 in H3...
          unfold sub, In at 1...
          repeat (basic; intuition)... rewrite <- Bdim in H3...
          apply (Minus_dim _ _ _ plusxdim)... trivial. 
      rewrite H3. 
      rewrite <- Adef.
      apply Prop_2_1_dual...
      exists (sub M n)...

(* this is tidying up, it is completely optional, doesn't change the meaning of anything, but might change
   whether the proofs compile *) (*
    fold (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) ∪ T) (tP ∪ T)) in T1.
    rewrite targetrel in T1. rewrite <- Bdef in T1.
    unfold tM in T1.
    rewrite sup_Union in T1. 
    rewrite sup_idemp in T1. 
    rewrite sup_sub_comm in T1.
    rewrite sub_sup_Empty_set in T1.
    rewrite Empty_set_ident_left in T1. 
    unfold tP in T1.
    unfold is_a_cell in T1. 
    fold (is_a_cell' (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (
       sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T))) in T2.
    rewrite targetrel in T2. rewrite <- Bdef in T2.
    unfold tM in T2.
    rewrite sup_Union in T2. 
    rewrite sup_idemp in T2. 
    rewrite sup_sub_comm in T2.
    rewrite sub_sup_Empty_set in T2.
    rewrite Empty_set_ident_left in T2. 
    unfold tP in T2.
    rewrite sup_sup_min in T2.
    unfold is_a_cell in T2. 
    inversion T2 as [T2a T2b]; clear T2. *)

    assert ((minus x) moves A to B) as moves4. 
      apply Prop_3_1. 
      assumption. 
      admit. (* ?? -- receptivity condition, see bottom of p326 *)

    assert ((S' ∪ (minus x)) moves (sub M n) to B) as moves5.
      refine (Prop_2_3 _ _ _ _ _ movesMtoA _ _)...
      assert (∃ n : nat, Cardinal S' n). apply Cardinality_exists... 
      inversion H5 as [p J]. 
      induction p. 
        apply Cardinality_zero_Empty_set in J. 
         rewrite J. 
         constructor... inversion H6. inversion H7...
        constructor...
         apply In_Intersection in H6...
         inversion H7 as [w R ]; clear H7...
         inversion H8 as [v R']; clear H8...
         set (Z := fun y => In S' y /\ triangle_rest S' w y).
         assert (exists m : carrier, m ∈ Z /\ 
            (forall y : carrier, y ∈ Z → triangle_rest Z m y -> m = y)).
           refine (maximal_exists' _ _ (S n) _)... 
           apply (Finite_Included'' S')... unfold Z; crush. 
           assert ((triangle_rest S' w x1) \/ ~(triangle_rest S' w x1))...
             apply triangle_rest_dec.
           apply Cardinal_are_Finite in J... left; unfold Z, In at 1... 
           right; unfold Z, In at 1... exists w; unfold Z, In at 1... left...
           apply (Included_trans _ (sub M (S n)))...
           apply (Included_trans _ S')...
           unfold Z; crush. rewrite DisjUnion...
         inversion H10 as [u [uinZ umax]]; clear H10...
         assert (plus u ∩ Minus (plus x) == Empty_set).
           apply (Prop_1_2_dual _ v)...
           right with w. exists x0...
           apply (rest_implies_full S').
           unfold Z, In at 1 in uinZ...
         set (A' := Intersection (Union A (minus u)) (Complement (plus u))).
         set (B' := Intersection (Union B (minus u)) (Complement (plus u))).
         assert ((plus x) moves A' to B').
           unfold A', B'.
           apply Prop_2_2... 
           unfold Included, A; intros; apply In_Intersection...
             right. exists u... unfold Z, In at 1 in uinZ...
             apply In_Complement...
             inversion H12; clear H12...
             assert (triangle_rest S' u x2).
               right with x2...
               unfold Z, In at 1 in uinZ... 
               exists x1...
               left...
             assert (u = x2)... 
               apply umax... 
               unfold Z, In at 1...
               apply (triangle_rest_trans _ _ u)...
               unfold Z, In at 1 in uinZ...
               clear H10 umax H11. 
               induction H13...
                 left...
                 right with y...
                 apply IHtriangle_rest... unfold Z, In at 1... 
                 apply triangle_rest_in_set in H13...
                 apply triangle_rest_equiv.
                 right with x2... 
                 apply triangle_rest_in_set in H13...
                 apply triangle_rest_equiv. unfold Z, In at 1 in uinZ...
             rewrite H15 in H11...
           constructor... 
             apply In_Intersection in H11... 
             unfold MinusPlus in H12; apply In_Intersection in H12. 
             assert (In (Empty_set) x1)... 
               rewrite <- H10. 
               apply In_Intersection...
           constructor... 
             apply In_Intersection in H11... 
             inversion H13; clear H13...
             assert (less x2 u).
               exists x1...
             refine (initial_property _ (plus x) _ S'initial _ _ u x2 _ _ _)...
               apply Disjoint_sym...
               unfold Z, In at 1 in uinZ...
           admit. (* really not sure why *)
         assert ((minus x) moves A' to B').
           refine (Prop_3_1 _ _ _ _ _)...
           admit. (* this should be fine, doen by diemsnion?, see paper *)
         admit. (* ?? *) 
       
    assert (((minus x) ∪ T) moves A  to (sub P n)) as moves6.
      refine (Prop_2_3 _ _ _ _ _ moves4 _ _)... 
      admit. (* ?? *) 

    assert (((S' ∪ (minus x)) ∪ T) moves (sub M n) to (sub P n)) as moves7.
      assert (Disjoint (Minus (minus x)) (Plus T)) as Disjtemp. 
        admit. (* ?? *)
      refine (Prop_2_3 _ _ _ _ _ moves5 _ _)... 
      apply Disjoint_Intersection_condition.
      rewrite Minus_Union.
      rewrite I_U_dist_r. 
      assert ((Minus S' ∩ Plus T) == Empty_set).
        unfold Same_set, Included...
        exfalso. 
        apply In_Intersection in H5... 
        inversion H6. inversion H7...
        refine (final_property _ (S') _ Tfinal _ _ x1 x2 _ _ _)...
          rewrite DisjUnion... 
        rewrite Disjoint_sym...
        exists x0... 
        inversion H5. 
        rewrite H5; clear H5. rewrite Empty_set_ident_left.
      apply (Disjoint_Intersection_condition)...

    assert (well_formed (S' ∪ (minus x))) as WF1.
      apply weird_lemma_2... 
      apply (well_formed_Included (sub M (S n)))... 
      apply (well_formed_Included    M         )... apply MPcell. unfold Included, S', In at 1...
      inversion H7; clear H7... inversion H8... 
        admit. (* ?? *)
      assert ((S' ∪ minus x) == sub (S' ∪ minus x) (S n)).
        unfold Same_set, Included... unfold sub, In at 1... repeat (basic; intuition)...
        unfold S', In at 1 in H9... inversion H10; clear H10... inversion H11... unfold sub, In at 1 in H5...
      rewrite H5... unfold Same_set, Included, sub, In... rewrite H9 in H8; exfalso... inversion H8... 

    assert (well_formed ((minus x) ∪ T)) as WF2.
      (* as above *)
      admit. (* ?? *)

    assert (well_formed ((S' ∪ minus x) ∪ T)) as WF3.
      admit. (* ?? *)

    assert (Y == (S' ∪ minus x) ∪ T) as Ycond.
      unfold Y. 
      rewrite DisjUnion. 
      rewrite Xsing.
      rewrite Minus_Singleton, Plus_Singleton.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      repeat (rewrite <- Disjoint_result)... 
      rewrite Union_trans, <- (Union_sym _ T). 
      rewrite <- Union_trans... 
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
 
    assert (Y == (sub Y (S n))) as dimY. 
      admit.

    (* real work begins *)
    split.
    unfold is_a_cell...

    rewrite Ycond. apply (Inhabited_Included (minus x)). 
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    rewrite Ycond. apply (Inhabited_Included (minus x)). 
      apply minus_Inhabited. rewrite xdim... 
      unfold Included; intros; right;left;right...

    apply well_formed_Union... 
    apply (well_formed_Included M). 
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H8. rewrite (Sn_minus_1 n) in H7. assert (dim x0 <= n)... 
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8... 
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    apply well_formed_Union... 
    apply (well_formed_Included P). 
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H8. rewrite (Sn_minus_1 n) in H7. assert (dim x0 <= n)... 
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8... 
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    rewrite (Sn_minus_1 n). 
    rewrite Ycond... 
    repeat (apply Finite_Union)...
      apply all_decidable. apply Finite_sup... apply MPcell.
      apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    rewrite (Sn_minus_1 n). 
    rewrite Ycond... 
    repeat (apply Finite_Union)...
    apply all_decidable... apply Finite_sup... apply MPcell.
    apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.
 
    (* there is some condition about splitting dimensions that should make this work *)
    rewrite (Sn_minus_1 n).
    unfold moves_def... 
      assert (forall k, sub (sup P n ∪ Y) k == sub (((sup M n ∪ Y) ∪ Plus (sup M n ∪ Y)) ∩ √Minus (sup M n ∪ Y)) k). 
        intros.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite dimY. 
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set || 
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          apply sub_Same_set_Proper... apply MPcell.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set _ (S n)) || 
                  rewrite (sub_sub_Empty_set _ n) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          admit. (* ?? *)
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) || 
                  rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
      apply Same_set_by_dimension in H5...

      assert (forall k, sub (sup M n ∪ Y) k == sub (((sup P n ∪ Y) ∪ Minus (sup M n ∪ Y)) ∩ √Plus (sup M n ∪ Y)) k). 
        intros.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite dimY. 
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set || 
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          apply sub_Same_set_Proper... apply MPcell.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set _ (S n)) || 
                  rewrite (sub_sub_Empty_set _ n) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          admit. (* ?? *)
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) || 
                  rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
      apply Same_set_by_dimension in H5...

    rewrite (Sn_minus_1 n). 
    unfold moves_def... 
      assert (forall k, sub (sup P n ∪ Y) k == sub (((sup M n ∪ Y) ∪ Plus (sup P n ∪ Y)) ∩ √Minus (sup P n ∪ Y)) k). 
                intros.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite dimY. 
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set || 
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          apply sub_Same_set_Proper... apply MPcell.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set _ (S n)) || 
                  rewrite (sub_sub_Empty_set _ n) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          admit. (* ?? *)
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) || 
                  rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
      apply Same_set_by_dimension in H5...

      assert (forall k, sub (sup M n ∪ Y) k == sub (((sup P n ∪ Y) ∪ Minus (sup P n ∪ Y)) ∩ √Plus (sup P n ∪ Y)) k). 
        intros.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite dimY. 
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set || 
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          apply sub_Same_set_Proper... apply MPcell.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set _ (S n)) || 
                  rewrite (sub_sub_Empty_set _ n) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)... 
          rewrite Setminus_is_Intersection_Complement. 
          admit. (* ?? *)
          rewrite b.
          repeat (rewrite (sub_sup_cancel n) || rewrite (sub_sup_Empty_set) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) || 
                  rewrite (sub_sub_Empty_set) || 
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set || 
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
      apply Same_set_by_dimension in H5...

    rewrite Xsing. 
    rewrite Minus_Singleton.
    rewrite DisjUnion.
    repeat (rewrite I_U_dist_l).
    unfold Same_set, Included... exfalso. 
      repeat (basic; intuition). 
      unfold S', In at 1 in H10...
      inversion H11; clear H11...
      assert (triangle x0 x1). 
        apply rest_implies_full in H12...
      apply (axiom3b _ _ x) in H10...
      unfold T, In at 1 in H10...
      unfold Setminus in H10... 
      unfold In at 1 in H9... 
    admit. (* ?? *)
    inversion H.
    inversion H5...
  Qed.

  Lemma Lemma_3_2_b_0_m :
    forall m, (Lemma_3_2_b_st 0 (S m)).
  Proof with intuition. 
    unfold Lemma_3_2_b_st. 
    intros.
    
    assert (exists z, (sub M 0) == Singleton z).
      apply dim_0_Singleton.
      apply (M_0_Inhabited' M P)... apply H0.
    inversion H2 as [z K]; clear H2.
    
    assert (Finite X) as XFin.
      apply (Cardinal_are_Finite _ _ H)...
    
    assert (PlusMinus X == Singleton z). 
      assert (Finite (PlusMinus X)). 
        apply (Finite_Included'' (Plus X))... 
        unfold PlusMinus, Included... apply In_Intersection in H4... 
      apply all_decidable...
      apply Finite_Empty_or_Inhabited in H2... 
        exfalso. 
      assert (Inhabited (PlusMinus X)). 
        apply (PlusMinus_Inhabited _ 0)... apply Cardinal_Sn in H...
        rewrite H5 in H2. inversion H2...
      apply Included_Singleton... rewrite <- K...
    
    split.

    assert (sup M (0 - 1) == Empty_set) as JA. admit. (* coding issue *)
    assert (sup P (0 - 1) == Empty_set) as JB. admit. (* coding issue *)
    assert ((sub M 0) ∩ √(Plus X) == Empty_set). 
      unfold Same_set, Included...
      exfalso. apply In_Intersection in H5... 
      rewrite K in H7; inversion H7; clear H7.
      assert (In (PlusMinus X) x).
        rewrite <- H5, H2... unfold PlusMinus in H7. apply In_Intersection in H7...
      inversion H5.
    assert (exists w, MinusPlus X == Singleton w). 
      (* Definitely true, not so easy to prove *)
      (* first, use X inhabited and X wellformed to show that MinusPlus is inhabited *)
      (* this all relies on the fact that X is well_formed and of dimension 1 *)
      (* it is unique to dimension 1, this doesn't seem at all easy, check how ross does
         it before bothering to prove it. *) 
      admit. (* ?? *)
    inversion H4 as [w E]; clear H4.
    assert (dim w = 0).
      assert (In (MinusPlus X) w). rewrite E...
      unfold MinusPlus in H4. apply In_Intersection in H4...
      inversion H1... apply minus_dim in H11... assert (dim x = 1)...
      rewrite H7 in H11; inversion H11...
    apply (Same_set_is_a_cell (Singleton w) (Singleton w)). 
    unfold is_a_cell...
      exists w...
      exists w...
      unfold moves_def. 
        split; rewrite Plus_Singleton, Minus_Singleton, plus_zero, minus_zero, Empty_set_ident_right, Complement_Empty_set, Full_set_ident_right...
      unfold moves_def. 
        split; rewrite Plus_Singleton, Minus_Singleton, plus_zero, minus_zero, Empty_set_ident_right, Complement_Empty_set, Full_set_ident_right...
     
    rewrite JA, I_U_dist_r, H3, <- E, Empty_set_ident_left, Empty_set_ident_left...

    rewrite JB, I_U_dist_r, H3, <- E, Empty_set_ident_left, Empty_set_ident_left...

    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H5...
      rewrite K in H8. rewrite <- H2 in H8. unfold PlusMinus in H8.
      apply In_Intersection in H8...
      exfalso... 
  Qed. 

  Lemma Lemma_3_2_b :
    forall n m, (Lemma_3_2_b_st n m).
  Proof.
    intros n.
    induction n.
      intros m; destruct m. 
      apply Lemma_3_2_b_n_0.
      apply Lemma_3_2_b_0_m.
    destruct m.
      apply Lemma_3_2_b_n_0.
    apply Lemma_3_2_Step_2'.
    apply Lemma_3_2_Step_3'.
    simpl. 
    rewrite <- (minus_n_O).
    apply IHn.
  Qed.
 
  Lemma Lemma_3_2_c :
    forall n m, (Lemma_3_2_c_st n m).
  Proof.
    intros.
    apply Lemma_3_2_Step_1'.
    apply Lemma_3_2_b.
  Qed.

  Lemma Prop_3_4 :
    forall M P, is_a_cell (M, P) ->
    forall z n, dim z = S n ->
    minus z ⊆ P ->
    Minus M ∩ plus z == Empty_set.
  Admitted.

  Lemma Prop_3_5 :
    forall M P N Q, is_a_cell (M, P) /\ is_a_cell (N, Q) ->
    (forall n m, m < n-1 -> (M == N /\ P == Q /\ P = N)) -> 
    (Minus M ∩ Plus N == Empty_set) /\ is_a_cell (M, N).
  Admitted.

  Lemma Theorem_3_6b :
    forall M P N Q (n: nat), 
      is_a_cell (M, P) -> is_a_cell (N, Q) -> 4 = 4 ->
      Minus (M ∪ P) ∩ Plus (N ∪ Q) == Empty_set.
  Admitted. 

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* mu and pi                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Function mu' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier := 
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => MinusPlus (mu' x (S n)) 
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x. 
      induction (dim x).
        - induction n...
            + inversion teq.
        - induction n0...
            + apply IHn. simpl in teq... simpl in teq0... 
     Qed.

  Definition mu (x : carrier) := fun y => exists n, In (mu' x n) y.

  Function pi' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier := 
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => PlusMinus (pi' x (S n)) 
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x. 
      induction (dim x).
        - induction n...
            + inversion teq.
        - induction n0...
            + apply IHn. simpl in teq... simpl in teq0... 
     Qed.
  
  Definition pi (x : carrier) := fun y => exists n, In (pi' x n) y.
  
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results from definitions                       *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma mu'_Singleton : forall x, (mu' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x. 
    rewrite mu'_equation.
    assert (leb (dim x) (dim x) = true). 
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true). 
      induction (dim x)... 
    rewrite H, H0...
  Qed.

  Lemma mu'_Empty_set : forall n x, S (dim x) <= n -> (mu' x n) = Empty_set.
  Proof with intuition.
    intros... 
    rewrite mu'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H. 
        - induction n0... 
           + inversion H. 
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0... 
  Qed.

  Lemma mu'_MinusPlus : forall n x, S n <= (dim x) -> (mu' x n) = MinusPlus (mu' x (S n)).
  Proof with intuition.
    intros n x... 
    rewrite mu'_equation.
    assert (leb n (dim x) = true). 
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
         simpl in H0... 
    rewrite H0, H1...
  Qed.

  Lemma mu'_ind' : 
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (mu' x (S n)) → P n (MinusPlus (mu' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e... 
       apply beq_nat_false in e0... 
       induction e... 
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Hint Resolve le_not_gt.

  Lemma mu'_Finite : forall n x, Finite (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind'...
  Qed.

  Lemma mu'_dim : forall x n y, In (mu' x n) y -> dim y = n. 
  Proof with intuition. 
    intros x n.
    apply mu'_ind'...
     - inversion H...
     - unfold MinusPlus in H1...
       apply In_Intersection in H1... 
       unfold Minus, In at 1 in H2... 
       inversion H2; clear H2... 
       assert (dim x0 = S n0)... 
     - inversion H0...
  Qed.

  Lemma sub_mu : forall x n, sub (mu x) n == mu' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold mu, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply mu'_dim in H...
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply mu'_dim in H...
  Qed.

  Lemma pi'_Singleton : forall x, (pi' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x. 
    rewrite pi'_equation.
    assert (leb (dim x) (dim x) = true). 
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true). 
      induction (dim x)... 
    rewrite H, H0...
  Qed.

  Lemma pi'_Empty_set : forall n x, S (dim x) <= n -> (pi' x n) = Empty_set.
  Proof with intuition.
    intros... 
    rewrite pi'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H. 
        - induction n0... 
           + inversion H. 
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0... 
  Qed.

  Lemma pi'_PlusMinus : forall n x, S n <= (dim x) -> (pi' x n) = PlusMinus (pi' x (S n)).
  Proof with intuition.
    intros n x... 
    rewrite pi'_equation.
    assert (leb n (dim x) = true). 
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
         simpl in H0... 
    rewrite H0, H1...
  Qed.

  Lemma pi'_ind' : 
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (pi' x (S n)) → P n (PlusMinus (pi' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e... 
       apply beq_nat_false in e0... 
       induction e... 
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Lemma pi'_Finite : forall n x, Finite (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind'...
  Qed.

  Lemma pi'_dim : forall x n y, In (pi' x n) y -> dim y = n. 
  Proof with intuition. 
    intros x n.
    apply pi'_ind'...
     - inversion H...
     - unfold PlusMinus in H1...
       apply In_Intersection in H1... 
       unfold Plus, In at 1 in H2... 
       inversion H2; clear H2... 
       assert (dim x0 = S n0)...
       assert (S (dim y) = dim x0)...
       rewrite H1 in H5...
     - inversion H0...
  Qed.

  Lemma sub_pi : forall x n, sub (pi x) n == pi' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold pi, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply pi'_dim in H...
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply pi'_dim in H...
  Qed.
  
  Notation "'<<' x '>>'" := ((mu x), (pi x)) (at level 85).

  Lemma atom_is_a_cell : forall x, is_a_cell (<< x >>).
  Admitted.

  Lemma atom_dim : forall x n, dim x = n -> celldim (<< x >>) n.
  Admitted.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 4                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Axiom mu_is_tight : forall x n, tight (sub (mu x) n). 
  Axiom pi_is_tight : forall x n, tight (sub (pi x) n). 

  Lemma Theorem_4_1 :
    forall M P n, is_a_cell (M, P) -> celldim (M, P) n ->
    forall u, u ∈ (sub M n) -> ~((M, P) === << u >>) ->
    exists N Q L R m, 
      is_a_cell (N, Q) /\ 
      is_a_cell (L, R) /\
      (m < n) /\ 
      ~(celldim (N, Q) m) /\ 
      ~(celldim (L, R) m) /\  
      ((M, P) === composite m (N, Q) (L, R)).
  Proof with intuition.
    intros M P n cellcond dimcond u udim notatomic.  

    set (Z := (fun m => (n <= m) \/ ((sub M (S m), sub P (S m)) === (sub (mu u) (S m), sub (pi u) (S m))))).
    assert (Inhabited Z) as ZInhab.
      exists (S n)... unfold Z, In at 1...
    assert (exists m, (In Z m /\ forall r, In Z r -> m <= r)) as max_exists.
      apply decidable_nat_have_minimum_le_element...
      unfold decidable, Z, In... 
      assert ({n <= x} + {x < n})...
      assert ((sub M (S x) == sub (mu u) (S x)) \/ ~((sub M (S x) == sub (mu u) (S x))))...
      apply Finite_eq_decidable... apply Finite_sub... apply cellcond. 
        rewrite sub_mu. apply mu'_Finite.
      assert ((sub P (S x) == sub (pi u) (S x)) \/ ~((sub P (S x) == sub (pi u) (S x))))...
      apply Finite_eq_decidable... apply Finite_sub... apply cellcond. 
        rewrite sub_pi. apply pi'_Finite.
      right. intros...
        apply le_not_lt in H2... 
      inversion H2...
      right. intros...
        apply le_not_lt in H1...
      inversion H1...
    inversion max_exists as [m H]; clear max_exists; inversion H as [minZ mmax]; clear H. 
    
    assert (m < n) as mltn. 
      assert ({n <= m} + {m < n})... 
        exfalso.
        apply notatomic...
        assert (celldim (<< u >>) n)... 
          apply atom_dim...
        unfold Same_pair...
          apply (TT (n))... unfold celldim in H. unfold setdim in *... unfold celldim, setdim in *... 
            admit. (* ?? *)
          apply (TT (n))... unfold celldim in H. unfold setdim in *... unfold celldim, setdim in *... 
            admit. (* ?? *) 

    assert ((sub M (S m)) == (sub (mu u) (S m)) ∪ ((sub M (S m)) ∩ (sub P (S m)))) as Mcond. 
      unfold Z, In in minZ. 
      inversion minZ as [minZa | minZb]; clear minZ.
        exfalso. apply le_not_lt in minZa...
        inversion minZb; clear minZb. 
          unfold Same_set, Included; repeat (basic; intuition)...
    assert ((sub P (S m)) == (sub (pi u) (S m)) ∪ ((sub M (S m)) ∩ (sub P (S m)))) as Pcond. 
      unfold Z, In in minZ. 
      inversion minZ as [minZa | minZb]; clear minZ.
        exfalso. apply le_not_lt in minZa...
        inversion minZb; clear minZb. 
          unfold Same_set, Included; repeat (basic; intuition)...
    assert (Disjoint (sub (mu u) (S m)) (sub M (S m) ∩ sub P (S m))) as JJ. 
      constructor... 
      admit. (* ?? *)
    assert (Disjoint (sub (pi u) (S m)) (sub M (S m) ∩ sub P (S m))) as KK'. admit. (* ?? *)
  
    assert (Inhabited ((sub M (S m)) ∩ (sub P (S m)))) as MPInhab.
      assert (((sub M (S m)) ∩ (sub P (S m))) == Empty_set \/ Inhabited ((sub M (S m)) ∩ (sub P (S m))))... 
        apply Finite_Empty_or_Inhabited. 
        apply Finite_Intersection... apply Finite_sub... apply cellcond...
        apply all_decidable. apply Finite_sub... apply cellcond...
      exfalso.
      admit. (* ?? -- implies that sub M (S m) == sub (mu u) (S m)... does that make m not maximal? *)
    inversion MPInhab as [w winMP]; clear MPInhab.
    
    set (X := fun k => triangle_rest (sub M (S m)) k w).
    assert (exists x, (In X x /\ forall r, In X r -> (triangle_rest X r x) -> x = r)) as Xhasmin. 
      refine (minimal_exists' _ _ (S m) _ )... 
      apply (Finite_Included'' (sub M (S m))). apply Finite_sub. apply cellcond.
      unfold X. unfold Included... unfold In at 1 in H... inversion H...
      idtac... 
      unfold X, In. 
      apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold X, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S m)))... 
      unfold X, Included... unfold In in H. inversion H...
    inversion Xhasmin as [x xismin]; clear Xhasmin.

    set (Y := fun k => triangle_rest (sub M (S m)) w k).
    assert (exists x, (In Y x /\ forall r, In Y r -> (triangle_rest Y x r) -> x = r)) as Yhasmax. 
      refine (maximal_exists' _ _ (S m) _ )... 
      apply (Finite_Included'' (sub M (S m))). apply Finite_sub. apply cellcond.
      unfold Y. unfold Included... unfold In at 1 in H1... apply triangle_rest_in_set in H1... 
      idtac... 
      unfold Y, In. 
      apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold Y, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S m)))... 
      unfold Y, Included... unfold In in H1. apply triangle_rest_in_set in H1... 
    inversion Yhasmax as [y yismax]; clear Yhasmax.

    assert ((minus x ⊆ sub M m) /\ (plus y ⊆ sub P m)) as specialcond. 
    split.
      apply (Included_trans _ (sub (MinusPlus M) m))...
        unfold Included...
        assert (dim x = S m) as AA. 
          unfold X, In at 1 in H...  inversion H...
        assert (S (dim x0) = dim x)...
        unfold sub, In at 1...
        unfold MinusPlus; apply In_Intersection... 
          exists x... unfold X, In at 1 in H... inversion H... apply H5... apply H5...
          apply In_Complement... unfold In, Plus in H5. 
          inversion H5; clear H5... 
          assert (triangle_rest X x1 x). 
            apply (tr_trans _ _ x)... unfold X, In at 1... 
            apply (tr_trans _ _ x)... unfold sub, In at 1... assert (S (dim x0) = dim x1)... 
            assert (S (dim x0) = dim x)... rewrite <- H6, H8... 
            exists x0... exists x0... left...  
          assert (x = x1). 
          apply (H0)... unfold X, In at 1... 
          apply (triangle_rest_trans _ _ x)... 
        apply (triangle_rest_Included X)...
        unfold X, Included, In at 1... inversion H8... 
        rewrite <- H8 in H7...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1 M M)...
      apply cellcond. exists P. apply cellcond.
      apply (Included_trans _ (sub (PlusMinus M) m))...
        unfold Included...
        assert (dim y = S m) as AA. 
          unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1... 
        assert (S (dim x0) = dim y)...
        unfold sub, In at 1...
        unfold PlusMinus; apply In_Intersection... 
          exists y... unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1... apply sub_Included in H6... 
          apply In_Complement... unfold In, Minus in H5. 
          inversion H5; clear H5... 
          assert (triangle_rest Y y x1).
            assert (In (sub M (S m)) x1)...
              unfold sub, In at 1... symmetry. rewrite <- AA, <- H4...
            assert (In (Y) x1)...
              unfold Y, In at 1...
              apply (triangle_rest_trans _ _ y)...
              apply (tr_trans _ _ x1)...
              unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...  
              exists x0... left...
            apply (tr_trans _ _ x1)... exists x0...
            left...
          assert (y = x1). 
          apply (H2)... unfold Y, In at 1... 
          apply (triangle_rest_trans _ _ y)... 
        apply (triangle_rest_Included Y)...
        unfold Y, Included, In at 1... apply triangle_rest_in_set in H8... 
        rewrite <- H8 in H7...
        rewrite AA in H4... 
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1_dual M P)...
      apply cellcond. exists M. apply cellcond. 
      
    assert (~(x ∈ (sub (mu u) (S m))) \/ ~(y ∈ (sub (mu u) (S m)))) as ASD. 
      assert (~((x ∈ (sub (mu u) (S m))) /\ (y ∈ (sub (mu u) (S m))))) as Q.
        unfold not...
        assert (is_a_segment (sub (mu u) (S m)) (sub M (S m))).
          apply Prop_1_3...
          rewrite sub_mu. apply mu'_Finite. 
          apply mu_is_tight. 
          pose (well_formed_by_dimension M)...
          apply H... apply cellcond.
          rewrite Mcond...
        apply weird_lemma_4 in H...  
        assert (w ∈ sub (mu u) (S m)).
          refine (H9 x y _ w _)...
        inversion JJ.
        apply (H10 w)... 
      assert ((x ∈ sub (mu u) (S m)) \/ ~(x ∈ sub (mu u) (S m))) as DD. 
        apply Finite_are_decidable... 
        rewrite sub_mu. 
        apply mu'_Finite.
      inversion DD; clear DD; [right |left]...

    assert ((x ∈ ((sub M (S m)) ∩ (sub P (S m)))) \/ (y ∈ ((sub M (S m)) ∩ (sub P (S m))))) as xory. 
      inversion ASD as [WER | WER]; clear ASD; [left | right].
        inversion xismin as [QQQ WWW]; clear xismin. 
        assert (In (sub M (S m)) x) as OOO. unfold In, X in QQQ. inversion QQQ...
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
        inversion yismax as [QQQ WWW]; clear yismax. 
        assert (In (sub M (S m)) y) as OOO. unfold In, Y in QQQ. 
        apply triangle_rest_in_set in QQQ... 
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
    clear ASD.
 
    inversion xory; clear xory.
    (* x case *)
    - set (R := (P ∩ (√(Singleton x)))).
      set (L := ((M ∩ √(Singleton x)) ∪ plus x) ∩ √minus x).
      set (Q := ((((sub M m) ∪ (plus x)) ∩ √(minus x))) ∪ (sup P (m-1)) ∪ (Singleton x)).
      set (N := ((sup M m) ∪ ((Singleton x)))).
      exists N. exists Q. exists L. exists R. exists m.
      assert (dim x = S m) as dimx. 
        unfold X, In at 1 in xismin... apply triangle_rest_in_set in H0... 
      splits...

      + unfold N, Q. 
        unfold is_a_cell... 
        * exists x... 
        * exists x... 
        * apply well_formed_Union... 
          apply well_formed_sup... 
          apply cellcond. 
          inversion H9; clear H9.
          assert (dim x0 <= m)...
          rewrite H7, <- H6, dimx in H9... 
        * apply well_formed_Union... 
          apply well_formed_Union... 
            admit. (* ?? *) 
          apply well_formed_sup... apply cellcond...
            assert (dim y0 <= m - 1)... 
            assert (dim x0 = m)... 
              repeat (basic; intuition)... 
              assert (S (dim x0) = dim x)... 
              rewrite dimx in H12... 
            rewrite <- H7, H10 in H6... admit. (* coding issue? *)
            inversion H9; clear H9. rewrite <- H6 in *...
            repeat (basic; intuition)... 
            assert (dim x0 = m)... 
              rewrite H8, dimx in H7...
            assert (S (dim x0) = dim x)...
              rewrite <- H8 in H7...
            assert (dim x0 <= m-1)...
              rewrite H7, dimx in H8... admit. (* coding issue? *)
        * rewrite Union_sym.
          apply Finite_Union...
          apply Finite_sup... apply cellcond... 
        * rewrite <- Setminus_is_Intersection_Complement.
          rewrite Union_sym. rewrite (Union_sym _ (sup P (m-1))). rewrite (Union_sym _ (plus x)).
          repeat (apply Finite_Union)... apply all_decidable... apply Finite_sup... apply cellcond. 
          apply Setminus_Finite'... apply Finite_Union...  apply Finite_sub... apply cellcond. 
          apply Finite_sup... apply cellcond. 
        * admit. (* as below *)
        * admit. (* as below *)

      + unfold L, R. 
        unfold is_a_cell... 
        * assert (Inhabited (plus x))... apply plus_Inhabited... admit. (* ?? *) 
          inversion H6; clear H6... exists x0...
        * admit. (* as below *)
        * admit. (* as below *)
        * apply (well_formed_Included P)... apply cellcond. 
          apply Intersection_Included_cancel_right...
        * repeat (rewrite <- Setminus_is_Intersection_Complement).
          rewrite Union_sym. 
          apply Setminus_Finite'... apply Finite_Union... apply Setminus_Finite'... apply cellcond. 
        * rewrite <- Setminus_is_Intersection_Complement.
          apply Setminus_Finite'... apply cellcond. 

        * unfold moves_def... 

          assert (forall k, sub (P ∩ √Singleton x) k == sub (
          ((((M ∩ √Singleton x) ∪ plus x) ∩ √minus x)
          ∪ Plus (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x))
          ∩ √Minus (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x)) k)...
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            pose (lt_eq_eq_lt_dec (S k) m);
              intuition;  
              repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            rewrite Setminus_is_Intersection_Complement. 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite <- H6 in a... 
            rewrite b. 
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set _ k) ||
                    rewrite (sub_minus_Empty_set _ k) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            rewrite <- H6 in b...
            assert (k = m)... rewrite H6.
            repeat (rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (sub_Singleton _ (S m))  ||
                    rewrite (sub_plus_Empty_set _ (S m)) ||
                    rewrite (sub_minus_Empty_set _ (S m)) ||
                    rewrite (sub_plus _ (m)) ||
                    rewrite (sub_minus _ (m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            inversion b; clear b...
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S m))) ||
                    rewrite (sub_Singleton _ (S m))  ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (sub_plus _ (m)) ||
                    rewrite (sub_minus _ (m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            repeat (rewrite (sub_Singleton_Empty_set _ ) ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
          apply Same_set_by_dimension in H6...

          assert (forall k, sub (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x) k ==
          sub (((P ∩ √Singleton x) ∪ Minus (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x))
          ∩ √Plus (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x)) k)...
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            pose (lt_eq_eq_lt_dec (S k) m);
              intuition;  
              repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            rewrite Setminus_is_Intersection_Complement. 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite <- H6 in a... 
            rewrite b. 
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set _ k) ||
                    rewrite (sub_minus_Empty_set _ k) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            rewrite <- H6 in b...
            assert (k = m)... rewrite H6.
            repeat (rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (sub_Singleton _ (S m))  ||
                    rewrite (sub_plus_Empty_set _ (S m)) ||
                    rewrite (sub_minus_Empty_set _ (S m)) ||
                    rewrite (sub_plus _ (m)) ||
                    rewrite (sub_minus _ (m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            inversion b; clear b...
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S m))) ||
                    rewrite (sub_Singleton _ (S m))  ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (sub_plus _ (m)) ||
                    rewrite (sub_minus _ (m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            repeat (rewrite (sub_Singleton_Empty_set _ ) ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
            rewrite H8 in H7...
          apply Same_set_by_dimension in H6...
            
        * unfold moves_def...

          assert (forall k, sub (P ∩ √Singleton x) k == sub (
          ((((M ∩ √Singleton x) ∪ plus x) ∩ √minus x) ∪ Plus (P ∩ √Singleton x))
          ∩ √Minus (P ∩ √Singleton x)) k)...
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            pose (lt_eq_eq_lt_dec k m);
              intuition;  
              repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            rewrite Setminus_is_Intersection_Complement. 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite <- H6 in a... 
            repeat (rewrite (sub_Singleton_Empty_set _ k) ||
                    rewrite (sub_plus _ k) ||
                    rewrite (sub_minus _ k) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            rewrite b. 
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S m))) ||
                    rewrite (sub_plus_Empty_set _ (S m)) ||
                    rewrite (sub_minus_Empty_set _ (S m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            repeat (rewrite (sub_Singleton_Empty_set _ ) ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            apply sub_Same_set_Proper... apply cellcond.
          apply Same_set_by_dimension in H6...

          assert (forall k, sub (((M ∩ √Singleton x) ∪ plus x) ∩ √minus x) k == sub (
          ((P ∩ √Singleton x) ∪ Minus (P ∩ √Singleton x)) ∩ √Plus (P ∩ √Singleton x)
          ) k)...
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            pose (lt_eq_eq_lt_dec k m);
              intuition;  
              repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            rewrite Setminus_is_Intersection_Complement. 
            apply sub_Same_set_Proper... apply cellcond.
            rewrite <- H6 in a... 
            repeat (rewrite (sub_Singleton_Empty_set _ k) ||
                    rewrite (sub_plus _ k) ||
                    rewrite (sub_minus _ k) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            rewrite b. 
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S m))) ||
                    rewrite (sub_plus_Empty_set _ (S m)) ||
                    rewrite (sub_minus_Empty_set _ (S m)) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            admit. (* ?? *)
            repeat (rewrite (sub_Singleton_Empty_set _ ) ||
                    rewrite (sub_plus_Empty_set _ ) ||
                    rewrite (sub_minus_Empty_set _ ) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)
                    ). 
            repeat (rewrite Setminus_is_Intersection_Complement). 
            apply sub_Same_set_Proper... apply cellcond.
          apply Same_set_by_dimension in H6...

      + unfold N, Q, celldim, setdim in H0...
        assert (dim x <= m).
          apply (H0)...
        assert (dim x = S m)...
          rewrite <- sub_Intersection in H...
        rewrite H8 in H7...

      + unfold L, R, celldim, setdim in H0.
        assert (Finite (sub M (S m))).
          apply Finite_sub... apply cellcond.
        (* somehow, there is an element of (sub M (S m) ∪ sub P (S m)) that is not x *)
        (* if this were not true, then there would be some contradiction on the
           size of m *) 
        assert (Inhabited ((sub M (S m) ∪ sub P (S m)) ∩ √Singleton x)). admit. (* ?? *) 
        inversion H8; clear H8...
        assert (dim x0 = S m)...
          apply In_Intersection in H9...
          apply In_Union in H8...
        assert (dim x0 <= m)...
          apply (H0 x0)...
          apply In_Intersection in H9...
          apply In_Union in H10...
          left... apply In_Intersection...
          left... apply In_Intersection... unfold sub, In at 1 in H9...
          apply In_Complement...
          assert (dim x0 = m)...
          rewrite H12 in H8...
          right... apply In_Intersection... unfold sub, In at 1 in H9...
        rewrite H8 in H10... 
       
      + split. 
      
        * unfold N, L...
          unfold Same_set, Included...
            assert ({dim x0 <= (S m)} + {(S m) < (dim x0)})... 
            inversion a; clear a... 
              assert ((x0 = x) \/ ~(x0 = x))... apply carrier_decidable_eq.
              right... 
              apply In_Intersection...
              apply In_Intersection...
              left... 
              apply In_Intersection...
              apply In_Complement... inversion H7... 
                apply In_Complement... 
                assert (S (dim x0) = dim x)...
                rewrite dimx, H8 in H10...
              apply In_Complement... assert (dim x0 = m)... rewrite H10 in H8...
              subst. 
              left...
            repeat (basic; intuition)...
              right... apply In_Intersection...
              apply In_Intersection...
              left...
              apply In_Intersection...
              apply In_Complement...
              inversion H12; clear H12...
              subst. assert (dim x0 = S m)...
              apply In_Complement...
                assert (S (dim x0) = dim x)...
                rewrite <- dimx, <- H13 in b...
              apply In_Complement... unfold sub, In at 1 in H12...
            repeat (rewrite <- Setminus_is_Intersection_Complement in H6). 
            repeat (rewrite <- sub_Union in H6 || rewrite <- sub_Setminus in H6). 
            repeat (rewrite    Setminus_is_Intersection_Complement in H6).
            repeat (basic; intuition)...
              unfold sup, In at 1 in H6...
              inversion H6; clear H6; subst...
              unfold sub, In at 1 in H9...
              exfalso. apply H13...
              unfold sub, In at 1...
              assert (S (dim x0) = dim x)...
              rewrite dimx in H12...

        * unfold Q, R... 
          unfold Same_set, Included...
            assert ((x = x0) \/ ~(x = x0))...
              apply carrier_decidable_eq... 
            left. 
              apply In_Intersection...
              apply In_Complement...
              assert (dim x0 = m)... 
              assert (dim x0 = (S m))... 
              rewrite <- H8. 
              unfold X, In at 1 in H0...
              apply triangle_rest_in_set in H0...
              rewrite H10 in H9...
            right... apply In_Intersection... apply In_Complement...
            repeat (rewrite <- Setminus_is_Intersection_Complement in H6). 
            repeat (rewrite sub_Union in H6 || rewrite sub_Setminus in H6).
            repeat (rewrite Setminus_is_Intersection_Complement in H6). 
            repeat (basic; intuition)...
              exfalso. apply H13...
              left; left. apply In_Intersection...
              apply In_Complement... apply H14...
              unfold sub, In at 1 in H12... 
              exfalso. apply H13...
              left; left. apply In_Intersection... right... 
              unfold sub, In at 1...
              assert (dim x = (S m))...
              assert (S (dim x0) = dim x)...
              rewrite H12 in H15...
              apply In_Complement... apply H14...
              unfold sub, In at 1 in H12...
              unfold sup, In at 1 in H6...
              inversion H12; clear H12... rewrite H6 in H10. unfold sub, In at 1 in H10...

      (* y case *)
    - set (N := (M ∩ (√(Singleton y)))).
      set (Q := ((P ∩ √(Singleton y)) ∪ minus y) ∩ √plus y).
      set (L := ((sup M (m-1) ∪ (((sub P m) ∪ (minus y)) ∩ √(plus y))) ∪ (Singleton y))).
      set (R := ((sup P m) ∪ ((Singleton y)))).
      assert (sup (sup M (m - 1) ∪ sub P m) (m - 1) == sup M (m-1)). 
        crush. exfalso. rewrite H7 in H8... apply (qwer'' m)... left... 
      assert ((sub (sup M (m - 1) ∪ sub P m) m) == sub P m).
        crush. exfalso. rewrite H9 in H8... apply (qwer'' m)... right... 
      exists N. exists Q. exists L. exists R. exists m.
      assert (dim y = S m) as ydim. 
        unfold Y, In at 1 in yismax... apply triangle_rest_in_set in H4... 
      splits...

      (* N and Q case *)
      + unfold N, Q. 
        unfold is_a_cell...
        * pose (M_0_Inhabited' _ _ cellcond). inversion i; clear i. exists x0. 
          split. apply H8. apply In_Complement... inversion H9; clear H9... 
          subst. assert (dim x0 = 0)... rewrite H9 in ydim... inversion ydim... 
        * assert (Inhabited (MinusPlus (Singleton y))). apply (MinusPlus_Inhabited _ m)... 
            apply In_Intersection in H... unfold Included... inversion H... 
            rewrite <- H10... exists y...
          inversion H8. exists x0. rewrite I_U_dist_r. right.
          unfold MinusPlus in H9. rewrite Plus_Singleton, Minus_Singleton in H9...  
        * apply (well_formed_Included M). apply cellcond. apply Intersection_Included_cancel_right...
        * admit. (* ?? *)
          (* apply well_formed_by_dimension.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement || 
                  rewrite sub_Union || 
                  rewrite sub_Setminus).
          pose (lt_eq_eq_lt_dec k m)...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite ydim in * )...
            admit. (* easy *)
            rewrite <- H8 in a...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite ydim in * )...
            repeat (rewrite <- sub_Union || 
                    rewrite <- sub_Setminus ||
                    rewrite Setminus_is_Intersection_Complement).
            assert (well_formed P). apply cellcond.
            assert (well_formed (minus y)). apply axiom2b.
            unfold well_formed in H8. unfold well_formed in H9...
            unfold well_formed... 
            unfold sub, In at 1 in H15. 
            unfold sub, In at 1 in H16...
            repeat (basic; intuition)...
              admit. (* ?? *)
              admit. (* ?? *) 
            unfold sub, In at 1 in H13. 
            unfold sub, In at 1 in H14...
            repeat (basic; intuition)...
              refine (H11 _ _ _ n0 _ _ _)... 
              admit. (* ?? *) 
              admit. (* ?? *)
              refine (H12 _ _ _ n0 _ _ _)... 
            repeat (rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite ydim in * )...
            admit. (* easy *)
            rewrite b in H8... rewrite b in H8...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_plus_Empty_set) ||
                    rewrite (sub_minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite ydim in * )...
            admit. (* easy *) *)
        * rewrite <- Setminus_is_Intersection_Complement...
          apply Setminus_Finite'... apply cellcond.
        * apply Setminus_Finite... rewrite Union_sym.
          apply Finite_Union...
          apply Setminus_Finite... apply cellcond. 
        * unfold moves_def... admit. (* ?? *) admit. (* ?? *)
        * unfold moves_def... admit. (* ?? *) admit. (* ?? *)

      (* L and R case *)
      + unfold L, R.  
        apply (Same_set_is_a_cell ((sup M (m - 1) ∪ ((sub P m ∪ Minus (Singleton y)) ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P m ∪ Singleton y))... 
        apply (Same_set_is_a_cell ((sup (sup M (m - 1) ∪ sub P m) (m - 1)
        ∪ ((sub (sup M (m - 1) ∪ sub P m) m ∪ Minus (Singleton y))
        ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P m ∪ Singleton y))... 
        apply (Lemma_3_2_c _ 1). 
        apply Cardinality_Singleton_is_one. 
        split. remember (target_is_a_cell m M P cellcond). unfold target in i.
        apply (Same_set_is_a_cell _ _ i). apply Union_sym. reflexivity.
        unfold celldim, setdim...
          inversion H8; clear H8; subst.
          inversion H9; clear H9; subst.
          apply (le_trans _ (m-1))...
          unfold sub, In at 1 in H8...
          rewrite H10; left. 
          apply H9.
        split.
        unfold Included... 
          inversion H8; clear H8; subst.
          unfold In, sub... 
          constructor.
        apply well_formed_Singleton.
        rewrite sub_Union.
        rewrite sub_idemp.
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        unfold Included...
          apply H7...
          unfold PlusMinus in H8. rewrite Plus_Singleton in H8...
          apply In_Intersection in H8...
          trivial. 
        rewrite H0, H1... 
        rewrite (Minus_Singleton y), (Plus_Singleton y)...
        
      + unfold celldim, setdim, N, Q in H2...
          assert (Inhabited ((sub M (S m) ∩ sub P (S m)) ∩ √Singleton y)). 
            admit. (* ?? *)
            (* it is certainly Finite. If it were empty then y = x = w.... *)
          inversion H9; clear H9.
          assert (dim x0 <= m).
            apply H2...
            left... 
            repeat (basic; intuition)... unfold sub, In at 1 in H10...
          assert (dim x0 = S m)...
            repeat (basic; intuition)...
          rewrite H11 in H9...
        
      + unfold celldim, setdim, L, R in H2... 
          assert (dim y <= m).
            apply H2...
          assert (dim y = S m)...
            apply In_Intersection in H...
          rewrite H10 in H9...

      + split.

        * unfold L, N...
          repeat (rewrite sub_Union).
          rewrite sub_sup_Empty_set.
          assert ( sub (Singleton y) m == Empty_set) as HH. 
            unfold sub, Same_set, Included, In... 
            exfalso. inversion H9; clear H9. rewrite <- H8, ydim in H10...
          rewrite HH. clear HH.
          rewrite Empty_set_ident_left.
          rewrite Empty_set_ident_right.
          assert (sub ((sub P m ∪ minus y) ∩ √plus y) m == ((sub P m ∪ minus y) ∩ √plus y) ) as BB.
            unfold sub at 1, Same_set, Included... 
            unfold In at 1 in H8; inversion H8; assumption.
            unfold In at 1... 
            inversion H8; clear H8; subst.
            inversion H9; clear H9; subst.
            unfold sub, In in H8...
            apply minus_dim in H8. rewrite ydim in H8.
            inversion H2... 
          rewrite BB.
          set (KK := ((sub P m ∪ minus y) ∩ √plus y)).
          unfold Same_set, Included... 
            assert (x0 = y ∨ x0 ≠ y) as OP. 
              apply carrier_decidable_eq.
            inversion OP; [right | left]; clear OP...
            subst. 
            apply In_Intersection... 
            apply In_Complement; unfold not... 
            unfold KK in H9. rewrite <- BB in H9.
            unfold sub at 1, In at 1 in H9... rewrite ydim in H11. 
            apply (n_Sn m)... 
            apply In_Intersection... 
            apply In_Complement; unfold not...
            inversion H10; subst...
            apply In_Union in H8...
            apply In_Intersection in H9...
            apply In_Intersection in H9...
            apply In_Union in H8...
            apply In_Union in H9...
            unfold sup, In at 1 in H8... 
            exfalso. unfold Complement, In at 1 in H10... 
            inversion H9; clear H9. rewrite <- H8.
            unfold Y, In at 1 in H4. apply triangle_rest_in_set in H4... apply H11. trivial. 

        * unfold Q, R.
          assert (forall k, (sub P k) ==
            sub (((((P ∩ √Singleton y) ∪ minus y) ∩ √plus y)
            ∩ √sub (((P ∩ √Singleton y) ∪ minus y) ∩ √plus y) m)
            ∪ (sup P m ∪ Singleton y)) k).
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement). 
          repeat (rewrite sub_Union || rewrite sub_Setminus). 
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_sup_cancel k m) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (Setminus_Empty_set) || 
                  rewrite (Empty_set_ident_left) || 
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)... 
          rewrite <- H8 in a...
          rewrite <- b in *.
          repeat (rewrite (sub_idemp k) || 
                  rewrite (sub_plus y k) || 
                  rewrite (sub_minus y k) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite (sub_idemp k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)... 
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left.
          rewrite sub_sup_cancel...
          rewrite H8 in ydim... 
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (sub_Singleton y k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set m k) ||
                  rewrite Setminus_Empty_set); try (rewrite b)... 
          apply Add_Setminus_Singleton. 
            apply carrier_decidable_eq. 
            apply In_Intersection in H... 
          rewrite ydim in H8... rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set m k) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in *)... 
          apply Same_set_by_dimension in H8... 
 Qed.

End ParityComplexTheory.                                    





