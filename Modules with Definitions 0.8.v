
(* Written by Mitchell Buckley 12/11/2013 *)

Require Import Ensembles Constructive_sets.
Require Import myFiniteDefs.
Require Import Relations.
Require Import mySetoids.
Require Import Utf8_core.
Require Import Max Le.
Require Import Arith.
Require Import Setoid.
Require Import Recdef.

(* Implicits *)

Arguments In : default implicits.
Arguments Setminus : default implicits.
Arguments Disjoint : default implicits.
Arguments Inhabited : default implicits.
Arguments Intersection : default implicits.
Arguments Union : default implicits.
Arguments Same_set : default implicits.
Arguments Included : default implicits.
Arguments Complement : default implicits.
Arguments Finite : default implicits.
Arguments Add : default implicits.
Arguments Singleton : default implicits.
Arguments Empty_set {U} _.
Arguments Full_set {U} _.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Preliminary definitions                              *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Definition restrict {A : Type} (X : Ensemble A) (R : relation A) : relation A :=
     (fun x => (fun y => In X x /\ In X y /\ R x y)).

  Hint Unfold decidable : sets v62. 

  Transparent In.

  Lemma strong_induction : 
    forall P : nat -> Prop,
    P O -> 
    (forall n : nat, (forall m, m <= n -> P m) -> P (S n)) -> 
    forall n : nat, P n.
  Proof with intuition.

    intros P.
    set (Q := fun n => (forall m, m <= n -> P m)).

    intros.
    assert (Q 0). unfold Q... inversion H1...
    assert (forall l, Q l -> Q (S l)). unfold Q...
    inversion H3...
    assert (Q n) as D.
      apply (nat_ind Q)...
    apply (D n). left.
  Qed.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Pre-Parity Complex Definitions                       *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Module Type PreParity.

  Parameter carrier : Type.
  Parameter dim : carrier -> nat.
  Parameter plus minus : carrier -> Ensemble carrier.

  Axiom carrier_decidable_eq : decidable_eq carrier.

  Axiom plus_dim :            forall (x y : carrier), In (plus y) x -> S(dim x) = dim y.
  Axiom minus_dim :           forall (x y : carrier), In (minus y) x -> S(dim x) = dim y. 
  Axiom plus_Finite :         forall (x : carrier),   Finite (plus x).
  Axiom minus_Finite :        forall (x : carrier),   Finite (minus x).
  Axiom plus_Inhabited :      forall (x : carrier),   dim x > 0 -> (Inhabited (plus x)).
  Axiom minus_Inhabited :     forall (x : carrier),   dim x > 0 -> (Inhabited (minus x)).
  Axiom plus_zero:            forall (x : carrier),   (dim x) = 0 ->  plus x == Empty_set.
  Axiom minus_zero:           forall (x : carrier),   (dim x) = 0 -> minus x == Empty_set.
  Axiom plus_minus_Disjoint : forall (y : carrier),   Disjoint (plus y) (minus y).
  
  Hint Resolve plus_dim minus_dim plus_Finite minus_Finite plus_minus_Disjoint.

  Hint Constructors Finite Cardinal Singleton Full_set.

  Lemma all_decidable : forall (S : Ensemble carrier), Finite S -> decidable S. 
  Proof.
    intros.
    apply Finite_are_decidable.
    apply carrier_decidable_eq.
    assumption.
  Qed.

  Hint Resolve all_decidable.

  End PreParity.

  Module PreParityTheory (M : PreParity).

  Import M.

  Definition sub (S : Ensemble carrier) (n : nat) : Ensemble carrier := 
    fun (x : carrier) => (In S x /\ dim x  = n).
  Definition sup (S : Ensemble carrier) (n : nat) : Ensemble carrier := 
    fun (x : carrier) => (In S x /\ dim x <= n).
    
  Definition setdim (S : Ensemble carrier) (n : nat) : Prop :=
    forall x, (In S x) -> dim x <= n.

  Definition Plus (X : Ensemble carrier) : Ensemble carrier :=
    fun (y : carrier) => (exists (x : carrier), (In X x) /\ (In (plus x) y)).
  Definition Minus (X : Ensemble carrier) : Ensemble carrier :=
    fun (y : carrier) => (exists (x : carrier), (In X x) /\ (In (minus x) y)). 

  Definition PlusMinus (X : Ensemble carrier) : Ensemble carrier := 
    Intersection (Plus X) (Complement (Minus X)).
  Definition MinusPlus (X : Ensemble carrier) : Ensemble carrier :=
    Intersection (Minus X) (Complement (Plus X)).

  Definition Perp (X Y : Ensemble carrier) : Prop :=
    (Intersection (Plus X) (Plus Y) == Empty_set) /\ (Intersection (Minus X) (Minus Y) == Empty_set).
  Definition perp (x y : carrier) : Prop :=
    (Intersection (plus x) (plus y) == Empty_set) /\ (Intersection (minus x) (minus y) == Empty_set).

  Definition less (x y : carrier) : Prop :=
    (Inhabited (Intersection (plus x) (minus y))).
  Definition curly_less (x y : carrier) : Prop :=
    (In (minus y) x) \/ (In (plus x) y). 
  
  Definition triangle : relation carrier := 
    clos_refl_trans_1n _ (less).
  Definition solid_triangle : relation carrier := 
    clos_refl_trans_1n _ (curly_less).
  Inductive triangle_rest (S : Ensemble carrier) : relation carrier :=
    | tr_refl  : forall x, In (S) x -> triangle_rest S x x
    | tr_trans : forall x y z, In (S) x -> less x y -> triangle_rest S y z -> triangle_rest S x z.
  Definition solid_triangle_rest (S : Ensemble carrier) : relation carrier := 
    clos_refl_trans_1n _ (restrict S curly_less).
    
  Definition is_a_segment (S T : Ensemble carrier) : Prop :=
    S ⊆ T /\
    forall x y z, (less x y) /\ (triangle_rest T y z) ->
    x ∈ S /\ z ∈ S ->
    y ∈ S. 

  Definition is_initial_segment (S T : Ensemble carrier) : Prop :=
    S ⊆ T /\
    forall y z, (triangle_rest T y z) ->
    z ∈ S ->
    y ∈ S. 

  Definition is_final_segment (S T : Ensemble carrier) : Prop :=
    S ⊆ T /\
    forall y z, (triangle_rest T y z) ->
    y ∈ S ->
    z ∈ S. 

  Hint Unfold PlusMinus MinusPlus Perp perp less curly_less triangle solid_triangle
    solid_triangle_rest Plus Minus sup sub: sets v62.

  Definition moves_def (S M P : Ensemble carrier) : Prop :=
    P == (Intersection (Union (M) ( Plus S)) (Complement (Minus S))) 
    /\
    M == (Intersection (Union (P) (Minus S)) (Complement ( Plus S))).

  Notation "S 'moves' M 'to' P" := (moves_def S M P) (at level 89).

  Definition well_formed (X : Ensemble carrier) : Prop :=
    (forall (x y : carrier), In X x /\ In X y 
      -> (dim x = O -> dim y = 0 -> x = y))
    /\
    (forall (x y : carrier), In X x /\ In X y 
      -> (forall (n : nat), dim x = S n -> dim y = S n -> not (perp x y) -> x = y)).

  Definition tight (R : Ensemble carrier) : Prop :=
    forall u v, 
      triangle u v ->  In R v -> Intersection (minus u) (PlusMinus R) == (Empty_set).

  Hint Unfold moves_def well_formed tight : sets v62.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results about triangle_rest                    *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Inductive triangle_rest' (S : Ensemble carrier) : relation carrier :=
    | tr_refl'  : forall x, In (S) x -> triangle_rest' S x x
    | tr_trans' : forall x y z, In (S) z -> less y z -> triangle_rest' S x y -> triangle_rest' S x z.

  Lemma triangle_rest_in_set : forall S, forall x y, triangle_rest S x y -> In S x /\ In S y.
  Proof with intuition.
    intros...
    induction H... induction H...
  Qed.

  Hint Resolve triangle_rest_in_set.

  Lemma triangle_rest_equiv : forall S, forall x y, triangle_rest S x y <-> triangle_rest' S x y.
  Proof with intuition.
  Admitted.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Ltac basic := 
  match goal with
    | H: ?P /\ ?Q |- _ => inversion H; clear H
    | H: _ |- ?P /\ ?Q => split
    | H: ?P, K: ?P -> False |- _ => contradiction
    | H: _ |- Disjoint ?P ?Q => constructor
    | H: Disjoint ?P ?Q |- _ => inversion H; clear H
    | H: exists x, ?P |- _ => inversion H; clear H
    | H: _ |- forall x, ?P => intros
    | H: In (Intersection ?S ?T) ?x |- _ => apply In_Intersection in H
    | H: _ |- In (Intersection ?S ?T) ?x  => apply In_Intersection
    | H: In (Union _ _) _ |- _ => apply In_Union in H
    | H: _ |- ?P == ?P => reflexivity
    | H: _ |- Included ?P ?P => reflexivity
    | H: _ |- ~ (?P) => unfold not; intros
    | H: Perp ?S ?T |- _ => unfold Perp in H
    | H: In ?P ?X, K: In (Complement ?P) ?X |- _ => unfold Complement in K; unfold In in K; unfold not in K; apply K in H; contradiction
    | H: In ?P ?x |- In (Union ?P ?Q) ?x => left
    | H: In ?Q ?x |- In (Union ?P ?Q) ?x => right
    | H: _ |- decidable _ => apply all_decidable
    | H: In (fun y => _) ?x |- _ => unfold In at 1 in H
    | H: _ |- In (fun y => _) ?x => unfold In at 1
    | [ H:(Same_set ?S ?T), _:(In ?T ?x) |- In ?S ?x ] => rewrite H; assumption
    | [ H:(Same_set ?S ?T), _:(In ?S ?x) |- In ?T ?x ] => rewrite <- H; assumption
  end.

  Ltac subsuptac := 
  match goal with
    | H: In (sub ?P ?n) ?x |- _ => unfold sub, In at 1 in H
    | H: In (sup ?P ?n) ?x |- _ => unfold sup, In at 1 in H
    | H: _ |- In (sub ?P ?n) ?x => unfold In, sub
    | H: _ |- In (sup ?P ?n) ?x => unfold In, sup
  end.

  Ltac disj := 
  match goal with
    | H: (?P ∪ ?Q) ?x |- _ => inversion H as [a K aeq | b K beq]; [clear H aeq a | clear H beq b]; unfold In in K
    | H: ?P ?x |- (?P ∪ _) ?x => left
    | H: ?P ?x |- (_ ∪ ?P) ?x => right
  end.

  Ltac conj := 
  match goal with
    | H: (?P ∩ ?Q) ?x |- _ => inversion H as [a H1 H2 aeq]; clear H a aeq; unfold In in H1; unfold In in H2
    | H: _ |- (?P ∩ ?Q) ?x => split; unfold In
  end.

  Ltac neg :=
  match goal with
    | H: (√(?P)) ?x |- _ => unfold Complement, In, not in H
    | H: _ |- (√(?P)) ?x => unfold Complement, In, not
  end.

  Ltac misc :=
  match goal with
    | H: (Empty_set) ?x |- _   => contradiction
    | H: (Full_set) ?x |- _    => clear H
    | H: _ |- (Full_set) ?x    => constructor
    | H: _ |- (Empty_set) ?x   => try (exfalso; auto)
    | H: ?a = ?b |- _          => subst
    | H: Singleton ?a ?a |- _  => clear a
    | H: Singleton ?a ?b |- _  => inversion H as [K]; clear H; try rewrite K in *; clear K
    | H: Disjoint ?a ?b |- _   => inversion H as [L]; clear H; unfold not, In in L 
    | H: _ |- Disjoint ?a ?b   => constructor; unfold In, not; intros
    | H: Inhabited ?S |- _       => inversion H; clear H
    | H: ?S ?x |- Inhabited ?S   => exists x; unfold In; trivial
  end.

  Ltac crush' := 
    autounfold with *;
    intuition; 
    repeat (conj || disj || neg || misc); 
    auto.
 
  Ltac crush := 
    autounfold with *;
    intuition (try (conj || disj || neg || misc); intuition).

  Lemma plus_minus_Disjoint_Lemma : forall x y, In (plus y) x -> In (minus y) x -> False.
  Proof with intuition.
    intros.
    pose (plus_minus_Disjoint y). 
    apply Disjoint_intersection_condition in d. 
    assert (In (Empty_set) x)... rewrite <- d... inversion H1.
  Qed.

  Hint Extern 2 (False) =>
    match goal with
    | H : S ?n <= ?n |- False => apply le_Sn_n in H; assumption
    | H : ?n   =  S ?n  |- False => apply n_Sn in H; assumption
    | H : S ?n =  ?n |- False => symmetry in H; apply n_Sn in H; assumption
    | H : In Empty_set _ |- False => inversion H
    | H : In (plus ?y) ?x, K : In (minus ?y) ?x |- False => apply (plus_minus_Disjoint_Lemma _ _ H K); assumption
    end.

  Lemma lt_Sn_n : forall n, ~(S n < n).
  Proof with intuition.
    intros n.
    induction n... 
    apply (lt_n_0) in H...
  Qed.

  Hint Resolve lt_irrefl le_lt_dec lt_Sn_n.

  Hint Extern 2 (False) => 
    match goal with
    | H : S ?n < ?n |- False => apply lt_Sn_n in H; assumption
    | H :   ?n < ?n |- False => apply lt_irrefl in H; assumption
    | H :   ?m < ?n , H' : ?n = ?m |- False => rewrite H' in H; apply lt_irrefl in H; assumption
    | H :   ?m < ?n , H' : ?m = ?n |- False => rewrite H' in H; apply lt_irrefl in H; assumption
    | H : S ?m < ?n , H' : ?n = ?m |- False => rewrite H' in H; apply lt_Sn_n in H; assumption
    | H : S ?m < ?n , H' : ?m = ?n |- False => rewrite H' in H; apply lt_Sn_n in H; assumption
    end.

  Hint Extern 2 (In _ _) => 
    match goal with 
      | H : ?S == ?T, _: In ?T ?x |- In ?S ?x => rewrite H; assumption 
      | H : ?S == ?T, _: In ?S ?x |- In ?T ?x => rewrite <- H; assumption 
    end.

  Lemma sub_Included_Lemma : forall S T m, Included (S) (sub T m) -> forall x, (In S x -> dim x = m). 
  Proof with crush. 
    unfold setdim...
    apply H...
  Qed.

  Lemma sub_def_Lemma : forall m x S, In (sub S m) x -> (dim x = m). 
  Proof with crush. 
    crush. 
  Qed.

  Lemma sup_def_Lemma : forall S m x, In (sup S m) x -> (dim x <= m). 
  Proof with crush. 
    crush. 
  Qed.

  Hint Extern 1 (dim _ = _) => 
    match goal with 
      | H: ?X ⊆ (sub _ (?n)), _: In ?X ?x |- (dim ?x = ?n) => apply (sub_Included_Lemma _ _ _ H)
      | H: In (sub _ ?n) ?x |- (dim ?x = ?n) => apply (sub_def_Lemma _ _ _ H) 
      | H: dim ?x = S ?n, K: In (minus ?x) ?y |- (dim ?y = ?n) =>
          apply minus_dim in K; rewrite H in K; inversion K; trivial
    end.

  Hint Extern 1 (dim _ <= _) => 
    match goal with 
    | H: In (sup _ ?n) ?x |- (dim ?x <= ?n) => apply (sup_def_Lemma _ _ _ H) 
    end.

  (* at some stage these should go, we never need to use n-1 *)
  Lemma qwer   : forall n, (n-1 <= n). Admitted.
  Lemma qwer'  : forall n, (n-1 <  n). Admitted.
  Lemma qwer'' : forall n, (n <= n-1) -> False. Admitted.

  Hint Resolve qwer qwer' qwer'' sub_Included_Lemma sub_def_Lemma sup_def_Lemma le_Sn_n n_Sn.

  (** SETOID MORPHISMS **)

  Add Parametric Morphism : (@Plus) with 
    signature (@Same_set carrier) ==> (@Same_set carrier) as Plus_Same_set.
  Proof with crush.
    crush. inversion H... exists x1...
    inversion H. exists x1... 
  Qed.

  Add Parametric Morphism : (@Minus) with 
    signature (@Same_set carrier) ==> (@Same_set carrier) as Minus_Same_set.
  Proof with crush.
    crush. inversion H. exists x1...
    inversion H. exists x1... 
  Qed.

  Add Parametric Morphism : (sub) with 
    signature (@Same_set carrier) ==> (@eq nat) ==> (@Same_set carrier) as sub_Same_set.
  Proof with intuition.
    crush.
  Qed.

  Add Parametric Morphism : (sup) with 
    signature (@Same_set carrier) ==> (@eq nat) ==> (@Same_set carrier) as sup_Same_set.
  Proof with intuition.
    crush.
  Qed.

  Add Parametric Morphism : (setdim) with 
    signature (@Same_set carrier) ==> (@eq nat) ==> (@iff) as setminus_Same_set.
  Proof with intuition.
    unfold setdim... 
  Qed.

  Add Parametric Morphism : (@moves_def) with 
    signature (@Same_set carrier) ==> (@Same_set carrier) ==> (@Same_set carrier) ==> (@iff) as moves_def_mor.
  Proof with intuition.
    unfold moves_def...
    rewrite <- H, <- H0, <- H1...
    rewrite <- H, <- H0, <- H1...
    rewrite H, H0, H1...
    rewrite H, H0, H1...
  Qed.

  Add Parametric Morphism : (triangle_rest) with 
    signature (@Same_set carrier) ==> (@eq carrier) ==> (@eq carrier) ==> (@iff) as triangle_rest_Same_set.
  Proof with intuition.
    intros S T... 
    induction H0.
      left. rewrite <- H...
      apply (tr_trans _ _ y); try rewrite <- H...
    induction H0.
      left. rewrite H...
      apply (tr_trans _ _ y); try rewrite H...
  Qed.

  Add Parametric Morphism : (well_formed) with
    signature (@Same_set carrier) ==> (iff) as well_formed_Same_set.
  Proof with intuition.
    autounfold with *...
      refine (H3 _ _ _ n _ _ _)...
      refine (H3 _ _ _ n _ _ _)...
  Qed.

  Lemma triangle_rest_trans : forall X, forall y z, triangle_rest X y z -> forall x, triangle_rest X z x -> triangle_rest X y x.
  Proof with intuition.
    intros...
    generalize dependent x.
    induction H...
      rename x0 into w.
      apply (tr_trans _ _ y)...
  Qed.

  Lemma triangle_rest_ind' :
    forall (S : Ensemble carrier) (P : carrier → carrier → Prop),
      (∀ x : carrier, x ∈ S → P x x) ->
        (∀ x y z : carrier,  
          triangle_rest S x y → triangle_rest S y z → P y z → P x z) ->
            ∀ u v : carrier, triangle_rest S u v → P u v.
  Proof with intuition.
    intros...
    induction H1... 
      apply (H0 x y z)...
      apply (tr_trans _ x y y)... left...
      inversion H3...  
  Qed.

  (** PLUS AND MINUS PROPERTIES **)

  Lemma Plus_Union_compat : forall S T,
     Plus (Union S T) == Union (Plus S) (Plus T).
  Proof with intuition. 
    autounfold with *...
    inversion H... inversion H1; [left |right]; unfold In; exists x0...
    inversion H; subst;
    unfold In in H0; inversion H0; exists x0... 
    left... right...
  Qed.

  Lemma Minus_Union_compat : forall S T,
     Minus (Union S T) == Union (Minus S) (Minus T).
  Proof with repeat basic; unfold In; auto.
    intros. autounfold with sets. unfold Minus...
    inversion H.
      left... exists x0...
      right... exists x0...
    inversion H.
      unfold In in H0. inversion H0. exists x1... left...
      unfold In in H0. inversion H0. exists x1... right...
  Qed.

  Lemma Minus_Singleton : forall x, Minus (Singleton x) == minus x.
  Proof with intuition.
    autounfold with *... inversion H... inversion H1... exists x...
  Qed.
  
  Lemma Plus_Singleton : forall x, Plus (Singleton x) == plus x.
  Proof with intuition.
    autounfold with *... inversion H... inversion H1... exists x...
  Qed.

  Lemma PlusMinus_Singleton : forall x, PlusMinus (Singleton x) == plus x.
  Proof with crush. 
    crush... 
    inversion H1... exists x... inversion H0...
    assert (dim x1 > 0 \/ dim x1 = 0).
      destruct (dim x1). right... left...
    inversion H1; clear H1.
    assert (Disjoint (plus x1) (minus x1)). 
      apply plus_minus_Disjoint...
    inversion H1. apply (H4 x0)...
    apply minus_zero in H2...
    assert (In Empty_set x0).
    rewrite <- H2... 
    unfold In in *... 
  Qed.

  Lemma MinusPlus_Singleton : forall x, MinusPlus (Singleton x) == minus x.
  Proof with crush. 
    crush... 
    inversion H1... exists x... inversion H0...
    assert (dim x1 > 0 \/ dim x1 = 0).
      destruct (dim x1). right... left...
    inversion H1; clear H1.
    assert (Disjoint (plus x1) (minus x1)). 
      apply plus_minus_Disjoint...
    inversion H1. apply (H4 x0)...
    apply plus_zero in H2... 
    assert (In Empty_set x0).
    rewrite <- H2... 
    unfold In in *...
  Qed.


  Lemma dim_1_properties : forall x, dim x = 1 -> 
    ( 
    Plus  (minus x) == Empty_set /\
    Plus  (plus  x) == Empty_set /\
    Minus (minus x) == Empty_set /\
    Minus (plus  x) == Empty_set 
    ). 
  Proof with intuition.
    intros x H... 
    crush... inversion H0 as [j]...
    assert (dim j = 0). apply minus_dim in H2. rewrite H in H2. auto. 
    assert (plus j == Empty_set). apply plus_zero... fold (In (plus j) x0) in H3. rewrite H4 in H3; unfold In in H3...
    crush... inversion H0 as [j]...
    assert (dim j = 0). apply plus_dim in H2. rewrite H in H2. auto. 
    assert (plus j == Empty_set). apply plus_zero... fold (In (plus j) x0) in H3. rewrite H4 in H3; unfold In in H3...
    crush... inversion H0 as [j]...
    assert (dim j = 0). apply minus_dim in H2. rewrite H in H2. auto. 
    assert (minus j == Empty_set). apply minus_zero... fold (In (minus j) x0) in H3. rewrite H4 in H3; unfold In in H3...
    crush... inversion H0 as [j]...
    assert (dim j = 0). apply plus_dim in H2. rewrite H in H2. auto. 
    assert (minus j == Empty_set). apply minus_zero... fold (In (minus j) x0) in H3. rewrite H4 in H3; unfold In in H3...
  Qed.

  (** SUB AND SUP PROPERTIES **)

  Lemma sub_Included : forall T n, Included (sub T n) T.
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Included...
  Qed.

  Lemma sup_Included : forall T n, Included (sup T n) T.
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Included...
  Qed.

  Lemma sub_sup_Included : forall T n, Included (sub T n) (sup T n).
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Included...
    rewrite H1...
  Qed.

  Hint Resolve sub_Included sup_Included sub_sup_Included.

  Lemma sup_Union : forall T R n, sup (Union T R) n == Union (sup T n) (sup R n).
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Same_set; unfold Included...
    inversion H0; [left | right]...
    inversion H; [left | right]...
    inversion H; inversion H0...
  Qed.

  Lemma sub_Union : forall T R n, sub (Union T R) n == Union (sub T n) (sub R n).
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Same_set; unfold Included...
    inversion H0; [left | right]...
    inversion H; [left | right]...
    inversion H; inversion H0...
  Qed.

  Lemma sub_Included_compat : forall S T, S ⊆ T -> forall m, (sub S m) ⊆ (sub T m).
  Proof.
    autounfold with *. intuition.
  Qed.

  Lemma sup_Included_compat : forall S T, S ⊆ T -> forall m, (sup S m) ⊆ (sup T m).
  Proof.
    autounfold with *. intuition.
  Qed.

  Lemma sup_Intersection : forall T R n, sup (Intersection T R) n == Intersection (sup T n) (sup R n).
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Same_set; unfold Included...
  Qed.

  Lemma sub_Intersection : forall T R n, sub (Intersection T R) n == Intersection (sub T n) (sub R n).
  Proof with repeat (basic || subsuptac); auto.
    intros.
    unfold Same_set; unfold Included...
  Qed.

  Lemma sub_idemp : forall n S, sub (sub S n) n == sub S n.
  Proof with intuition.
    autounfold with *...
  Qed. 

  Lemma sup_idemp : forall n S, sup (sup S n) n == sup S n.
  Proof with intuition.
    autounfold with *...
  Qed. 

  Lemma sub_Minus : forall n T, sub (Minus T) n == Minus (sub T (S n)).
  Proof with intuition.
    autounfold with *. 
    intros. split.
    intros... 
    inversion H0. exists x0... subst. symmetry. apply minus_dim...
    intros.
    inversion H; clear H...
    exists x0...
    apply minus_dim in H1... rewrite H2 in H1... 
  Qed.

  Lemma sup_Plus : forall T n, sup (Plus T) n == Plus (sup T (S n)).
  Proof with repeat (basic || subsuptac); auto.
    unfold Same_set.
    intros.
    unfold Included...
    unfold Plus in H0. unfold In in H0. inversion H0. clear H0...
    unfold Plus. unfold In. exists x0... unfold sup... apply plus_dim in H2.
    rewrite <- H2. apply le_n_S...
    generalize dependent n.
    unfold Plus. unfold Included...
    unfold In. exists x0... unfold sup in H...
    unfold In in H. inversion H. clear H...
    apply le_S_n. apply plus_dim in H1. rewrite H1...
  Qed.

  Lemma sub_Plus : forall n T, sub (Plus T) n == Plus (sub T (S n)).
  Proof with intuition.
    autounfold with *. 
    intros. split.
    intros... 
    inversion H0. exists x0... subst. symmetry. apply plus_dim...
    intros.
    inversion H; clear H...
    exists x0...
    apply plus_dim in H1... rewrite H2 in H1... 
  Qed.

  Lemma sup_Minus : forall T n, sup (Minus T) n == Minus (sup T (S n)).
  Proof with repeat (basic || subsuptac); auto.
    unfold Same_set.
    intros.
    unfold Included...
    unfold Plus in H0. unfold In in H0. inversion H0. clear H0...
    unfold Plus. unfold In. exists x0... unfold sup... apply minus_dim in H2.
    rewrite <- H2. apply le_n_S...
    generalize dependent n.
    unfold Minus. unfold Included...
    unfold In. exists x0... unfold sup in H...
    unfold In in H. inversion H. clear H...
    apply le_S_n. apply minus_dim in H1. rewrite H1...
  Qed.

  Lemma sub_sup_Empty_set : forall n k, n < k -> forall S, sub (sup S n) k == Empty_set.
  Proof with intuition.
    autounfold with *... 
    subst. exfalso. 
    apply (le_Sn_n n).
    apply (le_trans _ (dim x))...
  Qed. 

  Lemma Sn_minus_1 : forall n, (S n - 1 = n).
  Proof. intros. simpl. symmetry. apply minus_n_O. Qed.

  Lemma Finite_sup : forall T, Finite T -> forall n, Finite (sup T n). 
  Proof with intuition.
    intros.
    apply (Finite_Included'' T)...
    assert ({dim x <= n} + {~ (dim x) <= n})...
      apply le_dec.
  Qed.

  Lemma Finite_sub : forall T, Finite T -> forall n, Finite (sub T n). 
  Proof with intuition.
    intros.
    apply (Finite_Included'' T)...
    assert ({dim x = n} + {~ (dim x) = n})...
      apply eq_nat_dec.
  Qed.

  Hint Resolve Finite_sub Finite_sup.

  (** WELL_FORMED PROPERTIES **)
  
  Lemma well_formed_Included : 
    forall T, well_formed T -> forall R, Included R T -> well_formed R.
  Proof with intuition.
    autounfold with *...
    refine (H1 _ _ _ n _ _ _)... 
  Qed.

  Lemma well_formed_Singleton : 
    forall x, well_formed (Singleton x).
  Proof with intuition.
    intros x.
    unfold well_formed...
    inversion H2; inversion H3; subst...
    inversion H0; inversion H1; subst...
  Qed.

  Lemma dim_0_Singleton : forall S, Inhabited (sub S 0) -> well_formed S ->
    exists d, sub S 0 == Singleton d. 
  Proof with intuition.
    intros.
    inversion H; clear H.
    exists x.
    unfold Same_set, Included...
    assert (x = x0).
    unfold well_formed in H0...
    repeat subsuptac.
    apply H2...
    subst...
    inversion H... subst...  
  Qed.
 
  Hint Resolve well_formed_Singleton well_formed_Included.

  (** RESULTS ABOUT TRIANGLE **)

  Lemma equal_dim : forall x y, triangle x y -> (dim x = dim y). 
  Proof with repeat basic; auto.
    unfold triangle.
    apply (clos_refl_trans_1n_ind carrier).
      intros... 
      intros... 
      inversion H; clear H. rename x0 into w...
      apply plus_dim in H. apply minus_dim in H3. rewrite <- H1. rewrite <- H3.
      rewrite <- H...
  Qed.

  Lemma rest_implies_full : forall S x y, triangle_rest S x y -> triangle x y.
  Proof with intuition.
    intros.
    induction H...
      left.
      apply (Relation_Operators.rt1n_trans _ _ _ y)...
  Qed.

  (** FINITES SETS HAVE MAXIMAL ELEMENTS **)

  Lemma Finite_carrier_have_max_dim_element : 
    forall (T : Ensemble carrier), Finite T -> Inhabited T -> exists u, ((In T u) /\ 
      (forall v, (In T v) -> dim v <= dim u)).
  Proof with repeat basic; auto.
    intros.
    induction H.
      inversion H0. inversion H. 
      
      assert ((A == Empty_set) \/ (Inhabited A)). apply Finite_Empty_or_Inhabited. assumption.
           inversion H2. 
           exists x... apply Add_intro2. unfold Add in H4... inversion H4.
           rewrite H3 in H5. inversion H5. apply Singleton_inv in H5.        
           subst. apply le_refl. 
           apply IHFinite in H3. inversion H3 as [z]. 
           assert (((dim x) <= (dim z)) \/ ((dim z) <= (dim x))). apply le_total.
           inversion H5; [exists z | exists x]... left... unfold Add in H4...
           inversion H4... apply Singleton_inv in H10; subst...
           right... unfold Add in H4...
           inversion H4... apply (le_trans _ (dim z) _)... 
           apply Singleton_inv in H10; subst...

      assert (Inhabited T). inversion H0. apply (Inhabited_intro _ _ x). 
      rewrite <- H1... 
      apply IHFinite in H2. inversion H2. exists x...
  Qed. 

  Hint Resolve Finite_are_decidable carrier_decidable_eq.

  Lemma Plus_Finite : 
    forall A, Finite A ->
      Finite (Plus A).
  Proof with intuition.
    intros.
    induction H...
      apply (Finite_Same_set Empty_set)...
      crush. 
      inversion H... 

      unfold Add.
      rewrite Plus_Union_compat.
      rewrite Plus_Singleton.
      apply Finite_Union... 
      
      rewrite H0...
  Qed.

  Lemma Minus_Finite : 
    forall A, Finite A ->
      Finite (Minus A).
  Proof with intuition.
    intros.
    induction H.
      apply (Finite_Same_set Empty_set)...
      crush. inversion H... 

      unfold Add. 
      rewrite Minus_Union_compat. 
      rewrite Minus_Singleton. 
      apply Finite_Union...
   
      rewrite H0...
  Qed.

  Lemma PlusMinus_Finite : 
    forall A, Finite A ->
      Finite (PlusMinus A).
  Proof with intuition.
    intros.
    unfold PlusMinus.
    apply (Finite_Included'' (Plus A))...
    apply Plus_Finite...
    crush.
    assert ((In (Minus A) x) \/ ~(In (Minus A) x))...
      apply all_decidable...
      apply Minus_Finite...
    right... apply In_Intersection in H1...
  Qed.

  Lemma MinusPlus_Finite : 
    forall A, Finite A ->
      Finite (MinusPlus A).
  Proof with intuition.
    intros.
    unfold MinusPlus.
    apply (Finite_Included'' (Minus A))...
    apply Minus_Finite...
    crush.
    assert ((In (Plus A) x) \/ ~(In (Plus A) x))...
      apply all_decidable...
      apply Plus_Finite...
    right... apply In_Intersection in H1...
  Qed.

  Hint Resolve all_decidable Plus_Finite Minus_Finite PlusMinus_Finite MinusPlus_Finite.

  Lemma Setminus_Finite : 
    forall A, @Finite carrier A ->
    forall B, Finite B ->
      Finite (Intersection A (Complement B)).
  Proof with intuition.
    intros.
    induction H.
    - apply (Finite_Same_set Empty_set)...

    - unfold Add.
      rewrite I_U_dist_r. 
      apply Finite_Union...
      assert (In B x \/ ~(In B x)). 
        apply all_decidable... 
      inversion H2; clear H2.
      + apply (Finite_Same_set Empty_set).
        constructor.
        unfold Same_set, Included...  
        * repeat basic. 
          inversion H4; clear H4; subst... unfold Complement, In at 1 in H5...
        * inversion H2...
      + apply (Finite_Same_set (Singleton x)).
        apply Finite_Singleton.
        unfold Same_set, Included...
        * repeat basic. 
          inversion H4...
        * inversion H2; clear H2; subst...

    - rewrite H1...
  Qed.

  Lemma less_decidable : forall x y, ((less x y) \/ ~(less x y)).
  Proof with intuition.
    intros.
    assert (Finite (Intersection (plus x) (minus y))).
      apply Finite_Intersection. 
      apply minus_Finite.
      apply all_decidable...
    apply Finite_Empty_or_Inhabited in H.
    inversion H; clear H; [right | left]...
      unfold less in H.
      rewrite H0 in H.
      inversion H. 
      inversion H1.
  Qed.

  Lemma triangle_rest_Included : forall S x y, triangle_rest S x y -> 
    forall T, Included S T -> triangle_rest T x y.
  Proof with intuition.
    intros...
    induction H...
      left...
      right with y...
  Qed.

  Lemma Setminus_Included {U : Type}: forall S T, @Included U (Setminus S T) S.
  Proof with intuition.
    crush. 
  Qed.

  Lemma triangle_rest_dec : 
    forall T, 
      Finite T -> 
      forall x z, (triangle_rest T z x \/ ~(triangle_rest T z x)).
  Proof with intuition.
   (* could use strong induction on cardinality of T? *)
   intros T TFin. 
   assert (exists n, Cardinal T n) as K.
   apply Cardinality_exists... 
   inversion K as [n TCard]; clear K. 
   revert n T TFin TCard. 
   refine (strong_induction _ _ _)...
     - right... 
       apply Cardinality_zero_Empty_set in TCard. 
       rewrite TCard in H...
       apply triangle_rest_in_set in H...
     - set (R := fun r => less z r /\ In T r).
       assert (Finite R) as RFin. 
         apply (Finite_Included'' T)... 
         unfold R, Included... unfold In at 1 in H0...
         assert ((less z x0) \/ ~(less z x0))...
         apply less_decidable. 
         left... unfold R, In at 1... 
         right... unfold R, In at 1 in H1...
       assert (exists n, Cardinal R n) as J.
       apply Cardinality_exists... 
       inversion J as [k RCard]; clear J...
       assert (decidable T) as Tdec.
         apply Finite_are_decidable...       
       assert ((In T x) \/ ~(In T x))... 
         apply Tdec.
       assert ((In T z) \/ ~(In T z))... 
         apply Tdec.
       assert ((z = x) \/ ~(z = x))... 
         apply carrier_decidable_eq.       
       left. 
       rewrite H3; left...
                     
       destruct k. 
       + right...
         inversion H0...
         assert (In R y).
           unfold R, In at 1...
           apply triangle_rest_in_set in H6... 
         apply Cardinality_zero_Empty_set in RCard. 
         rewrite RCard in H9... 
       + set (T' := Setminus T (Singleton z)). 
         assert (Finite T') as T'Fin. 
           unfold T'... 
           rewrite Setminus_is_Intersection_Complement. 
           apply Setminus_Finite...  
           apply Finite_Singleton...
         set (Q := fun w => triangle_rest T' w x).
         assert (Finite Q) as QFin. 
           apply (Finite_Included'' T)... 
           unfold Q, Included, In at 1...
           apply triangle_rest_in_set in H0...
           unfold T', In at 1 in H4... inversion H4... 
           assert ((x0 = z) \/ ~(x0 = z)). 
             apply carrier_decidable_eq... 
           idtac... 
           right... 
           rewrite H5 in H4.
           assert (In T' z). 
             unfold Q, In at 1 in H4... 
             apply triangle_rest_in_set in H4... 
           unfold T', In at 1 in H6...
           inversion H6...
           assert (triangle_rest T' x0 x ∨ (triangle_rest T' x0 x → False)). 
             apply (H n)...
             unfold T'. apply Cardinal_Setminus... 
           idtac...  
         assert (Finite (Intersection R Q)).
           apply Finite_Intersection...
         apply (Finite_Empty_or_Inhabited) in H0...
         * right...
           inversion H0...
           assert (In (Intersection R Q) y). 
             apply In_Intersection...
             unfold R, In at 1...
             apply triangle_rest_in_set in H7... 
             unfold Q, In at 1...         
             subst.
             admit. 
           rewrite H4 in H10... 
         * left... 
           inversion H4; clear H4.
           apply In_Intersection in H0... 
           unfold R, In at 1 in H4.
           unfold Q, In at 1 in H5.
           right with x0... 
           apply (triangle_rest_Included T')...
           unfold T'... 
           apply Setminus_Included. 

       + right... apply H2... apply triangle_rest_in_set in H0... 
       + right... apply H1... apply triangle_rest_in_set in H0... 
  Qed.

  Lemma sub_sup_0 : forall X, sub X 0 == sup X 0.
  Proof with intuition.
    crush. rewrite H1... 
  Qed.

  Hint Resolve Finite_Singleton sub_sup_0.

 Lemma Minus_dim : 
      forall X Y n, Included X (sub Y (S n)) -> 
      forall y, In (Minus X) y ->
      dim y = n.
  Proof with intuition.
    idtac... unfold Minus, In at 1 in H0...
    inversion H0; clear H0...
    assert (dim x = (S n))...
  Qed.

  Lemma Plus_dim : 
      forall X n, Included X (sub Full_set (S n)) -> 
      forall y, In (Plus X) y ->
      dim y = n.
  Proof with intuition.
    idtac... unfold Plus, In at 1 in H0...
    inversion H0; clear H0...
    assert (dim x = (S n))... assert (S (dim y) = (dim x))...
    rewrite H1 in H3...
  Qed.

  Lemma Plus_dim' : 
      forall X n, Included X (sup Full_set (n)) -> 
      forall y, In (Plus X) y ->
      S (dim y) <= n.
  Proof with intuition.
    idtac... unfold Plus, In at 1 in H0...
    inversion H0; clear H0...
    assert (dim x <= (n))... apply H...  assert (S (dim y) = (dim x))...
    rewrite H3...
  Qed.

  Lemma Minus_dim' : 
      forall X n, Included X (sup Full_set (n)) -> 
      forall y, In (Minus X) y ->
      S (dim y) <= n.
  Proof with intuition.
    idtac... unfold Minus, In at 1 in H0...
    inversion H0; clear H0...
    assert (dim x <= (n))... apply H...  assert (S (dim y) = (dim x))...
    rewrite H3...
  Qed.
  
  Lemma Minus_Included : forall X Y, Included X Y -> Included (Minus X) (Minus Y). 
  Proof with intuition. 
    crush... 
    inversion H0; clear H0. 
    exists x0...
  Qed.

  Lemma Plus_Included : forall X Y, Included X Y -> Included (Plus X) (Plus Y). 
  Proof with intuition. 
    crush... 
    inversion H0; clear H0. 
    exists x0...
  Qed.

  Lemma SSn_n : forall n, S (S n)  = n -> False. 
  Proof with intuition. 
    intros... induction n... inversion H.
  Qed.
  Lemma le_SSn_n : forall n, S (S n) <= n -> False. 
  Proof with intuition. 
    intros... induction n... inversion H.
  Qed.

  Hint Resolve SSn_n le_SSn_n.


  Lemma Finite_sup_n : forall M, Finite M -> forall n, Finite (sup M n).
  Proof with intuition.
    intros.
    apply (Finite_Included'' M)...
    unfold sup, Included, In...
    assert ({dim x <= n} + {n < dim x}). apply le_lt_dec.
    inversion H1; clear H1; [left | right]. 
      unfold sup... 
      intros. unfold lt in H2. unfold sup, In in H1... 
      apply (le_Sn_n n). apply (le_trans _ (dim x))...
  Qed.

  Lemma Finite_sub_n : forall M, Finite M -> forall n, Finite (sub M n).
  Proof with intuition.
    intros.
    apply (Finite_Included'' M)...
    unfold sub, Included, In...
    assert ({eq_nat n (dim x)} + {~ eq_nat n (dim x)}). 
      apply eq_nat_decide.
    inversion H1; clear H1; [left | right]...
      apply eq_nat_is_eq in H2...
      apply H2. 
      apply eq_nat_is_eq...
  Qed.

  Lemma Finite_Minus : forall X, Finite X -> Finite (Minus X).
  Proof with intuition.
    intros.
    induction H.
    
    assert (Minus Empty_set == Empty_set).
      unfold Same_set, Minus, Included, In... inversion H...
    rewrite H.
    apply Finite_Empty_set.
    
    unfold Add.
    rewrite Minus_Union_compat. 
    rewrite Union_sym. 
    apply Finite_Union... 

    rewrite H0...
  Qed.

  Lemma Finite_Plus : forall X, Finite X -> Finite (Plus X).
  Proof with intuition.
    intros.
    induction H.
    
    assert (Plus Empty_set == Empty_set).
      unfold Same_set, Minus, Included, In... exfalso. inversion H...
    rewrite H...
    
    unfold Add.
    rewrite Plus_Union_compat. 
    rewrite Union_sym. 
    apply Finite_Union... 

    rewrite H0...
  Qed.

  Lemma Finite_PlusMinus : forall X, Finite X -> Finite (PlusMinus X).
  Proof with intuition.
    intros.
    apply (Finite_Included'' (Plus X))...
      unfold PlusMinus. apply Intersection_Included_cancel_right...
    apply all_decidable... 
  Qed.

  Lemma Finite_MinusPlus : forall X, Finite X -> Finite (MinusPlus X).
  Proof with intuition.
    intros.
    apply (Finite_Included'' (Minus X))...
      unfold MinusPlus. apply Intersection_Included_cancel_right...
    apply all_decidable...  
  Qed.

  Hint Resolve Finite_sub_n Finite_sup_n Finite_PlusMinus Finite_MinusPlus Finite_Plus Finite_Minus.

  Lemma wf_maximal_exists : 
    forall X n, Finite X /\ Inhabited X /\ setdim X n -> 
      well_formed X -> 
        exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    destruct n... 
      - unfold well_formed in H0... 
        inversion H; clear H...
        exists x... 
        constructor...
        apply In_Intersection in H... 
        assert (S (dim x0) = dim x)... 
        apply H3 in H0... 
        rewrite <- H in H0... 
        apply le_Sn_O in H0...
      - unfold well_formed in H0... 
        inversion H; clear H... 
        set (Z := fun s => triangle x s).
        assert (Finite Z /\ Inhabited Z)... 
          admit. admit. 
        (* find max in Z *)
  Admitted. 

  Lemma sub_Sn_sup_n : forall M n, (Union (sub M (S n)) (sup M n)) == sup M (S n).
  Proof with intuition.
   crush. 
   rewrite H0; crush.
   inversion H1; clear H1; [left | right]; crush.
  Qed.

    Lemma well_formed_Union : 
      forall A, well_formed A ->
      forall B, well_formed B ->
        (forall x y, x ∈ A /\ y ∈ B -> ~ (dim x = dim y)) ->
        well_formed (Union A B).
    Proof with intuition.
      unfold well_formed...
        inversion H7; clear H7; subst...
        inversion H8; clear H8; subst...
          exfalso; apply (H2 x y)... rewrite H5, H6... 
        inversion H8; clear H8; subst...
          exfalso; apply (H2 y x)... rewrite H5, H6...
        inversion H5; clear H5; subst...
        inversion H6; clear H6; subst...
          refine (H1 _ _ _ n _ _ _)... 
          exfalso; apply (H2 x y)... rewrite H, H7...
        inversion H6; clear H6; subst...
          exfalso; apply (H2 y x)... rewrite H, H7...
          refine (H4 _ _ _ n _ _ _)... 
    Qed.

  Lemma ZZZ :  
    forall S T : Ensemble carrier,
    (S ⊆ T /\ 
    (forall x z : carrier, x ∈ S ∧ z ∈ S -> 
        forall y, triangle_rest T x y ∧ triangle_rest T y z -> 
           y ∈ S)) ->
    (is_a_segment S T).
  Proof with intuition.
   intros...
   unfold is_a_segment...
   apply (H1 x z)...
   assert (In T y)...
     inversion H4... 
   apply (tr_trans _ _ y)...
   left...
  Qed.

  Lemma ZZZb :  
    forall S T : Ensemble carrier,
    (is_a_segment S T)
    ->
    (S ⊆ T /\ 
    (forall x z : carrier, x ∈ S ∧ z ∈ S -> 
        forall y, triangle_rest T x y ∧ triangle_rest T y z -> 
           y ∈ S)).
  Proof with intuition.
    intros. 
    unfold is_a_segment in H...
    (* need other induction principle for triangle_rest *)
  Admitted.

  Lemma well_formed_by_dimension : 
    forall X, 
      well_formed X <-> forall n, well_formed (sub X n).
  Proof with intuition.
    intros...
    - unfold well_formed in *...
      + apply H0... apply  H4. apply H5.
      + apply H1 with (n := n0)... apply H2. apply H3.
    - unfold well_formed in *...
      + apply (H 0)... 
      + specialize H with (n := (S n))...
        apply (H6) with (n := n)...
  Qed.

  Lemma sub_Setminus : 
    forall A B k, sub (Setminus A B) k == Setminus (sub A k) (sub B k).
  Proof with intuition.
    crush.
  Qed.

  Lemma moves_by_dim : forall T M P, ((T moves M to P) <-> (forall n, (sub T (S n) moves (sub M n) to (sub P n)))).
  Proof with intuition. 
    intros... 
     - unfold moves_def in *... 
       + rewrite H0... 
         rewrite <- Setminus_is_Intersection_Complement.
         rewrite sub_Setminus. 
         rewrite Setminus_is_Intersection_Complement.
         rewrite sub_Union.
         rewrite sub_Minus.
         rewrite sub_Plus...
       + rewrite H1... 
         rewrite <- Setminus_is_Intersection_Complement.
         rewrite sub_Setminus. 
         rewrite Setminus_is_Intersection_Complement.
         rewrite sub_Union.
         rewrite sub_Minus.
         rewrite sub_Plus...
     - unfold moves_def in *... 
       + unfold Same_set, Included... 
         assert (In (sub P (dim x)) x)... 
         specialize H with (n := (dim x))...
         rewrite <- sub_Plus in H2.
         rewrite <- sub_Minus in H2.
         rewrite <- sub_Union in H2.
         rewrite <- Setminus_is_Intersection_Complement in H2.
         rewrite <- sub_Setminus in H2. 
         rewrite Setminus_is_Intersection_Complement in H2.
         rewrite H2 in H1... 
         subsuptac... 
         assert (In (sub ((M ∪ Plus T) ∩ √Minus T) (dim x)) x)... 
         specialize H with (n := (dim x))...
         rewrite <- sub_Plus in H2.
         rewrite <- sub_Minus in H2.
         rewrite <- sub_Union in H2.
         rewrite <- Setminus_is_Intersection_Complement in H2.
         rewrite <- sub_Setminus in H2. 
         rewrite Setminus_is_Intersection_Complement in H2.
         rewrite <- H2 in H1... 
         subsuptac... 
       + unfold Same_set, Included... 
         assert (In (sub M (dim x)) x)... 
         specialize H with (n := (dim x))...
         rewrite <- sub_Plus in H3.
         rewrite <- sub_Minus in H3.
         rewrite <- sub_Union in H3.
         rewrite <- Setminus_is_Intersection_Complement in H3.
         rewrite <- sub_Setminus in H3. 
         rewrite Setminus_is_Intersection_Complement in H3.
         rewrite H3 in H1... 
         subsuptac... 
         assert (In (sub ((P ∪ Minus T) ∩ √Plus T) (dim x)) x)... 
         specialize H with (n := (dim x))...
         rewrite <- sub_Plus in H3.
         rewrite <- sub_Minus in H3.
         rewrite <- sub_Union in H3.
         rewrite <- Setminus_is_Intersection_Complement in H3.
         rewrite <- sub_Setminus in H3. 
         rewrite Setminus_is_Intersection_Complement in H3.
         rewrite <- H3 in H1... 
         subsuptac... 
  Qed.

  Lemma setdim_Union : forall S T n, (setdim S n /\ setdim T n) <-> setdim (Union S T) n.
  Proof with intuition.
    unfold setdim... basic... 
  Qed.

  Lemma setdim_sup : forall S n k, k <= n -> setdim (sup S k) n.
  Proof with intuition.
    unfold setdim, sup... unfold In at 1 in H0... apply (le_trans _ k)... 
  Qed.

  Lemma setdim_sub : forall S n k, k <= n -> setdim (sub S k) n.
  Proof with intuition.
    unfold setdim, sub... unfold In at 1 in H0... rewrite H2... 
  Qed.

  Lemma setdim_Setminus : forall R T n, setdim R n -> setdim (Setminus R T) n.
  Proof with intuition.
    unfold setdim, Setminus... unfold In at 1 in H0...
  Qed.

  Lemma setdim_Minus : forall T n, setdim T (S n) -> setdim (Minus T) n.
  Proof with intuition.
    unfold setdim... 
    inversion H0...  assert (S (dim x) = dim x0)... apply H in H2... 
    rewrite <- H1 in H2...
  Qed.

  Lemma setdim_Included : forall R T, Included R T -> forall n, setdim T n -> setdim R n.
  Proof with intuition.
    unfold setdim... 
  Qed.

  Lemma setdim_Singleton : forall x n, setdim (Singleton x) n <-> dim x <= n. 
  Proof with intuition.
    unfold setdim...
    inversion H0...
    rewrite <- H1...
  Qed.

  Ltac setdimtac :=
    match goal with
     | H : _ |- setdim (Union _ _) _ => apply setdim_Union
     | H : _ |- setdim (Setminus _ _) _ => apply setdim_Setminus
     | H : _ |- setdim (Intersection _ (Complement _)) _ => rewrite <- Setminus_is_Intersection_Complement
     | H : _ |- setdim (sub _ _) _ => apply setdim_sub
     | H : _ |- setdim (sup _ _) _ => apply setdim_sup
     | H : _ |- setdim (Minus _) _ => apply setdim_Minus
     | H : _ |- setdim (Singleton _) _ => apply setdim_Singleton
    end; 
    intuition; 
    try setdimtac.
 
  Lemma sub_sub_Empty_set : forall n k, ~(n=k) -> forall T, sub (sub T n) k == Empty_set.
  Proof with intuition. 
    intros...
    crush... apply H. rewrite H3 in H2...
  Qed. 

  Lemma initial_property : forall S T M, 
    is_initial_segment S M -> 
    Included T M ->
    Disjoint S T -> 
      forall a b, 
        In S a -> 
        In T b ->
        less b a -> False.
  Proof with intuition.
    intros...
    unfold is_initial_segment in H... 
    inversion H1; clear H1... 
    apply (H b)... apply In_Intersection... 
    apply (H6 _ a)... apply (tr_trans _ _ a)... left... 
  Qed.

  Lemma final_property : forall T S M, 
    is_final_segment T M -> 
    Included S M ->
    Disjoint S T -> 
      forall a b, 
        In S a -> 
        In T b ->
        less b a -> False.
  Proof with intuition.
    intros...
    unfold is_final_segment in H... 
    inversion H1; clear H1... 
    apply (H a)... apply In_Intersection... 
    apply (H6 b)... apply (tr_trans _ _ a)... left... 
  Qed.

  Lemma sub_Included' : forall S T, Included S T -> forall n, Included (sub S n) (sub T n).
  Proof with intuition. 
    crush. 
  Qed. 

  Lemma sub_PlusMinus : forall M n, PlusMinus (sub M (S n)) == sub (PlusMinus M) n.
  Proof with intuition.
  intros...
  unfold Same_set, Included, PlusMinus; repeat (basic; intuition)...
    apply sub_Intersection... 
    rewrite sub_Plus... 
    apply In_Intersection...
    assert (dim x = n). rewrite <- sub_Plus in H0...  
    unfold sub, In at 1... 
    apply In_Complement...
    apply H1...
    rewrite <- sub_Minus...
    rewrite <- sub_Plus...
    unfold sub, In at 1 in H... unfold sub, In at 1...
    basic...
    unfold sub, In at 1 in H... basic...
    apply In_Complement...
    apply H2...
    rewrite <- sub_Minus in H0...
    unfold sub, In at 1 in H0...
  Qed. 

  Lemma sub_MinusPlus : forall M n, MinusPlus (sub M (S n)) == sub (MinusPlus M) n.
  Proof with intuition.
  intros...
  unfold Same_set, Included, MinusPlus; repeat (basic; intuition)...
    apply sub_Intersection... 
    rewrite sub_Minus... 
    apply In_Intersection...
    assert (dim x = n). rewrite <- sub_Minus in H0...  
    unfold sub, In at 1... 
    apply In_Complement...
    apply H1...
    rewrite <- sub_Plus...
    rewrite <- sub_Minus...
    unfold sub, In at 1 in H... unfold sub, In at 1...
    basic...
    unfold sub, In at 1 in H... basic...
    apply In_Complement...
    apply H2...
    rewrite <- sub_Plus in H0...
    unfold sub, In at 1 in H0...
  Qed. 

Lemma Perp_thing :
    forall U V, Disjoint U V -> well_formed (Union U V) -> Finite U -> Finite V -> 
       (forall a b, In U a /\ In V b -> dim a = dim b) ->
       (Plus U ∩ Plus V == Empty_set ∧ Minus U ∩ Minus V == Empty_set). 
  Proof with intuition.
    intros... 
    - rename H3 into G.
      unfold well_formed in H0...
      apply Disjoint_intersection_condition. 
      constructor... 
      apply In_Intersection in H0... 
      inversion H5; clear H5.
      inversion H6; clear H6...
      assert (x0 = x1).
        remember (dim x0) as w.
        destruct (w).
        + exfalso. rewrite plus_zero in H7...
        + refine (H4 _ _ _ w _ _ _)...
          rewrite Heqw. symmetry. apply G...
          unfold perp in H5... 
          assert (In Empty_set x)... 
          rewrite <- H9... +
      rewrite H5 in *.
      inversion H... 
      apply (H9 x1)... 
    - rename H3 into G.
      unfold well_formed in H0...
      apply Disjoint_intersection_condition. 
      constructor... 
      apply In_Intersection in H0... 
      inversion H5; clear H5.
      inversion H6; clear H6...
      assert (x0 = x1).
        remember (dim x0) as w.
        destruct (w).
        + exfalso. rewrite minus_zero in H7...
        + refine (H4 _ _ _ w _ _ _)...
          rewrite Heqw. symmetry. apply G...
          unfold perp in H5... 
          assert (In Empty_set x)... 
          rewrite <- H10... +
      rewrite H5 in *.
      inversion H... 
      apply (H9 x1)... 
  Qed.

  Lemma Disjoint_three {U : Type} : 
    forall S T R, @Disjoint U S R /\ Disjoint T R -> 
      Disjoint (Union S T) R.
  Proof with intuition.
    intros...
    repeat basic... 
    apply (H1 x)... 
    apply (H x)... 
  Qed.

  Lemma sub_Singleton_Empty_set : forall y k, ~(dim y = k) -> sub (Singleton y) k == Empty_set.
  Proof with intuition.
    intros...
    crush. 
    inversion H1; subst...
  Qed. 

  Lemma sub_plus_Empty_set : forall y k, ~(dim y = S k) -> sub (plus y) k == Empty_set.
  Proof with intuition.
    intros...
    crush.
    assert (S (dim x) = dim y)...
    apply H. rewrite <- H0...
  Qed. 

  Lemma sub_minus_Empty_set : forall y k, ~(dim y = S k) -> sub (minus y) k == Empty_set.
  Proof with intuition.
    intros...
    crush.
    assert (S (dim x) = dim y)...
    apply H. rewrite <- H0...
  Qed. 

  Lemma sub_Singleton : forall y k, (dim y = k) -> sub (Singleton y) k == Singleton y.
  Proof with intuition.
    intros...
    crush.
    inversion H0; subst... 
  Qed. 

  Lemma sub_plus : forall y k, (dim y = S k) -> sub (plus y) k == plus y.
  Proof with intuition.
    intros...
    crush.
    assert (S (dim x) = dim y)...
    rewrite H in H1... 
  Qed. 

  Lemma sub_minus : forall y k, (dim y = S k) -> sub (minus y) k == minus y.
  Proof with intuition.
    intros...
    crush.
    assert (S (dim x) = dim y)...
    rewrite H in H1... 
  Qed. 

  Lemma Setminus_cancel {U : Type} : forall S, Setminus S S == @Empty_set U.
  Proof with intuition.
    intros...
    crush.
  Qed. 

  Lemma sub_Same_set':
  ∀ x y : Ensemble carrier,
  x == y <-> ∀ k : nat, sub x k == sub y k.
  Admitted.

  Lemma lt_eq_eq_lt_dec: forall k m, {k < m} + {k = m} + {k = S m} + {S m < k}. 
  Proof with intuition.
   intros. 
   pose (lt_eq_lt_dec k m)... 
   unfold lt in b. 
   apply le_lt_eq_dec in b...
  Qed.

  Lemma TT : forall k S T, setdim T k /\ setdim S k -> 
                (forall m, m <= k -> sub T m == sub S m) -> S == T.
  Proof with intuition.
   intros...
     unfold Same_set, Included... 
       assert (dim x <= k)...
       apply (sub_Included T (dim x))...
       rewrite H0...
       assert (dim x <= k)...
       apply (sub_Included S (dim x))...
       rewrite <- H0...
  Qed.

  Lemma FFF : forall R T, 
    (R == T) <-> forall k, sub R k == sub T k.
  Proof with intuition.
    intros...
    rewrite H...
    unfold Same_set, Included...
    assert (In (sub R (dim x)) x)... 
    rewrite H in H1. subsuptac... 
    assert (In (sub T (dim x)) x)... 
    rewrite <- H in H1. subsuptac... 
  Qed.


  Lemma Plus_Empty_set : Plus (Empty_set) == Empty_set.
  Proof with intuition. 
    unfold Same_set, Included... 
    exfalso; inversion H... 
    exfalso... 
  Qed.

  Lemma Minus_Empty_set : Minus (Empty_set) == Empty_set.
  Proof with intuition. 
    unfold Same_set, Included... 
    exfalso; inversion H... 
    exfalso... 
  Qed.  

  Lemma Setminus_Empty_set {U : Type}: forall T, Setminus T (@Empty_set U) == T.
  Proof with intuition. 
    unfold Setminus, Same_set, Included...
      unfold In at 1 in H...
      unfold In at 1...
  Qed.

  Lemma sub_sup_cancel : forall k n, k <= n -> forall P, sub (sup P n) k == sub P k.
  Proof with intuition. 
    crush...
  Qed.

  Lemma sup_sub_comm : forall S n k, sup (sub S n) k == sub (sup S k) n. 
  Proof with intuition. 
    crush.
  Qed.

  Lemma sup_sup_comm : forall S n k, sup (sup S n) k == sup (sup S k) n. 
  Proof with intuition. 
    crush.
  Qed.

  Lemma sup_sup_min : forall S n k, k <= n -> sup (sup S n) k == sup S k. 
  Proof with intuition. 
    crush. apply (le_trans _ k)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 2                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Observation_p321 : 
    forall (S : Ensemble carrier), Finite S -> S moves (MinusPlus S) to (PlusMinus S).
  Proof with intuition.
    unfold moves_def, PlusMinus, MinusPlus...

    rewrite U_I_dist_r.
    rewrite Full_set_property.
    rewrite Full_set_ident_right.
    rewrite I_U_dist_r.
    rewrite Empty_set_property.
    rewrite Empty_set_ident_left.
    reflexivity. 
    apply all_decidable... 

    rewrite U_I_dist_r.
    rewrite Full_set_property.
    rewrite Full_set_ident_right.
    rewrite I_U_dist_r.
    rewrite Empty_set_property.
    rewrite Empty_set_ident_left.
    reflexivity. 
    apply all_decidable... 
  Qed.

  Lemma Prop_2_1 : forall (S M : Ensemble carrier), 
     Finite S ->
     ((exists (P : Ensemble carrier), S moves M to P) 
     <->
     (MinusPlus S) ⊆ M /\ Disjoint M (Plus S)).
  Proof with repeat basic; auto.
    unfold moves_def; unfold PlusMinus; unfold MinusPlus. 
    intros S M SFin; split; intros. 
    inversion H as [P]; clear H.
    intuition.

    rewrite H1.
    apply Intersection_Included_compat. unfold Included... reflexivity.

    constructor. unfold not; intros. apply In_Intersection in H0. intuition.
    rewrite H1 in H2...

    exists ((M ∪ Plus S) ∩ √Minus S).
    split; try reflexivity.
    rewrite U_I_dist_r.
    rewrite Full_set_property.
    rewrite Full_set_ident_right.
    rewrite I_U_dist_r. 
    rewrite I_U_dist_r.
    rewrite Empty_set_property.
    rewrite Empty_set_ident_right.
    inversion H; clear H.
    assert ((M ∩ √Plus S) == M). apply Intersection_Included_left.
    apply Disjoint_property_right. apply Disjoint_sym. assumption. 
    rewrite H; clear H.
    symmetry. rewrite Union_sym.
    apply Union_Included_left. apply H0.
    apply all_decidable... 
  Qed.

  Lemma Prop_2_1' : forall (S M : Ensemble carrier), 
     Finite S ->
     (S moves M to ((M ∪ (Plus S)) ∩ √(Minus S)) 
     <->
     (MinusPlus S) ⊆ M /\ Disjoint M (Plus S)).
  Proof with intuition. 
    intros S M SFin. split; intros.
    apply Prop_2_1...
    exists ((M ∪ Plus S) ∩ √Minus S). assumption.
    apply Prop_2_1 in H...
    inversion H as [P K]. 
    unfold moves_def in *...
    rewrite <- H0...
  Qed.
  
  Lemma Prop_2_1_dual : forall (S P : Ensemble carrier), 
     Finite S ->
     ((exists (M : Ensemble carrier), S moves M to P) 
     <->
     (PlusMinus S) ⊆ P /\ Disjoint P (Minus S)).
  Proof with repeat basic; auto.
    unfold moves_def; unfold PlusMinus; unfold MinusPlus. 
    intros S P SFin; split; intros. 
    inversion H as [M]; clear H.
    intuition.

    rewrite H. 
    apply Intersection_Included_compat. unfold Included... reflexivity.

    constructor. unfold not; intros. apply In_Intersection in H0. intuition.
    rewrite H in H2... 

    exists ((P ∪ Minus S) ∩ √Plus S).
    split; try reflexivity.
    rewrite U_I_dist_r.
    rewrite Full_set_property.
    rewrite Full_set_ident_right.
    rewrite I_U_dist_r. 
    rewrite I_U_dist_r.
    rewrite Empty_set_property.
    rewrite Empty_set_ident_right.
    inversion H; clear H.
    assert ((P ∩ √Minus S) == P). apply Intersection_Included_left.
    apply Disjoint_property_right. apply Disjoint_sym. assumption. 
    rewrite H; clear H.
    symmetry. rewrite Union_sym.
    apply Union_Included_left. apply H0. 
    auto.
  Qed.

  Lemma Prop_2_1_dual' : ∀ S P : Ensemble carrier,
       Finite S
    → (S moves ((P ∪ Minus S) ∩ √Plus S) to P)
         ↔ PlusMinus S ⊆ P ∧ Disjoint P (Minus S).
  Proof with intuition. 
    intros S P SFin. split; intros.
    apply Prop_2_1_dual...
    exists ((P ∪ Minus S) ∩ √Plus S). assumption.
    apply Prop_2_1_dual in H...
    inversion H as [M K]. 
    unfold moves_def in *...
    rewrite <- H1...
  Qed.

  Lemma Prop_2_2 : 
    forall (S A B X: Ensemble carrier),
    Finite S ->
    S moves A to B -> X ⊆ A -> Disjoint (MinusPlus S) X 
    -> 
    forall (Y : Ensemble carrier),  
    Disjoint Y (Plus S) -> Disjoint Y (Minus S) 
    ->
    S moves ((A ∪ Y) ∩ (√X)) to ((B ∪ Y) ∩ (√X)).
  Proof with intuition.
    intros S A B X SFin. intros.
    unfold moves_def in H. inversion H; clear H.
    assert (exists (P : Ensemble carrier), S moves ((A ∪ Y) ∩ √X) to P).
      apply Prop_2_1. assumption.
      split.
        apply Included_trans with (T:=(A ∩ √X)).
          rewrite H5. 
          rewrite <- (Intersection_idemp (MinusPlus S)).
          apply Intersection_Included_compat.
          unfold MinusPlus. 
          apply Intersection_Included_compat.
          apply Union_Included_cancel_left. reflexivity. reflexivity.
          apply Disjoint_property_left. apply H1.
          apply Intersection_Included_compat.
          apply Union_Included_cancel_right; reflexivity. reflexivity.
          
        apply Disjoint_intersection_condition.
        rewrite Intersection_trans. rewrite (Intersection_sym _ (Plus S)).
        rewrite <- Intersection_trans.
        rewrite I_U_dist_r. assert (Disjoint Y (Plus S)). apply H2. 
        apply Disjoint_intersection_condition in H. rewrite H.
        rewrite Empty_set_ident_right.
        rewrite H5. rewrite (Intersection_trans _ _ (Plus S)).
        rewrite (Intersection_sym _ (Plus S)). rewrite Empty_set_property...
        rewrite Empty_set_zero_right...

    inversion H as [P].
    assert (P == (B ∪ Y) ∩ √X).
    Focus 2. unfold moves_def. unfold moves_def in H6. inversion H6; clear H6. 
    split; rewrite <- H7; assumption.
    clear H.
    inversion H6; clear H6.
    rewrite H, H4.
    repeat rewrite U_I_dist_r.
    rewrite Union_trans.
    rewrite (Union_sym Y).
    rewrite <- Union_trans.
    repeat rewrite Intersection_trans.
    rewrite Intersection_Same_set_compat; try reflexivity.
    rewrite (Union_sym _ Y). 
    rewrite (Union_Included_left Y _).
    rewrite (Union_sym). 
    rewrite (Union_Included_left).
    apply Intersection_sym. 
    apply Complement_Included_flip. apply (Included_trans _ _ _ H0).
    rewrite H5. apply Intersection_Included_cancel_left. reflexivity.
    apply Disjoint_property_left. apply H3.
  Qed.

  Lemma Prop_2_3 : 
    forall (S M P T Q : Ensemble carrier),
    S moves M to P -> T moves P to Q -> (Disjoint (Minus S) (Plus T) ) 
    ->
    (S ∪ T) moves M to Q.
  Proof with repeat basic; auto.
    intros.
    unfold moves_def in *.  intuition. 
    
    rewrite H. 
    assert (Plus T == Intersection (Plus T) (Complement (Minus S))).
      symmetry. apply Intersection_Included_left. apply Disjoint_property_right. assumption. 
    rewrite H0.
    rewrite H2.
    rewrite <- I_U_dist_r.
    assert ((√Minus S ∩ √Minus T) == (√Minus(Union S T))). 
    rewrite Minus_Union_compat. rewrite Union_Complement_compat...
    rewrite <- H5.
    rewrite <- Intersection_trans.
    assert ((Plus S ∪ Plus T) == (Plus (S ∪ T))). 
    rewrite Plus_Union_compat...
    rewrite <- H6.
    rewrite <- Union_trans...

    rewrite H3. 
    assert (Minus S == Intersection (Minus S) (Complement (Plus T))).
      symmetry. apply Intersection_Included_left. apply Disjoint_property_right. 
      apply Disjoint_sym. assumption. 
    rewrite H0.
    rewrite H4.
    rewrite <- I_U_dist_r.
    assert ((√Plus T ∩ √Plus S) == (√Plus(Union S T))). 
    rewrite Plus_Union_compat. rewrite Union_Complement_compat... rewrite Union_sym...
    rewrite <- H5.
    rewrite <- Intersection_trans.
    assert ((Minus T ∪ Minus S) == (Minus (S ∪ T))). 
    rewrite Minus_Union_compat... rewrite Union_sym...
    rewrite <- H6. 
    rewrite <- Union_sym, Union_trans...
  Qed.

 
  Lemma Prop_2_4 :
    forall (T Z M P : Ensemble carrier),
    Finite Z -> Finite T -> (Union T Z) moves M to P -> 
    Included (PlusMinus Z) P ->
    Perp T Z ->
    exists N N', (N == N') /\ (T moves M to N) /\ (Z moves N' to P).
  Proof with repeat basic; auto.
    intros T Z M P ZFin TFin. 
    remember (Union T Z) as S.
    intros.
    assert (Finite S) as SFin. rewrite HeqS. apply Finite_Union...
    unfold moves_def in H...
    
    assert (exists N, Z moves N to P). 
    apply Prop_2_1_dual. assumption.
      split; try assumption.
      assert (Included (Minus Z) (Minus S)). 
        rewrite HeqS. rewrite Minus_Union_compat. apply Union_Included_cancel_left. reflexivity.
      apply Disjoint_intersection_condition. apply (Included_Empty_set _ (P ∩ Minus S)). apply Intersection_Included_compat...
      rewrite H2. rewrite Intersection_trans. rewrite (Intersection_sym _ (Minus S)). 
      rewrite Empty_set_property...
    inversion H1 as [N']; clear H1.

    assert (exists N', T moves M to N').        
    apply Prop_2_1. assumption. split.
      assert (K1: Plus T == (Plus S) ∩ √(Plus Z)). 
        rewrite HeqS. rewrite Plus_Union_compat. rewrite I_U_dist_r.
        rewrite Empty_set_property. rewrite Empty_set_ident_right.
        apply Disjoint_result... 
      assert (K2: Minus T == (Minus S) ∩ √(Minus Z)). rewrite HeqS. 
        rewrite Minus_Union_compat. rewrite I_U_dist_r.
        rewrite Empty_set_property. rewrite Empty_set_ident_right.
        apply Disjoint_result...  
      assert ((MinusPlus T) == (MinusPlus S ∩ √(Minus Z)) ∪ (Minus S ∩ (PlusMinus Z)) ). 
        unfold MinusPlus, PlusMinus. rewrite K1, K2.
        rewrite (Intersection_Complement_compat).
        rewrite (Complement_Complement_compat).
      unfold Same_set; unfold Included...
        inversion H7... left... right... 
        inversion H1. apply In_Intersection in H6... apply In_Intersection in H6... 
        inversion H1. apply In_Intersection in H6... apply In_Intersection in H6... 
        inversion H1; apply In_Intersection in H6...  
        auto. auto.

      assert (M == (Union M (Intersection (Minus S) P))).
      unfold Same_set; unfold Included...
        inversion H6... symmetry in H3. rewrite <- H3...
        rewrite H2 in H9... 

      rewrite H1, H6. rewrite H3.
      unfold MinusPlus.
      unfold Included...
      inversion H7. left... right... 

      (* apply Disjoint_intersection_condition.  *)
      constructor... rewrite H3 in H6...
      rewrite HeqS in H8. assert ((√Plus (T ∪ Z)) == ((√ Plus T ∩ √ Plus Z))).
      rewrite Plus_Union_compat. rewrite Union_Complement_compat...
      rewrite H6 in H8...

    inversion H1 as [N]; clear H1. 
    exists N. exists N'...
    
    unfold moves_def in H5. inversion H5. clear H5.
    unfold moves_def in H6. inversion H6. clear H6.
    rewrite H7, H5. 
    assert ((Plus T) == (Intersection (Plus S) (Complement (Plus Z)))).
      rewrite HeqS. rewrite Plus_Union_compat. rewrite I_U_dist_r.
      rewrite Empty_set_property. rewrite Empty_set_ident_right.
      apply Disjoint_result. assumption.
    assert ((Minus T) == (Intersection (Minus S) (Complement (Minus Z)))).
      rewrite HeqS. rewrite Minus_Union_compat. rewrite I_U_dist_r.
      rewrite Empty_set_property. rewrite Empty_set_ident_right.
      apply Disjoint_result. assumption. 
    rewrite H6, H9. 
    rewrite Intersection_Complement_compat. 
    rewrite Complement_Complement_compat.
    rewrite U_I_dist_l. 
    rewrite Intersection_trans. 
    rewrite (Intersection_sym (M ∪ √Plus Z) _).
    rewrite <- Intersection_trans. 
    rewrite (I_U_dist_l (M ∪ Plus S)). 
    rewrite <- H2.
    assert ((Minus Z) ⊆ Union (MinusPlus S) (Plus S)).
      assert ((Union (MinusPlus S) (Plus S)) == (Union (Minus S) (Plus S))).
        unfold MinusPlus. rewrite U_I_dist_r. rewrite Full_set_property. rewrite Full_set_ident_right...
        auto.
      rewrite H10. rewrite HeqS. rewrite Minus_Union_compat. left; right...
    assert ((MinusPlus S ∪ Plus S) ⊆ (Union M (Plus S))). 
      unfold MinusPlus. rewrite H3. apply Union_Included_compat. 
      apply Intersection_Included_compat. apply Union_Included_cancel_left. 
      reflexivity. reflexivity. reflexivity.
    assert (Minus Z ⊆ M ∪ Plus S). 
      apply (Included_trans _ (MinusPlus S ∪ Plus S)). apply H10... assumption.
    assert (((M ∪ Plus S) ∩ Minus Z) == (Minus Z)).
      unfold Same_set; unfold Included... rewrite H13.
    assert ((M ∪ √Plus Z) == (√Plus Z)).
      apply Union_Included_left.
      rewrite H3. apply Intersection_Included_cancel_left.
      apply Complement_Included_flip. rewrite HeqS. 
      rewrite Plus_Union_compat. apply (Included_trans _ (Plus T ∪ Plus Z) _).
      unfold Included; intros; right... apply Complement_closure.
    rewrite H14... auto. auto.
  Qed.

  Lemma Prop_2_4' : (* ignore this lemma for the moment, sort it out near the end *)
    forall (T Z M P : Ensemble carrier),
    Finite Z -> Finite T -> (Union T Z) moves M to P -> 
    Included (PlusMinus Z) P ->
    Perp T Z ->
    (T moves M to (M ∪ Plus T) ∩ √Minus T) /\ 
    (Z moves (P ∪ Minus Z) ∩ √Plus Z to P) /\ 
    ((P ∪ Minus Z) ∩ √Plus Z == (M ∪ Plus T) ∩ √Minus T).
  Proof with repeat basic; auto.
    intros T Z M P ZFin TFin. 
    remember (Union T Z) as S.
    intros.
    assert (Finite S) as SFin. 
      rewrite HeqS. apply Finite_Union...
    
    assert ((T moves M to (M ∪ Plus T) ∩ √Minus T)) as A.
    apply Prop_2_1'. 
    assumption. 
    admit.

    assert ((Z moves (P ∪ Minus Z) ∩ √Plus Z to P)) as B.
    apply Prop_2_1_dual'. 
    assumption.
      split; try assumption.
      assert (Included (Minus Z) (Minus S)). 
        rewrite HeqS. rewrite Minus_Union_compat. apply Union_Included_cancel_left. reflexivity.
      apply Disjoint_intersection_condition. 
      apply (Included_Empty_set _ (P ∩ Minus S))... 
      apply Intersection_Included_compat...
      admit.
    
    intuition. 

    unfold moves_def in A...
    unfold moves_def in B...
    unfold moves_def in H...

    assert ((Plus T) == (Intersection (Plus S) (Complement (Plus Z)))) as C.
      rewrite HeqS. rewrite Plus_Union_compat. rewrite I_U_dist_r.
      rewrite Empty_set_property. rewrite Empty_set_ident_right.
      apply Disjoint_result. assumption.
    assert ((Minus T) == (Intersection (Minus S) (Complement (Minus Z)))) as D.
      rewrite HeqS. rewrite Minus_Union_compat. rewrite I_U_dist_r.
      rewrite Empty_set_property. rewrite Empty_set_ident_right.
      apply Disjoint_result. assumption. 
    rewrite C, D. 
    rewrite Intersection_Complement_compat. 
    rewrite Complement_Complement_compat.
    rewrite U_I_dist_l. 
    rewrite Intersection_trans. 
    rewrite (Intersection_sym (M ∪ √Plus Z) _).
    rewrite <- Intersection_trans. 
    rewrite (I_U_dist_l (M ∪ Plus S)). 
    rewrite <- H7.
    assert ((Minus Z) ⊆ Union (MinusPlus S) (Plus S)). admit.
    assert ((MinusPlus S ∪ Plus S) ⊆ (Union M (Plus S))). admit.
    assert (Minus Z ⊆ M ∪ Plus S). admit. 
    assert (((M ∪ Plus S) ∩ Minus Z) == (Minus Z)). admit.
    assert ((M ∪ √Plus Z) == (√Plus Z)). admit.
    rewrite H11...
    rewrite H12...  
    auto. 
    auto.
  Qed.

End PreParityTheory.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Parity Complex Definitions                           *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Module Type ParityComplex.
 
  Declare Module C : PreParity.
  Import C.
  Module PPT := PreParityTheory C.
  Import PPT.

  Axiom axiom1 :
    forall (x : carrier), 
      Union (Plus (plus x)) (Minus (minus x)) == Union (Plus (minus x)) (Minus (plus x)).

  Axiom axiom2a :
    forall x, well_formed (plus x).

  Axiom axiom2b :
    forall x, well_formed (minus x).

  Axiom axiom3a:
    forall x y : carrier, 
      triangle x y -> triangle y x -> x = y.

  Axiom axiom3b:
    forall x y z : carrier, 
    triangle x y ->
    (~ (In (plus z) x /\ In (minus z) y) /\ ~ (In (plus z) y /\ In (minus z) x)).

  Hint Resolve axiom2a axiom2b.

End ParityComplex.

Module ParityComplexTheory (M : ParityComplex).

  Import M.
  Import C.
  Import PPT. 

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
 
  Lemma gggg : 
    forall n Z, Cardinal Z n -> 
        forall X, Cardinal X n -> 
            @Included carrier Z X -> X == Z.
  Proof with intuition.
    intros n Z Zcard.
    induction Zcard...
      - apply Cardinality_zero_Empty_set... 
      - unfold Same_set...
        unfold Add, Included...
        assert (X == Add (Setminus X (Singleton x)) x). 
          apply Add_Setminus_Singleton. apply carrier_decidable_eq...
          apply H1... 
        assert (Setminus X (Singleton x) == A). 
          apply IHZcard...
          apply Cardinal_Setminus... unfold Included... 
          assert ((x1 = x) \/ ~(x1 = x))... apply carrier_decidable_eq...
            + exfalso. apply H... rewrite <- H6...
            + unfold Setminus, In at 1... inversion H5... + 
        rewrite H3 in H2. 
        unfold Add in H2. apply In_Union in H2... 
      - rewrite <- H. apply IHZcard...
  Qed.

  Lemma minimal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set n)
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X y m) -> m = y).
  Proof with intuition.    
    refine (strong_induction _ _ _)...
   
    - apply Cardinality_one_Singleton in H. 
      inversion H; clear H.
      exists x... rewrite H1... 
    
    - assert (Inhabited X).
        apply Cardinal_Sn in H0... 
      inversion H2; clear H2.
   
      set (Z := (fun y => triangle_rest X y x)).

      assert (Z ⊆ X) as SS. 
        unfold Z, Included, In at 1... inversion H2... 

      assert (Finite Z /\ Inhabited Z). 
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0... 
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0... 
        exists x... unfold Z, In at 1... left... 

      assert (exists k, Cardinal Z (S k)) as K. 
        apply Finite_Inhabited_Cardinal_Sn... 
        inversion K as [k L]; clear K... 
    
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L... 
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n). 
          assert (S (S k) <= S (S n))... 
            refine (Cardinal_le Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n... 

        inversion H2; clear H2.
    
        * assert (X == Z). 
            apply (gggg (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧ 
             (∀ y : carrier, y ∈ W → triangle_rest W y m → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply Cardinal_Setminus... rewrite H6... 
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
 
          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ). 
            apply axiom3a. apply (rest_implies_full X). rewrite H12...
            apply (rest_implies_full X). assert (In X maxZ)... apply H7. rewrite H2 in H11... 
          rewrite <- H11 in H7... 
          unfold W, In at 1, Setminus in H7...
          induction H10... 
            left... 
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear x0 H15.
            assert (z = x). 
            apply axiom3a. apply (rest_implies_full X). assert (In Z z)... 
            rewrite <- H2... apply triangle_rest_in_set in H12... 
            apply (rest_implies_full X). apply (tr_trans _ _ y)... 
            rewrite H13 in H7. 
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
          
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z y m → m = y)) as M.
          refine (H (S k) _ _ _ n0 _ )... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          induction H10.  
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ z)...
            apply (tr_trans _ _ y)... 
  Qed.

  Lemma maximal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set n)
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y).
  Proof with intuition.   
    refine (strong_induction _ _ _)...
   
    - apply Cardinality_one_Singleton in H. 
      inversion H; clear H.
      exists x... rewrite H1... 
    
    - assert (Inhabited X).
        apply Cardinal_Sn in H0... 
      inversion H2; clear H2.
   
      set (Z := (fun y => triangle_rest X x y)).

      assert (Z ⊆ X) as SS. 
        unfold Z, Included, In at 1... 
        apply triangle_rest_in_set in H2...

      assert (Finite Z /\ Inhabited Z). 
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0... 
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0... 
        exists x... unfold Z, In at 1... left... 

      assert (exists k, Cardinal Z (S k)) as K. 
        apply Finite_Inhabited_Cardinal_Sn... 
        inversion K as [k L]; clear K... 
    
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L... 
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n). 
          assert (S (S k) <= S (S n))... 
            refine (Cardinal_le Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n... 

        inversion H2; clear H2.
    
        * assert (X == Z). 
            apply (gggg (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧ 
             (∀ y : carrier, y ∈ W → triangle_rest W m y → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply Cardinal_Setminus... rewrite H6... 
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
 
          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ). 
            apply axiom3a. 
            apply (rest_implies_full X). assert (In X maxZ)... apply H7. 
            rewrite H2 in H11...
            apply (rest_implies_full X). rewrite H12... 
          rewrite <- H11 in H7... 
          unfold W, In at 1, Setminus in H7...
          apply triangle_rest_equiv in H10...
          apply triangle_rest_equiv.
          induction H10... 
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear z H15.
            assert (x0 = x). 
            apply axiom3a. apply (rest_implies_full X). assert (In Z x0)... 
            rewrite <- H2... 
            apply triangle_rest_equiv in H12.
            apply triangle_rest_in_set in H12... 
            apply triangle_rest_equiv.
            right with y... 
            apply (rest_implies_full X). 
            assert (In Z x0)... rewrite <- H2. 
            apply triangle_rest_equiv in H12. apply triangle_rest_in_set in H12... 
            rewrite H13 in H7. 
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
          
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z m y → m = y)) as M.
          refine (H (S k) _ _ _ n0 _)... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          apply triangle_rest_equiv in H10.
          apply triangle_rest_equiv.
          induction H10.  
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ x0)...
            apply triangle_rest_equiv...
            right with y...
  Qed.

  Lemma minimal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X -> 
         ∀ n : nat,
         X ⊆ sub Full_set n -> 
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X y m → m = y).
  Proof with intuition.
    intros X H1. 
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn... 
    inversion H; clear H. 
    apply (minimal_exists x)...
  Qed.

  Lemma maximal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X -> 
         ∀ n : nat,
         X ⊆ sub Full_set n -> 
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X m y → m = y).
  Proof with intuition.
    intros X H1. 
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn... 
    inversion H; clear H. 
    apply (maximal_exists x)...
  Qed.

  Lemma PlusMinus_Inhabited : 
    forall X n,
      Included X (sub Full_set (S n)) -> 
      Finite X -> 
      Inhabited X ->
      Inhabited (PlusMinus X).
  Proof with intuition.
    intros...
    assert (Finite (PlusMinus X))...
    apply Finite_Empty_or_Inhabited in H2... 
    exfalso. rename H3 into H2. 
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X m y) -> m = y)).
      refine (maximal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (plus max)). 
      apply plus_Inhabited. apply H in H2. subsuptac... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d). 
    apply H3. 
    unfold PlusMinus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Plus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less max r). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ r)... left...
    rewrite H9 in H7; unfold less in H7... 
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)... 
    idtac... 
  Qed.

  Lemma MinusPlus_Inhabited : 
    forall X n,
      Included X (sub Full_set (S n)) -> 
      Finite X -> 
      Inhabited X ->
      Inhabited (MinusPlus X).
  Proof with intuition.
    intros...
    assert (Finite (MinusPlus X))...
    apply Finite_Empty_or_Inhabited in H2... 
    exfalso. rename H3 into H2. 
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X y m) -> m = y)).
      refine (minimal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (minus max)). 
      apply minus_Inhabited. apply H in H2. subsuptac... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d). 
    apply H3. 
    unfold MinusPlus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Minus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less r max). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ max)... left...
    rewrite H9 in H7; unfold less in H7... 
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)... 
    idtac... 
  Qed.

  Lemma tttt : forall S T, 
    well_formed S -> 
    well_formed T -> 
    Perp S T -> 
    sub (Union S T) 0 == Empty_set -> 
    well_formed (Union S T).
  Proof with intuition.
  intros...
  unfold well_formed in *...
    exfalso; assert (In Empty_set x)... rewrite <- H2... 
    repeat (basic; intuition)... 
      refine (H4 _ _ _ n _ _ _)...
      exfalso; apply H9; unfold perp... 
      assert (Finite (plus x ∩ plus y)). apply Finite_Intersection... apply Finite_Empty_or_Inhabited in H1... 
      assert (Inhabited (Plus S ∩ Plus T)). inversion H12; clear H12... exists x0...
      apply In_Intersection in H1... apply In_Intersection... exists y... exists x... 
      exfalso... inversion H1... rewrite H6 in H13... 
      assert (Finite (minus x ∩ minus y)). apply Finite_Intersection... apply Finite_Empty_or_Inhabited in H1... 
      assert (Inhabited (Minus S ∩ Minus T)). inversion H12; clear H12... exists x0...
      apply In_Intersection in H1... apply In_Intersection... exists y... exists x... 
      exfalso... inversion H1... rewrite H11 in H13...
      exfalso; apply H9; unfold perp... 
      assert (Finite (plus x ∩ plus y)). apply Finite_Intersection... apply Finite_Empty_or_Inhabited in H1... 
      assert (Inhabited (Plus S ∩ Plus T)). inversion H12; clear H12... exists x0...
      apply In_Intersection in H1... apply In_Intersection... exists x... exists y... 
      exfalso... inversion H1... rewrite H6 in H13... 
      assert (Finite (minus x ∩ minus y)). apply Finite_Intersection... apply Finite_Empty_or_Inhabited in H1... 
      assert (Inhabited (Minus S ∩ Minus T)). inversion H12; clear H12... exists x0...
      apply In_Intersection in H1... apply In_Intersection... exists x... exists y... 
      exfalso... inversion H1... rewrite H11 in H13...
      refine (H5 _ _ _ n _ _ _)...
  Qed.

  Lemma triangle_rest_Included : forall S T, Included S T -> forall x y, triangle_rest S x y -> triangle_rest T x y.
  Proof with intuition.
    intros...
    induction H0... 
    left...
    apply (tr_trans _ _ y)...
  Qed.

  Lemma triangle_rest_trans : forall X, forall a b c, triangle_rest X a b -> triangle_rest X b c -> triangle_rest X a c.
  Proof with intuition. 
    intros...
    generalize dependent c. 
    induction H... 
    apply (tr_trans _ x y)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 1                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_1_1 : 
    forall x, 
    (Plus (plus x)) ∩ (Minus (minus x)) == (Empty_set) == (Plus (minus x)) ∩ (Minus (plus x))
    /\
    (MinusPlus (minus x)) == Intersection (Minus (minus x)) (Minus (plus x)) == (MinusPlus (plus x))
    /\
    (PlusMinus (minus x)) == Intersection (Plus (minus x)) (Plus (plus x))   == (PlusMinus (plus x)).
  Proof with repeat basic; auto.
    remember axiom3b as axiom3b. clear Heqaxiom3b.
    assert (H: forall x y, (In (Plus (plus x)) y /\ In (Minus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus, In in H0.  
      unfold Minus, In in H1...
      rename x0 into v. rename x1 into w. 
      assert (less w v).
        unfold less. refine (Inhabited_intro  _ _ u _)... 
      assert (triangle w v). 
        right with v...  left... 
      apply (axiom3b _ _ x) in H4...

    assert (K: forall x y, (In (Minus (plus x)) y /\ In (Plus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus in H2. unfold In in H2. 
      unfold Minus in H1. unfold In in H1...
      rename x0 into v. rename x1 into w. 
      assert (less v w).
        unfold less. refine (Inhabited_intro _ _ u _)... 
      assert (triangle v w). 
        right with w... 
        left... 
      apply (axiom3b _ _ x) in H5...

    intros; split; split.
    apply Disjoint_intersection_condition.
    constructor. unfold not. intros... apply (H x x0)...
    symmetry.
    apply Disjoint_intersection_condition.
    constructor. unfold not. intros... apply (K x x0)...
 
    split; unfold MinusPlus, Same_set, Included... rename x0 into y.
    assert (In (Union (Plus (minus x)) (Minus (plus x))) y).
      rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0... 
    apply In_Complement... apply (K x x0)...

    unfold Same_set, Included...
    apply In_Complement... apply (H x x0)...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0... 

    split; unfold PlusMinus, Same_set, Included...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (H x x0)...
    
    unfold Same_set; unfold Included...
    apply In_Complement... apply (K x x0)...
    assert (In (Union (Plus (minus x)) (Minus (plus x))) x0).
    rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0... 
  Qed.

  Lemma Prop_1_2 :
    forall u v x,
    triangle u v ->
    In (plus x) v ->
    (minus u) ∩ (Plus (minus x)) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included... 
     - unfold Plus in H3. 
       unfold In at 1 in H3... 
       rename x1 into w. 
       assert (less w u). 
         exists x0... 
       assert (triangle w v). 
         unfold triangle. 
         refine (Relation_Operators.rt1n_trans _ _ w u v _ _)... 
       exfalso. 
       apply (axiom3b _ _ x) in H5...
     - inversion H1. 
     - inversion H1.
  Qed.

  Lemma Prop_1_2_dual :
       forall u v x : carrier,
       triangle v u -> v ∈ minus x -> plus u ∩ Minus (plus x) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included... 
     - unfold Minus in H3. 
       unfold In at 1 in H3... 
       rename x1 into w. 
       assert (less u w). 
         exists x0... 
       assert (triangle v w). 
         unfold triangle.
         apply clos_rt_rt1n_iff.
         apply clos_rt_rtn1_iff. 
         refine (Relation_Operators.rtn1_trans _ _ v u w _ _)... 
         apply clos_rt_rtn1_iff. 
         apply clos_rt_rt1n_iff...
       exfalso. 
       apply (axiom3b _ _ x) in H5...
     - inversion H1. 
     - inversion H1.
  Qed.

  Lemma Prop_1_3 : 
    forall R S', Finite R ->
      tight R -> well_formed S' -> R ⊆ S' -> is_a_segment R S'.
  Proof with repeat basic; auto.
    unfold is_a_segment.
    unfold tight.
    unfold well_formed.
    unfold triangle. 
    intros R S' RFin... 
    assert (exists m, (dim x = S m)) as K.
      inversion H4... apply plus_dim in H8. exists (dim x0). auto.  
    rename x into w. rename y into u. rename z into v.
    assert (dim w = dim u) as J. apply equal_dim. unfold triangle. 
      right with u... left... 
    inversion H4 as [y]...
    assert (minus u ∩ PlusMinus R == Empty_set) as L.
      apply (H u v). 
      apply (rest_implies_full S')...
      assumption.  
    assert (~(In (PlusMinus R) y)) as M.
      unfold not; intros... assert (In (Empty_set) y). 
      rewrite <- L... inversion H11. unfold not in M.
    assert (In (Plus R) y) as N.
      unfold Plus. unfold In. exists w...
    assert (In (Minus R) y) as P. 
      assert (y ∈ Minus R \/ ~(y ∈ Minus R)). 
        apply all_decidable...
      inversion H0. assumption. exfalso. apply M.
      unfold PlusMinus...
    inversion P as [z]...
    assert (u = z).
      refine (H3 _ _ _ x _ _ _)...   
      assert (forall T u' v', In T v' -> triangle_rest T u' v' -> In T u') as Q...
        inversion H13... 
      apply (Q _ u v)...
      rewrite <- J. apply H8. 
      apply minus_dim in H12. rewrite <- H12. rewrite <- H8.
      apply plus_dim in H9...
      unfold perp in H0...
      apply Disjoint_intersection_condition in H14. 
      inversion H14. apply (H0 y)...
      rewrite H0...
  Qed.

  Lemma xplus_is_tight :
    forall x, tight (plus x).
  Proof with repeat basic; auto.
    unfold tight; intros.
    assert (Intersection (minus u) (Plus (minus x)) == Empty_set) as A. 
      apply (Prop_1_2 u v)...
    assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as B. 
      apply (Prop_1_1 x). 
    rewrite <- B. 
    rewrite <- Intersection_trans. 
    rewrite A.
    unfold Same_set, Included; split; intros... inversion H1. 
  Qed.

  (* Section 2 *)
  
  Lemma Observation_p322 :
    forall (T Z : Ensemble carrier),
    well_formed (Union T Z) ->
    Disjoint T Z ->
    Perp T Z. 
  Proof with repeat basic; auto.
    intros T Z WF Disj. remember (Union T Z) as S'.
    unfold well_formed in WF... 
    rename H into WF0.
    rename H0 into WFSn. 
    rename H1 into Disj.
    unfold Perp...

    apply Disjoint_intersection_condition. constructor. unfold not in *. 
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Plus in PT. unfold In in PT.
    unfold Plus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (x0 = x1). 
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left... 
    apply H. assumption. 
    unfold perp. intros...
    apply Disjoint_intersection_condition in H6. 
    inversion H6 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
 
    apply Disjoint_intersection_condition. constructor. unfold not in *. 
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Minus in PT. unfold In in PT.
    unfold Minus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (x0 = x1). 
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left... 
    apply H. assumption. 
    unfold perp. intros...
    apply Disjoint_intersection_condition in H7. 
    inversion H7 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Cells                                                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Definition Same_pair (A B: Ensemble carrier * Ensemble carrier) : Prop.
  inversion A as [M  P ].
  inversion B as [M' P'].
  exact (M == M' /\ P == P').
  Defined.

  Hint Unfold Same_pair.

  Notation " F === G" := (Same_pair F G) (at level 89).

  Definition is_a_cell (G : Ensemble carrier * Ensemble carrier) : Prop.
  inversion G as [M P]. 
  exact ( Inhabited M  /\ Inhabited P /\
    well_formed M /\ well_formed P /\
    Finite M /\ Finite P /\
    (M moves M to P) /\ (P moves M to P)).
  Defined.

  Definition celldim (G : Ensemble carrier * Ensemble carrier) (n : nat) : Prop.
    inversion G as [M P]. 
    exact (setdim (Union M P) n).
  Defined.

  Definition source (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sup M n , sub M n ∪ sup P (n-1)).
  Defined.

  Definition target (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sub P n ∪ sup M (n-1) , sup P n ).
  Defined.

  Definition composable (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Prop :=
    target n A === source n B. 

  Definition composite (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
   inversion A as [M P].
   inversion B as [N Q].
   exact ((M ∪ (N ∩ √(sub N n))), ((P ∩ √(sub P n)) ∪ Q)).
  Defined.

  Definition receptive (S : Ensemble carrier) : Prop :=
    (forall x, (Plus (minus x)) ∩ (Plus (plus x)) ⊆ S ->
       (Inhabited (S ∩ (Minus (minus x))) -> False) ->
       (Inhabited (S ∩ (Minus (plus x))) -> False))  /\ 
    (forall x, (Minus (plus x)) ∩ (Minus (minus x)) ⊆ S ->
       (Inhabited (S ∩ (Plus (plus x))) -> False) ->
       (Inhabited (S ∩ (Plus (minus x))) -> False)).

  Definition cell_receptive (G : Ensemble carrier * Ensemble carrier) : Prop.
    inversion G as [M P].
    exact (receptive M /\ receptive P).
  Qed.

  Hint Unfold is_a_cell.

  Lemma Same_set_is_a_cell : forall S T, 
    is_a_cell (S, T) -> forall S' , S == S' -> forall T', T == T' -> is_a_cell (S', T').
  Admitted. 


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma cell_has_dim : forall M P, is_a_cell (M, P) -> exists m, celldim (M, P) m.
  Proof with repeat basic; auto.
    intros.
    unfold is_a_cell in H...
    assert (Finite (Union M P)). 
    apply Finite_Union.
    apply all_decidable... 
    assumption.
    assumption. 
    apply Finite_carrier_have_max_dim_element in H6.
    inversion H6 as [m]; clear H6... 
    exists (dim m).
    unfold celldim. 
    unfold setdim.
    intros...
    inversion H8; apply H9...
    inversion H0. 
    apply (Inhabited_intro _ _ x). 
    left...
  Qed.

  Lemma target_dim : forall M P, is_a_cell (M, P) -> forall m, 
    celldim (target m (M, P)) m.
  Proof with intuition.
    intros...
    unfold target, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1... 
    apply (le_trans _ (m-1))... 
  Qed.

  Lemma source_dim : forall M P, is_a_cell (M, P) -> forall m, 
    celldim (source m (M, P)) m.
  Proof with intuition.
    intros...
    unfold source, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (m-1))...
  Qed.

 Lemma cell_dim_n_property : 
    forall M P, is_a_cell (M, P) -> forall n, celldim (M, P) n -> sub M n == sub P n.
  Proof with intuition.
    intros M P K n J.
    unfold is_a_cell in K... unfold moves_def in *...
    unfold sub, Same_set, Included, In...

    fold (In P x). rewrite H6.
    repeat basic. left... apply In_Complement. unfold not... 
    unfold In, Minus in H7. inversion H7; clear H7... apply minus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...

    fold (In M x). rewrite H9.
    repeat basic. left... apply In_Complement. unfold not... 
    unfold In, Plus in H7. inversion H7; clear H7... apply plus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...
  Qed.     

  Lemma M_n_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        Inhabited (sub M (S n)) ->
        Inhabited (sub M (  n)).
  Proof with intuition. 
    intros...

    assert (exists m, In (sub M (S n)) m /\ (forall y, In (sub M (S n)) y -> (triangle_rest (sub M (S n)) y m) -> (m = y))).
      refine (minimal_exists' _ _ (S n) _)...
      refine (Finite_sub M _ (S n)). apply H.
      unfold sub, Included... unfold In at 1. unfold In at 1 in H1...
    inversion H1 as [w J]; clear H1...
    assert ( MinusPlus (sub M (S n)) ⊆ sub M n). 
      assert (MinusPlus M ⊆ M). 
        unfold is_a_cell in H...
        apply Prop_2_1... exists P... 
      unfold MinusPlus, Plus, Minus, sub, Included... 
      apply In_Intersection in H4...
      unfold In at 1 in H5. unfold Complement, not, In at 1 in H6.
      unfold In at 1...
      apply H3. unfold MinusPlus...
      apply In_Intersection...
      inversion H5 as [p Q]; clear H5.
      exists p... unfold In in H4...
      apply In_Complement... apply H6.
      unfold In at 1. unfold Plus, In at 1 in H4. inversion H4 as [t T].
      exists t...
      unfold In at 1...
      apply plus_dim in H8.
      inversion H5 as [y Y]; clear H4...
      unfold In at 1 in H4...
      apply minus_dim in H9. rewrite <- H8, H9...
      inversion H5 as [y Y]; clear H5...
      unfold In at 1 in H4...
    assert (Finite (sub M n)). 
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso. 
    assert (MinusPlus (sub M (S n)) == Empty_set). 
      apply (Included_Empty_set _ (sub M n))...
    assert (forall x, In (Minus (sub M (S n))) x -> (In (Plus (sub M (S n)))) x)...
      assert (x ∈ Plus (sub M (S n)) \/ ~(x ∈ Plus (sub M (S n))))... 
        apply all_decidable... 
        apply Finite_Plus. apply Finite_sub... apply H.
      exfalso. 
      assert (In (MinusPlus (sub M (S n))) x); unfold MinusPlus...
      rewrite H4 in H7. inversion H7...
    assert (Inhabited (minus w))... 
      apply minus_Inhabited. assert (dim w = (S n))... apply H1. rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Plus (sub M (S n))). 
      apply H6... exists w...
    unfold Plus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less z w). 
      unfold less. exists p... 
    assert (w = z). 
      apply H2... apply (tr_trans _ _ w)... left...
    subst. unfold less in H9...
  Qed.

  Lemma M_n_Empty_set : 
    forall M P, 
      is_a_cell (M, P) -> 
      forall n, 
        sub M (  n) == Empty_set ->
        sub M (S n) == Empty_set.
  Proof with intuition. 
    intros...
    assert (Finite (sub M (S n))).
      unfold is_a_cell in H... 
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (M_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma M_0_not_empty : 
    forall M P, 
      is_a_cell (M, P) -> 
       ((sub M 0) == Empty_set) -> False.
  Proof with intuition. 
    unfold not... 
    assert ( forall n, ((sub M n) == Empty_set))...
      induction n...
      apply (M_n_Empty_set M P)... 
    unfold is_a_cell in H...
    inversion H2 as [z W]...
    assert (Inhabited (sub M (dim z)))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma M_0_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      exists z, (sub M 0) == Singleton z.
  Proof with intuition. 
    intros.
    assert (Inhabited (sub M 0)).
      assert (Finite (sub M 0)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (M_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H2...
        apply H0. apply J. 
      rewrite H1... 
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma P_0_Inhabited : 
    forall M P, 
      is_a_cell (M, P) -> 
      exists z, (sub P 0) == Singleton z.
  Proof with intuition. 
  Admitted.

  Lemma M_0_Inhabited' : 
    forall M P, 
      is_a_cell (M, P) -> Inhabited (sub M 0).
  Proof with intuition. 
    intros.
    assert (Finite (sub M 0))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso. 
    apply (M_0_not_empty M P)...
  Qed.

  Lemma source_is_a_cell : forall (m : nat) (M P : Ensemble carrier), 
    is_a_cell (M, P) -> 
    celldim (M, P) (S m) -> 
    forall n, 
      n <= m -> 
      is_a_cell (source n (M, P)).
  Proof with intuition.
    intros m M P MPcell MPdim n nltm.
    unfold source.
    
    destruct n.
    apply (Same_set_is_a_cell (sub M 0) (sub M 0))... 
      apply M_0_Inhabited in MPcell. 
      inversion MPcell; clear MPcell. 
    apply (Same_set_is_a_cell (Singleton x) (Singleton x))... 
    assert (dim x = 0) as dimx.
      assert (In (sub M 0) x)... rewrite H...
    unfold is_a_cell... 
      exists x...
      exists x...
 
      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right. 
      rewrite Complement_Empty_set. 
      rewrite Full_set_ident_right...

    assert (sup P (0 - 1) == Empty_set) as AA. admit. (* fix later *)
    rewrite AA. 
    rewrite Empty_set_ident_right...

    rewrite Sn_minus_1. 
    unfold is_a_cell in *...

    assert (Inhabited (sub M 0)). 
      assert (exists z, (sub M 0) == Singleton z). apply (M_0_Inhabited M P). unfold is_a_cell... 
      inversion H6; clear H6. exists x... rewrite H8... 
    inversion H6. exists x... repeat subsuptac... rewrite H10...

    assert (Inhabited (sub P 0)). 
      assert (exists z, (sub P 0) == Singleton z). 
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8... 
    inversion H6. exists x... right. repeat subsuptac... rewrite H10...

    unfold well_formed in *...
      apply H6... 
      repeat subsuptac...
      repeat subsuptac...
      refine (H8 _ _ _ n0 _ _ _)... 
      repeat subsuptac...
      repeat subsuptac...
      
    unfold well_formed in *...
      inversion H12; clear H12... 
      inversion H13; clear H13; subst...
      apply H6... 
      repeat subsuptac...
      repeat subsuptac...
      repeat subsuptac... rewrite H10 in H14; inversion H14.
      inversion H13; clear H13; subst...
      repeat subsuptac... rewrite H11 in H15; inversion H15.
      apply H0... 
      repeat subsuptac...
      repeat subsuptac...
      inversion H10; clear H10... 
      inversion H11; clear H11; subst...
      refine (H8 _ _ _ n0  _ _ _)... 
      repeat subsuptac...
      repeat subsuptac...
      repeat subsuptac...
      rewrite H2 in H15; inversion H15; subst.
      rewrite H12 in H16. apply le_Sn_n in H16...
      inversion H11; clear H11; subst...
      repeat subsuptac...
      rewrite H12 in H16; inversion H16; subst.
      rewrite H2  in H15. apply le_Sn_n in H15...
      refine (H9 _ _ _ n0  _ _ _)... 
      repeat subsuptac...
      repeat subsuptac...

    (**) apply Finite_Union...

    (**) 
    unfold moves_def in *...
    rewrite <- (sup_Plus M (n)).
    rewrite <- (sup_Minus M (n)).
    unfold Same_set, Included. repeat (basic; intuition).
      left. apply (sub_sup_Included M (S n))...
      rewrite H6 in H10. unfold sup, In at 1 in H10...
      repeat (basic; intuition). 
      left. subsuptac...
      apply In_Complement... repeat (subsuptac; intuition). rewrite H12 in H13... 
      apply In_Complement...
      rewrite H6 in H10. unfold sup, In at 1 in H10...
      apply In_Intersection in H11... 
      unfold sup, In at 1 in H7...
      unfold sup, In at 1 in H7...
      inversion H12; clear H12... clear H7 m0.
      right. rewrite H6... subsuptac... repeat (basic; intuition). apply In_Complement...
      right. assert (Included (PlusMinus M) P). apply Prop_2_1_dual... exists M...
      unfold sup, In at 1... apply H10. unfold PlusMinus... basic... apply H7. 
      apply In_Complement... 
    rewrite <- (sup_Plus M (n)).
    rewrite <- (sup_Minus M (n)).
    unfold Same_set, Included. repeat (basic; intuition).
      unfold sup, In at 1 in H7... 
      inversion H11; clear H11... 
      left. left. unfold sup, In at 1...
      clear H7 m0. 
      rewrite H8 in H10... 
      rewrite (Union_trans). right. rewrite <- sup_Union. 
      unfold sup, In at 1... apply In_Intersection in H10...
      apply In_Complement... rewrite H8 in H7... rewrite (sup_Intersection) in H7. 
      basic... unfold sup, In at 1 in H10...
      unfold sup, In at 1 in H12...
      apply (sub_sup_Included M (S n))...
      rewrite H8. unfold sup, In at 1...
      basic... left. apply (sup_Included P n)... 
      apply In_Complement...
      assert (Included (MinusPlus M) M). apply Prop_2_1... exists P...
      unfold sup, In at 1...  apply H10... unfold MinusPlus... 
      basic...  apply H7. apply In_Complement...

    (**) 
    unfold moves_def in *...
    rewrite Plus_Union_compat, Minus_Union_compat.
    rewrite <- Union_Complement_compat.
    unfold Same_set, Included. repeat (basic; intuition).
      left. apply (sub_sup_Included M (S n))...
      unfold sup, In at 1 in H10...
      inversion H11; clear H11...  
      rewrite H6 in H7; repeat (basic; intuition). right; left... rewrite <- sub_Plus... 
      rewrite H5 in H7; repeat (basic; intuition). left... unfold sup, In at 1... 
      right; right... unfold Plus, In at 1 in H7... inversion H7; clear H7... exists x0... 
      unfold sup, In at 1...  assert (S (dim x) = dim x0)...  rewrite <- H11... 
      apply In_Complement... assert (dim x = S n)... assert (dim x = n)...
      apply (Minus_dim (sub M (S n)) Full_set)... rewrite H12 in H11... 
      unfold sup, In at 1 in H10... 
      rewrite H6 in H7... rewrite <- sub_Minus... apply In_Intersection in H7...
      apply In_Complement...      apply H12...  apply H7...
      apply In_Complement... assert (dim x = S n)... 
      unfold Minus, In at 1 in H7... inversion H7; clear H7... assert (dim x0 <= n)... 
      assert (S (dim x) = dim x0)... rewrite <- H14, H11 in H12... apply (le_SSn_n n)...
      unfold sup, In at 1 in H10... rewrite H5 in H7... apply In_Intersection in H7... 
      apply In_Complement... apply H12... unfold Minus, In at 1 in H7... 
      inversion H7; clear H7... exists x0... apply H7... 
      unfold sup, In at 1 in H11... 
      inversion H13; clear H13... 
      inversion H14; clear H14... rewrite H8 in H10; repeat (basic; intuition)... exfalso. apply H7...
      rewrite <- sub_Minus... subst. rewrite H9 in H10; repeat (basic; intuition)... right... 
      exfalso. apply H12... rewrite <- sup_Minus...
      right... unfold sup, In at 1... apply (Prop_2_1_dual M P)... exists M...
      unfold PlusMinus. basic... apply (Plus_Included (sub M (S n)))... apply In_Complement... apply H7...
      rewrite <- sub_Minus... subsuptac... rewrite <- sub_Plus in H10... rewrite <- sub_Plus in H10...  assert (dim x = n)...
      rewrite H11...  
      right... unfold sup, In at 1... apply (Prop_2_1_dual P P)... exists M...
      unfold PlusMinus. basic... apply (Plus_Included (sup P (n)))... apply In_Complement... apply H12...
      unfold Minus, In at 1...  unfold Minus, In at 1 in H11... inversion H11; clear H11... 
      exists x0... assert (S (dim x) = dim x0)... subsuptac... rewrite <- H13... 
      unfold Plus, In at 1 in H10...  inversion H10...  assert (dim x1 <= n)...
      assert (S (dim x) = dim x1)... rewrite H18... 
      apply (le_trans _ (S (dim x)))... 
      apply (Plus_dim' (sup P n))...
    rewrite Plus_Union_compat, Minus_Union_compat.
    rewrite <- Union_Complement_compat.
    unfold Same_set, Included. repeat (basic; intuition).
      unfold sup, In at 1 in H7...
      inversion H11; clear H11... left; left...
      inversion H12; clear H12...  
      rewrite H8 in H10; repeat (basic; intuition). left;right... right; left...
      rewrite <- sub_Minus...
      rewrite H9 in H10; repeat (basic; intuition). left;right... right;right... 
      rewrite <- sup_Minus...
      apply In_Complement... rewrite <- sub_Plus in H10... repeat (subsuptac)...
      rewrite H8 in H11; repeat (basic; intuition)...
      apply In_Complement... unfold sup, In at 1 in H7... 
      rewrite H9 in H11. apply In_Intersection in H11... apply H13... apply (Plus_Included (sup P n))...
      repeat (subsuptac)... rewrite H13... 
      unfold sup, In at 1 in H10... unfold sup, In at 1...
      inversion H13; clear H13... rewrite H6 in H11; repeat (basic; intuition)... exfalso.
      apply H7... rewrite <- sub_Plus... 
      rewrite H5 in H11; repeat (basic; intuition)... exfalso.
      apply H12... unfold Plus, In at 1 in H11. inversion H11; clear H11... exists x0... subsuptac... 
      assert (S (dim x) = dim x0)... rewrite <- H13, <- H14...
      rewrite <- sub_Minus  in H10... 
      repeat (subsuptac)... assert (Included (MinusPlus M) M). 
      apply (Prop_2_1 M M)... exists P...  apply H10... unfold MinusPlus; repeat (basic; intuition)... 
      apply In_Complement...  apply H7... rewrite <- sub_Plus... rewrite H13... 
      assert (S (dim x) <= n). apply (Minus_dim' (sup P n))... 
      repeat (subsuptac)... assert (Included (MinusPlus P) M). 
      apply (Prop_2_1 P M)... exists P...  apply H13... unfold MinusPlus; repeat (basic; intuition)... 
      unfold Minus, In at 1 in H10. inversion H10; clear H10... exists x0... apply H10... 
      apply In_Complement...  apply H12... 
      unfold Plus, In at 1 in H14. inversion H14; clear H14... exists x0... subsuptac... 
      assert (S (dim x) = dim x0)... rewrite <- H15...
  Qed.

  Lemma target_is_a_cell : forall (n : nat) (M P : Ensemble carrier), 
    is_a_cell (M, P) -> is_a_cell (target n (M, P)).
  Admitted.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 3                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_3_1 :
    forall x M P, 
      (plus x) moves M to P ->
      receptive M ->
      (minus x) moves M to P.
  Proof with intuition. 
    intros. 
    assert (exists P', plus x moves M to P'). 
      exists P... 
    apply Prop_2_1 in H1...
    assert (MinusPlus (minus x) == MinusPlus (plus x)).
      remember (Prop_1_1 x) as prop_1_1. 
      apply (Same_set_trans _ (Minus (minus x) ∩ Minus (plus x))). apply prop_1_1. apply prop_1_1. 
    assert (MinusPlus (minus x) ⊆ M). unfold Included...
    assert (Disjoint M (Plus(minus x))). 
      unfold receptive in H0... constructor... 
      apply (H6 x). 
      Focus 3. apply (Inhabited_intro _ _ x0)...
      Focus 2. intros... inversion H7; clear H7... 
      unfold moves_def in H... rewrite H9 in H8...
        rewrite Intersection_trans in H8. repeat basic...
      unfold moves_def in H... unfold Included...
        assert ((In (Plus (plus x)) x1) \/ ~(In (Plus (plus x)) x1))... apply all_decidable... 
        pose (Prop_1_1 x)... exfalso. assert (In (Empty_set) x1). rewrite <- H12...
        apply In_Intersection... apply In_Intersection in H... inversion H14.
        rewrite H8... apply In_Intersection... right... apply In_Intersection in H...
    assert (exists Y, minus x moves M to Y). 
      apply Prop_2_1... 
    inversion H6 as [P']; clear H6.
    assert (P == P'). 
      unfold moves_def in H7... 
      rewrite H6. 
      symmetry. 
      rewrite I_U_dist_r. 
      pose (Prop_1_1 x)... 
      unfold PlusMinus in H7. rewrite H7. 
      unfold moves_def in H... 
      rewrite H12.
      rewrite I_U_dist_r.
      assert ((Plus (plus x) ∩ √Minus (plus x)) == (Plus (minus x) ∩ Plus (plus x))).        
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... assert (In (Empty_set) x0)... rewrite H11. apply In_Intersection...
      assert ((M ∩ √Minus (plus x)) == (M ∩ √Minus (plus x) ∩ √Plus (minus x))). 
        unfold Same_set; unfold Included; repeat (basic; intuition).
          apply In_Complement... apply (H17 x0)...
      assert ((M ∩ √Minus (minus x)) == (M ∩ √Minus (minus x) ∩ √Plus (plus x))). 
        unfold Same_set; unfold Included; repeat (basic; intuition). 
        apply In_Complement... apply (H5 x0). apply In_Intersection... 
      rewrite H, H16, H17. 
      repeat rewrite (Intersection_trans M _ _). 
      repeat rewrite Union_Complement_compat.
      rewrite (Union_sym (Minus (minus x)) _). 
      rewrite (axiom1 x).
      rewrite (Union_sym _ (Minus (plus x)))...
      
    unfold moves_def in *... 
      rewrite H6... 
      rewrite H6... 
  Qed.

  Definition is_a_cell' (S T : Ensemble carrier) := is_a_cell (S, T). 

  Hint Unfold is_a_cell'.

  Add Parametric Morphism : (is_a_cell') with 
    signature (@Same_set carrier) ==> (@Same_set carrier) ==> (iff) as is_a_cell_Same_set.
  Proof with intuition.
    intuition. 
    symmetry in H.
    symmetry in H0.
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H... 
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H). 
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
 
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H... 
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H). 
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
  Qed.

  Lemma is_a_cell_Same_set_compat : forall (S S': Ensemble carrier), 
    S == S' -> forall T T', T == T' -> (is_a_cell (S, T) <-> is_a_cell (S', T')).
  Proof.
    intros.
    fold (is_a_cell' S T).
    fold (is_a_cell' S' T').
    rewrite H, H0.
    intuition. 
  Qed.

  Lemma Prop_3_3 : (forall M P : Ensemble carrier, is_a_cell (M, P) -> cell_receptive (M, P)).
  Proof with intuition.
    unfold is_a_cell...
    assert (receptive M /\ receptive P).
    split.

    unfold receptive... 
    remember (dim x) as n.
    destruct n.
    
    (* n = 0 *) 
    assert (Minus (minus x) == Empty_set /\ Minus (plus x) == Empty_set).
    split; unfold Minus, Same_set, Included, In...  
    inversion H10... apply minus_dim in H12. rewrite <- Heqn in H12. inversion H12.
    inversion H10... apply plus_dim in H12. rewrite <- Heqn in H12. inversion H12.
    apply H8... 
    rewrite H11.
    rewrite H12 in H9...
    
    induction n.
    (* n = 1 *)
    assert (Minus (minus x) == Empty_set /\ Minus (plus x) == Empty_set).
    split; apply dim_1_properties; symmetry... 
    apply H8... 
    rewrite H11.
    rewrite H12 in H9...

    (* n > 1 *)
    
  Admitted.
  
  Lemma maximal_property :
    forall X, Finite X -> Inhabited X -> forall n, Included X (sub Full_set n) 
      -> exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    intros X hyp1 hyp2 n hyp3.
    assert (exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y)) as hyp4.
      refine (maximal_exists' _ _ n _)...
    inversion hyp4 as [m]; clear hyp4...
    exists m...
    apply Disjoint_intersection_condition. 
    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H...
      unfold Minus, In at 1 in H3...
      inversion H3 as [z]; clear H3...
      assert (less m z). unfold less. exists x... 
      assert (m = z). apply H1... apply (tr_trans _ _ z)... left... 
      rewrite H5 in H; unfold less in H... pose (plus_minus_Disjoint z)...
      inversion d... inversion H. apply (H6 x0)...
    inversion H.
  Qed.
 
  Definition Lemma_3_2_b_st : nat -> nat -> Prop := 
    (fun n => (fun m => 
    forall (X : Ensemble carrier), 
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S n))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M n))) ->
    is_a_cell ( (sup M (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)), (sup P (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)) )
    /\ (Minus X ∩ (sub M n)) == Empty_set))).

  Definition Lemma_3_2_c_st : nat -> nat -> Prop := 
    (fun n => (fun m => 
    forall (X : Ensemble carrier), 
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S n))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M n))) ->
    is_a_cell ( (sup M (n - 1)) ∪ (((sub M n) ∪ Minus X) ∩ √(Plus X)) ∪ X, P ∪ X)
    ))).

  Lemma Lemma_3_2_b_n_0 : forall n, Lemma_3_2_b_st n 0.
  Proof with intuition.
    intros n.
    unfold Lemma_3_2_b_st.
    intros X Xcard. 
    assert (X == Empty_set) as XEmpty. 
      apply Cardinality_zero_Empty_set; assumption.
    assert (Finite X) as XFinite.
      apply (Cardinal_are_Finite 0)...
    intros M P H. 
    inversion H as [MPcell MPdim]; clear H. 
    intros H.
    inversion H as [Xdim K]; clear H. 
    inversion K as [Xwf Xcond]; clear K. 
    split. 

    (* is_a_cell *)
    assert (Minus X == Empty_set) as MXE. 
      rewrite XEmpty.
      unfold Minus, Same_set, Included, In... inversion H...
    assert (Plus X == Empty_set) as PXE. 
      rewrite XEmpty.
      unfold Plus, Same_set, Included, In... inversion H...
    assert (sup M (n - 1) ∪ ((sub M (n) ∪ Minus X) ∩ √Plus X) == M) as MM. 
      rewrite MXE, PXE. 
      rewrite Complement_Empty_set. 
      rewrite Empty_set_ident_right. 
      rewrite Full_set_ident_right.
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush. 
        assert (dim x <= (n)).
          unfold celldim in *...
        inversion H0; [right | left]... 
          basic... rewrite Sn_minus_1...
    assert (sup P (n - 1) ∪ ((sub M (n) ∪ Minus X) ∩ √Plus X) == P) as PP.
      rewrite MXE, PXE. 
      rewrite Complement_Empty_set. 
      rewrite Empty_set_ident_right. 
      rewrite Full_set_ident_right.
      rewrite (cell_dim_n_property M P).
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= (n)).
          unfold celldim in *...
        inversion H0; [right | left]... 
          basic... rewrite Sn_minus_1...
    assumption. 
    assumption. 
    symmetry in MM; symmetry in PP.
    apply (is_a_cell_Same_set_compat M _ MM P _ PP)... 

    (* Disjoint *)
    apply Disjoint_intersection_condition.
    constructor. 
    unfold not; intros. 
    basic...
    unfold In, Minus in H0...
    inversion H0 as [z J]...
    assert (In Empty_set z). rewrite <- XEmpty... 
    inversion H3.
  Qed.

  Lemma Lemma_3_2_b_0_1 : Lemma_3_2_b_st 0 1.
  Proof with intuition.
    unfold Lemma_3_2_b_st.
    intros X Xcard M P J K.
    inversion J as [MPcell MPdim]; clear J.
    inversion K as [Xdim L]; clear K.
    inversion L as [Xwf Xcond]; clear L.
    apply Cardinality_one_Singleton in Xcard. 
    inversion Xcard as [x Xsing]; clear Xcard.
    set (Y := ((sub M 0 ∪ Minus X) ∩ √Plus X)).
    
    assert (dim x = 1) as dimx. 
      rewrite Xsing in Xdim.
      autounfold with * in Xdim... apply Xdim... 
    assert (sub M 0 == plus x) as subM0. 
      assert (exists d, sub M 0 == Singleton d).
      apply dim_0_Singleton. 
      apply (M_0_Inhabited' M P)...
      apply MPcell. inversion H as [f L]; clear H.
      assert (plus x == Singleton f). apply Included_Singleton.
      apply plus_Inhabited. rewrite dimx...
      rewrite <- L.
      assert (PlusMinus X == plus x). 
      unfold PlusMinus. rewrite Xsing.
      assert (Plus (Singleton x) ∩ √Minus (Singleton x) == PlusMinus (Singleton x)).
      unfold PlusMinus...
      rewrite H.
      rewrite PlusMinus_Singleton...
      rewrite <- H... rewrite <- H in L...
    assert (Y == minus x) as Ydef. 
      unfold Y. 
      rewrite Xsing, subM0, Plus_Singleton, Minus_Singleton.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_left.
      apply Intersection_Included_left.
      apply Disjoint_property_right.
      apply plus_minus_Disjoint.
    assert (sup M (0 - 1) == Empty_set) as supM0. admit. (* this is really a coding issue *)
    assert (sup P (0 - 1) == Empty_set) as supP0. admit. (* this is really a coding issue *)
    assert (sup M (0 - 1) ∪ Y == minus x) as HypA.
      unfold is_a_cell in MPcell...
      rewrite supM0, Ydef. 
      rewrite Empty_set_ident_left.
      reflexivity.
    assert (sup P (0 - 1) ∪ Y == minus x) as HypB.
      unfold is_a_cell in MPcell...
      rewrite supP0, Ydef. 
      rewrite Empty_set_ident_left.
      reflexivity.

    split.

    apply (is_a_cell_Same_set_compat _ _ HypA _ _ HypB).
    unfold is_a_cell... 
        apply minus_Inhabited. rewrite dimx. auto.
        apply minus_Inhabited. rewrite dimx. auto. 
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.

      rewrite Xsing, Minus_Singleton, subM0.
      apply Disjoint_intersection_condition.
      apply Disjoint_sym. apply plus_minus_Disjoint.
  Qed.

  Lemma ddd : forall X Y n k,
   Included X (sub Full_set n) ->
   Included Y (sup Full_set k) ->
    ~(n <= k) -> (forall y, In X y /\ In Y y -> False).
  Proof with intuition.
    intros...
    assert (dim y = n)...
    assert (dim y <= k)... apply H0...
    rewrite H2 in H5...
  Qed.

  Lemma Lemma_3_2_Step_1' :
    forall n m, (Lemma_3_2_b_st n m) -> (Lemma_3_2_c_st n m).
  Proof with intuition.
    unfold Lemma_3_2_b_st, Lemma_3_2_c_st. 
    intros n m Hyp1 X Xcard M P J K. 
    assert (Finite X) as XFin. apply (Cardinal_are_Finite m)...
    set (Y := ((sub M n ∪ Minus X) ∩ √Plus X))...
    assert (is_a_cell
               (sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X),
                sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X))
             ∧ Minus X ∩ sub M n == Empty_set) as Hyp2.
    apply Hyp1...
    intuition. 
    unfold is_a_cell in *... 
    
    apply (Inhabited_Included (sup M (n - 1) ∪ Y)). assumption. 
    apply Union_Included_cancel_right. reflexivity.

    apply (Inhabited_Included (P)). assumption. 
    apply Union_Included_cancel_right. reflexivity.
      
    (* This whole argument is predicated on the fact that both parts of the union are
       well-formed and that the intersection is (dimenion-wise) empty *)
    unfold well_formed in *...
    apply In_Union in H28... 
    apply In_Union in H29... 
      exfalso. assert (dim y = S n)...
      rewrite H27 in H29. inversion H29.
    apply In_Union in H29... 
      exfalso. assert (dim x = S n)...
      rewrite H26 in H29. inversion H29.
    apply In_Union in H26...
    apply In_Union in H27...
      refine (H23 _ _ _ n0 _ _ _)... 
      exfalso. 
      assert (dim y = S n)...
      apply In_Union in H30...
        assert (dim x <= n). apply (le_trans _ (n-1))...    
        rewrite H11, <- H28, H27 in H30...
        assert (dim x = n). unfold Y in H31. 
        apply In_Intersection in H31... 
        apply In_Union in H30... 
        inversion H31... assert (dim x0 = S n)... 
        rewrite H11, <- H28, H27 in H30...
    apply In_Union in H27...
      exfalso. 
      assert (dim x = S n)... 
      apply In_Union in H26...
        assert (dim y <= n). apply (le_trans _ (n-1))...    
        rewrite H28, <- H11, H27 in H26...
        assert (dim y = n). unfold Y in H31. 
        apply In_Intersection in H31... 
        apply In_Union in H26... 
        inversion H31... assert (dim x0 = S n)...
        rewrite H28, <- H11, H27 in H26...
        refine (H21 _ _ _ n0 _ _ _)... 

    (* as above *)
    unfold well_formed in *...
    apply In_Union in H28... 
    apply In_Union in H29...
      assert (dim y = S n)... 
      rewrite H27 in H29. inversion H29.
    apply In_Union in H29...
      assert (dim x = S n)... 
      rewrite H26 in H29. inversion H29.
    apply In_Union in H26... 
    apply In_Union in H27...
      refine (H24 _ _ _ n0 _ _ _)... 
      exfalso. 
      assert (dim y = S n)... 
      assert (dim x <= n)... assert (dim x = S n)... rewrite H11, <- H28...
      rewrite H32 in H31...
    apply In_Union in H27...
      exfalso. assert (dim y <= n)... assert (dim x = S n). intuition. 
      assert (dim y = S n). rewrite H28, <- H11, H31... rewrite H32 in H27; apply (le_Sn_n n)...
      refine (H21 _ _ _ n0 _ _ _)...
      
    apply Finite_Union... 
    apply Finite_Union...

    unfold Y. 
    assert ((sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((M ∪ Minus X) ∩ √Plus X))) as JA. admit. (* don't fix these until n-1 *)
    assert ((sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((P ∪ Minus X) ∩ √Plus X))) as JB. admit. (* is dealt with             *)
    rewrite JA, JB in *.
    unfold moves_def in *...
    rewrite (Plus_Union_compat _ X).
    rewrite (Minus_Union_compat _ X).
    rewrite <- (Union_Complement_compat _ (Minus X)). 
    rewrite Union_trans. rewrite (Union_sym X _). 
    rewrite (Union_trans _ _ X).
    rewrite <- (Union_trans _ _ (Plus X ∪ X)).
    rewrite <- Intersection_trans.
    rewrite I_U_dist_r. 
    rewrite <- H19.
    unfold Same_set, Included; repeat (basic; intuition).  
      assert ((In (Plus X) x) \/ ~(In (Plus X) x))... apply all_decidable... 
      right. repeat (basic; intuition). apply In_Complement... 
        assert (dim x = n)... apply (Plus_dim X)... 
        unfold Minus, In at 1 in H20... inversion H20; clear H20... 
        repeat (basic; intuition). assert (dim x0 <= n)...
        assert (S (dim x) = dim x0)... rewrite <- H31, H27 in H28...
        assert (S (dim x0) = dim x1)... assert (dim x1 = (S n))...
        assert (S (dim x) = dim x0)... 
        rewrite H27 in H33. rewrite H32, H33 in H28... 
      right. apply In_Intersection... apply In_Complement... 
        assert (dim x = S n)...  
        unfold Minus, In at 1 in H20... inversion H20; clear H20... 
        repeat (basic; intuition). assert (dim x0 <= n)...
        assert (S (dim x) = dim x0)... rewrite <- H30, H26 in H27... apply le_SSn_n in H27...
        assert (S (dim x0) = dim x1)... assert (dim x1 = (S n))...
        assert (S (dim x) = dim x0)... 
        rewrite H26 in H32. rewrite <- H31, <- H27 in H32... apply SSn_n in H32... 
      apply In_Complement... assert (In (sub M n) x)... 
        rewrite (cell_dim_n_property M P)... unfold sub, In at 1...
        apply (Minus_dim X Full_set)... unfold is_a_cell... 
        assert (In Empty_set x)... rewrite <- H5. apply In_Intersection... 
      apply In_Complement... 
        assert (dim x = S n)... assert ( dim x = n)... apply (Minus_dim X Full_set)... rewrite H27 in H26...
      left. assert (In (sub M n) x)... apply H4... unfold PlusMinus; basic... 
        rewrite (cell_dim_n_property M P) in H25... apply H25... unfold is_a_cell... 

    rewrite (Plus_Union_compat _ X).
    rewrite (Minus_Union_compat _ X).
    rewrite <- (Union_Complement_compat _ (Plus X)). 
    rewrite (Union_trans _ X). rewrite <- (Union_trans X). rewrite (Union_sym (X ∪ Minus ((M ∪ Minus X) ∩ √Plus X)) (Minus X)).
    rewrite <- (Union_trans P).
    rewrite (Intersection_sym (√Plus ((M ∪ Minus X) ∩ √Plus X)) (√Plus X)). 
    rewrite <- Intersection_trans.
    rewrite (I_U_dist_r _ (P ∪ Minus X)). 
    rewrite H23 at 1. 
    unfold Same_set, Included; repeat (basic; intuition). 
      right.
        apply In_Intersection... 
        apply In_Complement... 
        assert (dim x = n)... apply (Plus_dim X (n))... 
        assert (S (dim x) <= n). apply (Minus_dim' _ n) in H25... 
        unfold Included... unfold sup, In at 1... repeat (basic; intuition).
        assert (dim x0 = n)... apply (Minus_dim X Full_set (n))... rewrite H29... 
        rewrite H27 in H28...
      right. repeat (basic; intuition). 
        apply In_Complement... 
         assert (dim x = S n)... 
         assert (dim x = n)... apply (Plus_dim _ n) in H20... 
         rewrite H26 in H27... 
        apply In_Complement... 
         assert (dim x = S n)... 
         assert (dim x <= n)... apply (Plus_dim' _ n) in H20...
         unfold Included... unfold sup, In at 1... repeat (basic; intuition).
         assert (dim x0 = n)... apply (Minus_dim X Full_set (n))... rewrite H28... 
         rewrite H26 in H27...

    unfold Y. 
    assert ((sup M (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((M ∪ Minus X) ∩ √Plus X))) as JA. admit. (* wait until n-1 is fixed *)
    assert ((sup P (n - 1) ∪ ((sub M n ∪ Minus X) ∩ √Plus X)) == (((P ∪ Minus X) ∩ √Plus X))) as JB. admit. (* before doing this *)
    rewrite JA, JB in *.
    unfold moves_def in *...

    rewrite (Union_trans _ X _).
    rewrite (Union_sym X _).
    rewrite <- (Union_trans _ _ X).
    rewrite I_U_dist_r.
    assert (X ∩ √Minus (P ∪ X) == X) as G. 
      unfold Same_set, Included; repeat (basic; intuition). apply In_Complement... 
      refine (ddd X (Minus (P ∪ X)) (S n) n _ _ _ x _)...
      unfold sup, Included... unfold In at 1... inversion H26; clear H26... 
      assert (S (dim x0) = dim x1)... basic... 
      assert (dim x1 <= n)... apply (le_trans _ (S (dim x0))). constructor... 
      rewrite H27... 
      assert (dim x1 = (S n))... rewrite <- H27 in H26... 
      inversion H26... 
    rewrite G. clear G. 
    apply Union_mor...
    assert (P == (((P ∪ Minus X) ∩ √Plus X) ∩ √Minus X) ∪ (P ∩ Plus X)) as G. 
      unfold Same_set, Included; repeat (basic; intuition). 
      assert ((In (Plus X) x) \/ ~(In (Plus X) x))... apply all_decidable... 
      left. basic... apply In_Complement... 
      assert (dim x = n)... apply (Minus_dim _ Full_set n) in H25... 
      assert (In (sub M n) x)... rewrite (cell_dim_n_property M P)... unfold is_a_cell... 
      assert (In Empty_set x)... rewrite <- H5... 
    rewrite G; clear G.
    rewrite H17 at 1.
    repeat (rewrite (Plus_Union_compat)).
    repeat (rewrite (Minus_Union_compat)).
    rewrite <- (Union_Complement_compat _ (Minus X)).
    admit.
(*
    Notation "A # B -# C" := (Intersection (Union A (Minus B)) (Complement (Plus  C))) (at level 89). 
    Notation "A @ B -@ C" := (Intersection (Union A (Plus  B)) (Complement (Minus C))) (at level 89). 
*)

    rewrite (Plus_Union_compat _ X).
    rewrite (Minus_Union_compat _ X).
    rewrite <- (Union_Complement_compat _ (Plus X)). 
    admit. 
  Qed.

  Lemma Lemma_3_2_Step_2' :
    forall n, ((Lemma_3_2_b_st n 1) -> (forall m, Lemma_3_2_b_st n (S m))).
  Proof with intuition.
    intros n hypothesis_for_1 m.

    induction m. assumption.
 
    unfold Lemma_3_2_b_st in *. 
    intros X Xcard M P H J.
    inversion H as [MPcell MPdim]; clear H.
    inversion J as [Xdim K]; clear J.
    inversion K as [Xwf Xcond]; clear K.

    assert (exists x, In X x /\ Disjoint (plus x) (Minus X)) as R.  (* maximal *)
      apply (wf_maximal_exists X (S n))...
      apply (Cardinal_are_Finite (S (S m)))...
      apply Cardinal_Sn in Xcard... 
      unfold setdim... 
      assert (dim x = S n)... rewrite H0... 
    inversion R as [x xcond]; clear R. 
    inversion xcond as [xinX disj]; clear xcond.
    assert (dim x = S n) as dimx. idtac...

    assert (plus x ⊆ sub M n) as K. 
      apply (Included_trans _ (PlusMinus X))...
        unfold PlusMinus. rewrite <- (Intersection_idemp (plus x)).
        apply Intersection_Included_compat...
          unfold Included, Plus, In... exists x...
        apply Disjoint_property_left...

    assert (is_a_cell
                 (sup M (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
                 sup P (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
               ∧ Minus (Singleton x) ∩ sub M n == Empty_set).
        apply hypothesis_for_1...
        apply Cardinality_Singleton_is_one.
        unfold Included... inversion H; subst... 
        rewrite PlusMinus_Singleton...
    inversion H as [LA LB]; clear H.
    
    set (N :=  sup M (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Q :=  sup P (n - 1) ∪ ((sub M n ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))). 
    set (Z := Intersection X (Complement (Singleton x))).
    set (Y' := (sub N n ∪ (Minus Z)) ∩ √Plus Z).
    set (Y  := (sub M n ∪ (Minus X)) ∩ √Plus X). 
    assert (X == Union (Singleton x) Z) as XZrel. 
      unfold Z. 
      rewrite Union_sym. rewrite U_I_dist_r. 
      rewrite Full_set_property. rewrite Full_set_ident_right. 
      unfold Same_set, Included... apply In_Union in H... inversion H0. rewrite <- H...
      intuition. 

    assert (Cardinal Z (S m) /\ Z ⊆ sub Full_set (S n) /\ well_formed Z) as Zproperties.
      idtac...
      unfold Z. rewrite <- Setminus_is_Intersection_Complement. 
      apply Cardinal_Setminus...
      apply (Included_trans _ X _)... 
      unfold Z. 
      apply Intersection_Included_cancel_right... 
        unfold Z. apply (well_formed_Included X)...
        apply Intersection_Included_cancel_right...
    inversion Zproperties as [Zcard T].
    inversion T as [Zdim Zwf]. clear T Zproperties. 

    split.

    assert (is_a_cell ((sup N (n - 1)  ∪ Y'), (sup Q (n - 1) ∪ Y')) /\ Minus Z ∩ sub N n == Empty_set) as AA.
      apply (IHm Z)...
        unfold celldim, N, Q, setdim...
          apply In_Union in H...
          apply In_Union in H0...
            apply (le_trans _ (n-1))...
          apply In_Intersection in H...
          apply In_Union in H0...
          assert (dim x0 = n)... rewrite H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
          apply In_Union in H0...
            apply (le_trans _ (n-1)). repeat subsuptac... idtac...
          apply In_Intersection in H...
          apply In_Union in H0...
          assert (dim x0 = n)... rewrite H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...

        assert (sub N n == Intersection (Union (sub M n) (minus x)) (Complement (plus x))) as JA.
            unfold N. 
            rewrite sub_Union.
            rewrite sub_Intersection. rewrite sub_Union.
            rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left...
            rewrite sub_idemp.
            rewrite Minus_Singleton.
            rewrite Plus_Singleton.
            unfold Same_set, Included;
              repeat basic...
              right. 
              repeat subsuptac... 
              repeat subsuptac... 
              repeat subsuptac... 
        assert (PlusMinus Z ⊆ Intersection (Union (PlusMinus X) (minus x)) (Complement (plus x))) as JB. 
          unfold PlusMinus.
          rewrite XZrel.
          rewrite Plus_Union_compat. 
          rewrite Minus_Union_compat.
          rewrite Plus_Singleton. 
          rewrite Minus_Singleton.
          rewrite <- Union_Complement_compat.
          unfold Included; repeat (basic; intuition). 
          assert ((In (minus x) x0) \/ ~(In (minus x) x0))... 
            assert (Finite (minus x))... assert (decidable (minus x))... apply H3. 
            apply In_Complement; unfold not... 
            unfold Plus, Z, In at 1 in H1. 
            inversion H1 as [d SS]...
            apply In_Intersection in H3...
            unfold well_formed in Xwf...
            assert (x = d). 
            refine (H7 _ _ _ n _ _ _)... unfold perp in H8... 
            assert (In Empty_set x0). rewrite <- H9. apply In_Intersection... inversion H8. rewrite H8 in H6. 
            apply In_Complement in H6; unfold not in H6... 
        
      rewrite JA, JB.
        apply Intersection_Included_compat...
        apply Union_Included_compat...

      assert (sup N (n-1) == sup M (n-1)) as J1.
        unfold N.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1... 
        repeat subsuptac...
        apply In_Intersection in H1... 
        apply In_Union in H2... 
        repeat subsuptac...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1. 
        rewrite H5 in H3. exfalso... apply qwer'' in H3... 

      assert (sup Q (n-1) == sup P (n-1)) as J2.
        unfold Q.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1... 
        repeat subsuptac...
        apply In_Intersection in H1... 
        apply In_Union in H2... 
        assert (dim x0 = n)...  rewrite H2 in H3. exfalso. apply qwer'' in H3...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1. 
        rewrite H5 in H3. exfalso... apply qwer'' in H3... 

      assert (Y == Y') as J3. 
        unfold Y, Y', N.    
        rewrite XZrel.
        rewrite Minus_Union_compat.
        rewrite Plus_Union_compat.
        rewrite <- Union_Complement_compat.
        rewrite sub_Union. 
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left.
        rewrite sub_Intersection. rewrite sub_Union. rewrite sub_idemp. rewrite sub_Minus.
        rewrite <- Intersection_trans.
        rewrite <- Union_trans.
        rewrite I_U_dist_r.
        assert (sub (Singleton x) (S n) == (Singleton x)) as WW. 
          unfold Same_set, Included... subsuptac... subsuptac...
          inversion H1. rewrite <- H2...
        rewrite WW. clear WW.
        rewrite Minus_Singleton, Plus_Singleton.
          unfold Same_set, Included... 
            repeat (basic; intuition). 
            left... left... 
            repeat (basic; intuition). 
            left... apply In_Intersection... repeat subsuptac...
            left...
            right... apply In_Intersection... 
            unfold Z in H1. unfold Minus, In at 1 in H1. 
            inversion H1 as [z T]; clear H1... 
            apply In_Complement; unfold not... 
            apply (H2 x0). apply In_Intersection... exists z... apply In_Intersection in H1...

      fold (is_a_cell' (sup N (n - 1) ∪ Y') (sup Q (n - 1) ∪ Y')) in AA.
      rewrite J1, J2, <- J3 in AA... 
    fold N in LA. 
    fold Q in LA.

    assert (celldim (N, Q) n) as NQdim.
      unfold celldim, N, Q. 
      setdimtac.
      rewrite dimx... 
      rewrite dimx... 
    assert (sub N n == (sub M n ∪ (minus x)) ∩ √(plus x)). 
      unfold N. 
      rewrite Minus_Singleton, Plus_Singleton.
      unfold Same_set, Included, sub, sup; repeat (basic; intuition)... 
        exfalso. rewrite H2 in H3... apply qwer'' in H3...
        right; basic...
    assert (Minus Z ∩ sub N n == Empty_set).
      apply (IHm Z Zcard N Q)...
      rewrite H.
      unfold PlusMinus, Z, Included; repeat (basic; intuition)... 
        inversion H2; clear H2...
        assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
          apply all_decidable... 
          left; apply Xcond... 
          unfold PlusMinus; repeat basic... exists x1...
          apply In_Complement... 
          apply H3... inversion H2; clear H2... 
          exists x2; repeat basic...
          apply In_Complement...
          inversion H7; clear H7...
          rewrite <- H9 in *...
          apply In_Complement...
          inversion H2... 
          apply In_Intersection in H5...
          assert (x = x1)... unfold well_formed in Xwf...
          refine (H8 _ _ _ n _ _ _)...
          unfold perp in H9... assert (In (Empty_set) x0)...
          rewrite <- H10...
    assert (Disjoint (sub M n) (minus x)).
      rewrite Disjoint_intersection_condition.
      rewrite Intersection_sym.
      rewrite Minus_Singleton in LB...
    assert ((sub N n ∪ (plus x)) ∩ √(minus x) == sub M n). 
      rewrite H. 
      rewrite U_I_dist_r. 
      rewrite Full_set_property... 
      rewrite Full_set_ident_right.
      repeat (rewrite I_U_dist_r). 
      rewrite Empty_set_property...
      rewrite Empty_set_ident_right.
      assert (Included (minus x) (√(sub M n))).
        apply Disjoint_property_right... 
      apply Complement_Included_compat in H2... 
      rewrite Complement_Complement_compat in H2...
      assert (Included (minus x) (√(sub M n))).
        apply Disjoint_property_right... 
      unfold Same_set, Included; repeat (basic; intuition)...
       apply all_decidable... apply Finite_sub... apply MPcell. 
    rewrite <- H2. 
    rewrite XZrel. 
    rewrite Minus_Union_compat.
    rewrite Minus_Singleton. 
    rewrite <- Intersection_trans.  
    rewrite I_U_dist_l. 
    rewrite (I_U_dist_r (sub N n)). 
    rewrite (I_U_dist_r (plus x)).
    rewrite H0; clear H0.
    unfold Same_set, Included... 
    exfalso; repeat (basic; intuition)...
    apply (H1 x0)... basic...
    apply (Minus_Included Z X)... rewrite XZrel...
  Qed.

  Axiom cells_are_receptive : forall M P, is_a_cell (M, P) -> receptive M /\ receptive P.

  Lemma Lemma_3_2_Step_3' :
    forall n, (forall m , Lemma_3_2_b_st (n - 1) m) -> (Lemma_3_2_b_st n 1).  
  Proof with intuition.
    intros n Hyp1.

    induction n.
    (* n = 0 *)
    apply Lemma_3_2_b_0_1.

    (* n > 0 *)
    rewrite (Sn_minus_1 n) in *.
    intros X Xcard M P K L.
    inversion K as [MPcell MPdim]; clear K.
    inversion L as [Xdim J]; clear L.
    inversion J as [Xwf Xcond]; clear J.
    assert (Finite X) as XFin. apply (Cardinal_are_Finite 1)...

    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    assert (In X x) as xinX. rewrite Xsing...

    assert (plus x ⊆ sub M (S n)) as plusxdim.
      assert (PlusMinus X == plus x) as K. 
        unfold PlusMinus. rewrite Xsing. 
        rewrite Plus_Singleton, Minus_Singleton. 
        apply Intersection_Included_left. apply Disjoint_property_left.
        apply plus_minus_Disjoint.
      rewrite <- K... 
    set (Y := (sub M (S n) ∪ Minus X) ∩ √Plus X).

    set (S' := (fun z =>  ~(In (plus x) z) /\ exists w, In (plus x) w /\ triangle_rest (sub M (S n)) z w)).
    set (T  := Setminus ((Setminus (sub M (S n))) S') (plus x)). 
    assert ((sub M (S n)) == S' ∪ (plus x) ∪ T) as DisjUnion. 
      unfold Same_set, Included...
        assert (In (plus x) x0 \/ ~(In (plus x) x0))... apply Finite_are_decidable...
        assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)))... 
          apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left; left. unfold S', In at 1... 
        right. unfold T, Setminus... unfold In at 1... unfold In at 1... unfold S', In at 1 in H0... 
        apply In_Union in H... apply In_Union in H0... unfold S', In at 1 in H... inversion H1; clear H1...
        inversion H2... unfold T, Setminus in H0; repeat (basic; intuition)...
    assert (Disjoint (plus x) S') as DisjMS'. 
      unfold S', Setminus. constructor... apply In_Intersection in H... 
      unfold In at 1 in H1...
    assert (Disjoint (plus x) T) as DisjMT. 
      unfold T, Setminus. constructor... apply In_Intersection in H... 
      unfold In at 1 in H1...
    assert (Disjoint T S') as DisjTS'. 
      unfold T, S', Setminus. constructor... 
      apply In_Intersection in H... 
      unfold In at 1 in H1... 
      unfold In at 1 in H0...
      unfold In at 1 in H1... 
    assert (is_initial_segment S' (sub M (S n))) as S'initial. 
      unfold is_initial_segment. 
      split. unfold S', Included...
      unfold In at 1 in H... inversion H1; clear H1... induction H2... 
      unfold S'... unfold In at 1 in H0... unfold In at 1... apply H1...
      inversion H2 as [w E]; clear H2... 
      assert (is_a_segment (plus x) (sub M (S n)))... apply Prop_1_3... apply xplus_is_tight. 
      apply (well_formed_Included M). apply MPcell. unfold Included, sub, In...
      apply ZZZb in H4...
      refine (H6 y w _ _ _)...
      inversion H2 as [a A]; exists a... 
      apply (triangle_rest_trans _ _ z)...
    assert (is_final_segment T (sub M (S n))) as Tfinal. 
      unfold is_final_segment. 
      split. unfold T, Setminus, Included, In...
      unfold T... unfold Setminus, In at 1 in H0... unfold In at 1 in H1... 
      unfold Setminus, In at 1... unfold In at 1... apply triangle_rest_in_set in H... apply H3. 
      unfold is_initial_segment in S'initial... apply (H5 y z)...
      assert (is_initial_segment (Union S' (plus x)) (sub M (S n))). 
        unfold is_initial_segment... rewrite DisjUnion. unfold Included...
        apply In_Union in H5... left.
        unfold is_initial_segment in S'initial... apply (H7 y0 z0)...
        assert ((y0 ∈ plus x) \/ ~(y0 ∈ plus x))... apply Finite_are_decidable... left. unfold S', In at 1... exists z0...
      unfold is_initial_segment in H4... assert (y ∈ S' ∪ plus x). apply (H6 y z)...
      apply In_Union in H4...
    assert (Finite S') as S'Fin. 
      apply (Finite_Included'' (sub M (S n)))... apply Finite_sub. apply MPcell. 
      unfold S', Included, In ... inversion H1; clear H1... inversion H2... 
      assert ((In (plus x) x0) \/ ~(In (plus x) x0))... apply Finite_are_decidable...
      right... unfold S', In at 1 in H0...
      assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S n)) x0 w)))... 
        apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left... unfold S', In at 1... right...  apply H2. unfold S', In at 1 in H0...
    assert (Finite T) as TFin. 
      unfold T. apply Setminus_Finite'... 
      apply Setminus_Finite'... 
      apply Finite_sub. apply MPcell.
    assert (sub T (S n) == T) as Tdim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold T, Setminus in H... unfold In at 1, In at 1 in H...
    assert (sub S' (S n) == S') as S'dim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold S', Setminus in H... unfold In at 1 in H...
      inversion H1; clear H1...
      apply triangle_rest_in_set in H2...

    assert ((S' ∪ plus x moves sub M n
               to (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x))
              ∧ (T moves (sub P n ∪ Minus T) ∩ √Plus T to sub P n)
                ∧ (sub P n ∪ Minus T) ∩ √Plus T ==
                  (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)). 
    apply Prop_2_4'... apply Finite_Union...
    rewrite <- DisjUnion...
    pose (moves_by_dim M M P) as I. inversion I; clear I... apply H... apply MPcell...
    apply (Included_trans _ (PlusMinus (sub M (S n)))).
     unfold T, PlusMinus.
     repeat (rewrite Setminus_is_Intersection_Complement)... 
     unfold Included; repeat (basic; intuition)... 
     inversion H3... exists x1... repeat (basic; intuition)...
     apply In_Complement... apply H4...
     rewrite Intersection_trans.
     rewrite Union_Complement_compat. 
     inversion H0... exists x1... repeat (basic; intuition)...
     inversion H3...              repeat (basic; intuition)...
       apply In_Complement... apply In_Union in H5... 
       unfold S', In at 1 in H12...
       inversion H13; clear H13...
       apply (H1 x3)... apply In_Intersection... 
       unfold is_final_segment in Tfinal... 
       refine (H15 x2 _ _ _). apply (tr_trans _ _ x1)... exists x0... 
       unfold T, In at 1; repeat (basic; intuition)... 
       rewrite DisjUnion in H8; repeat (basic; intuition)...
       assert (In T x1)...
       unfold is_final_segment in Tfinal... 
       refine (H13 x2 _ _ _)... apply (tr_trans _ _ x1)... exists x0... 
       left... unfold T, Setminus in H8... unfold In at 1, In at 1 in H8; repeat (basic; intuition)... 
    rewrite sub_PlusMinus...
    apply sub_Included_compat. 
    apply Prop_2_1_dual... apply MPcell... exists M... apply MPcell...
    unfold Perp. 
    apply Perp_thing...
    apply Disjoint_three... 
    apply Disjoint_sym... 
    rewrite <- DisjUnion.
    pose (well_formed_by_dimension M).
    inversion i. apply H.
    apply MPcell... 
    apply Finite_Union... 
    assert (dim b = S n). rewrite <- Tdim in H1...
    assert (dim a = S n). apply In_Union in H0... rewrite <- S'dim in H2...
    rewrite H, H2...

    set (B := (sub M n ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)). 
    fold B in H. 
    assert (sub B n == B) as Bdim. 
      unfold Same_set, Included, sub... 
        unfold In at 1 in H1... 
        unfold In at 1... 
        unfold B in H1... 
        repeat (basic; intuition)...
        inversion H1; clear H1...
        assert (dim x1 = S n)...
          apply In_Union in H1...
          rewrite <- S'dim in H6...
        assert (S (dim x0) = dim x1)...
        rewrite H6 in H9...

    assert ((S' moves sub M n to (sub M n ∪ Plus S') ∩ √Minus S')
              ∧ (plus x moves (B ∪ Minus (plus x)) ∩ √Plus (plus x) to B)
                ∧ (B ∪ Minus (plus x)) ∩ √Plus (plus x) ==
                  (sub M n ∪ Plus S') ∩ √Minus S') as JJJ.
    apply Prop_2_4'... 
    unfold B, Included, PlusMinus... 
      rewrite Plus_Union_compat. 
      rewrite Minus_Union_compat. 
      rewrite <- Union_Complement_compat. 
      repeat (basic; intuition)...
      apply In_Complement... apply H7... exfalso.
      inversion H6... inversion H1...
        assert (less x1 x2)... exists x0...
        apply (H5 x1)... basic... 
        unfold is_initial_segment in S'initial...
        apply (H14 _ x2)... apply (tr_trans _ _ x2)... left...
    unfold Perp. 
    apply Perp_thing...
    apply Disjoint_sym... 
    apply (well_formed_Included M).
    apply MPcell...
    apply (Included_trans _ (sub M (S n)))...
    rewrite DisjUnion...
    assert (dim a = S n). rewrite <- S'dim in H3...
    assert (dim b = S n). assert (S (dim b) = dim x)... 
    rewrite H1, H5...
    set (A := (sub M n ∪ Plus S') ∩ √Minus S'). 
    fold A in JJJ. 
    assert (sub A n == A) as Adim. 
      unfold Same_set, Included, sub... 
        unfold In at 1 in H2... 
        unfold In at 1... 
        unfold A in H2... 
        repeat (basic; intuition)...
        inversion H2; clear H2...
        assert (dim x1 = S n)...
          rewrite <- S'dim in H2...
        assert (S (dim x0) = dim x1)...
        rewrite H9 in H12...

    inversion H as [movesMtoB [movesBtoP Bdef]]. 
    clear H. symmetry in Bdef. rewrite <- Bdef in movesBtoP. 
    inversion JJJ as [movesMtoA [movesAtoB Adef]].
    clear JJJ. symmetry in Adef. rewrite <- Adef in movesAtoB. 
 
    assert (dim x = S (S n)) as xdim. 
      idtac...

    set (tM := sub P (n) ∪ sup M (n - 1)).
    set (tP := sup P (n)).
    assert (is_a_cell (tM, tP)) as tMPcell.
      unfold tM, tP. apply target_is_a_cell... 
    assert (celldim (tM, tP) (n)) as tMPdim. 
      apply target_dim...
    assert (sub tM n == sub P n) as targetrel. 
        unfold tM... 
        rewrite sub_Union. rewrite sub_idemp. rewrite sub_sup_Empty_set... 
      
(*
    assert (is_a_cell ((sup M (n - 1) ∪ B ∪ T          , sup P (n) ∪ T))        ).
    assert (is_a_cell ((sup M (n - 1) ∪ B              , sup P (n - 1) ∪ B))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ A ∪ (plus x)   , sup P (n) ∪ (plus x))) ).
    assert (is_a_cell ((sup M (n - 1) ∪ A              , sup P (n - 1) ∪ A))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n) ∪ S' , sup P (n) ∪ S'))       ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n)      , sup P (n - 1) ∪ (sub M n))) ).
  *)  (* I don't know what this is for, leave it until i'm sure the lemma works *)

    assert (exists mT, Cardinal T mT). apply Cardinality_exists. assumption.
      inversion H as [mT Tcard]; clear H.
    

    (* is a cell (M + B + T) (P + T) *)
    assert (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T) ∪ T, tP ∪ T))) as T1.
      apply (Lemma_3_2_Step_1' _ mT)...
      unfold Included... subsuptac... 
      assert (In (sub M (S n)) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion... 
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P n)). apply Prop_2_1_dual... 
      exists B... apply H0...
    
    (* is a cell (M + B) (P + B) *)
    assert (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)  , sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T))) 
       /\ (Minus T) ∩ sub tM n == Empty_set) as T2.
      apply (Hyp1 mT)...
      unfold Included... subsuptac... 
      assert (In (sub M (S n)) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion... 
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P n)). apply Prop_2_1_dual... 
      exists B... apply H0...
    
    assert (exists mplusx, Cardinal (plus x) mplusx). 
      apply Cardinality_exists...
      inversion H as [mplusx plusxcard]; clear H.

    (* is a cell (M + A + x) (P + B + x) *)
    assert (is_a_cell
             ((sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n) ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ (plus x),
             (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) ∪ (plus x))) as plusx1. 
      apply (Lemma_3_2_Step_1' _ mplusx)...
      unfold celldim... 
        setdimtac.
        unfold T; setdimtac.
        unfold T; setdimtac.
        unfold Included, sub... unfold In at 1... 
      rewrite targetrel. 
      rewrite <- Bdef. 
      assert (sub ((sup tM (n - 1) ∪ B)) n == B).
        rewrite sub_Union... rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...  
    
    assert (is_a_cell
               (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n ∪ Minus (plus x)) ∩ √Plus (plus x)),
               sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1) ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n ∪ Minus (plus x)) ∩ √Plus (plus x)))
             ∧ Minus (plus x) ∩ sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n == Empty_set) as plusx2.
      apply (Hyp1 mplusx)... 
      unfold celldim... 
        setdimtac... 
        unfold T; setdimtac... 
        unfold T; setdimtac... 
      unfold Included... 
      rewrite targetrel. 
      rewrite <- Bdef.
      assert (sub ((sup tM (n - 1) ∪ B)) n == B). 
        rewrite sub_Union. 
        rewrite sub_sup_Empty_set... 
        rewrite Empty_set_ident_left... 
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...  
    
    assert (exists mS', Cardinal S' mS'). 
      apply Cardinality_exists...
    inversion H as [mS' S'card]; clear H.

    assert (is_a_cell
        ((sup (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S')) ∪ S', (sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
           ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
               ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ S')) as S'1.
      apply (Lemma_3_2_Step_1' _ mS')...
      unfold celldim... setdimtac... 
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (Included_trans _ (sub M (S n))). rewrite DisjUnion...
        apply sub_Included'... 
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      unfold Included; intros. 
      rewrite sub_Union at 1. right.
      assert (PlusMinus S' ⊆ A). apply Prop_2_1_dual...
      exists (sub M n)... apply H4 in H3; clear H4.
      rewrite Adef in H3...
      unfold sub at 1, In at 1...  assert ((sub (sup tM (n - 1) ∪ B) n == B)). 
        rewrite sub_Union. rewrite Bdim. 
        rewrite sub_sup_Empty_set...
      rewrite H4... repeat (basic; intuition). rewrite Bdef in H3.
      repeat (basic; intuition). unfold T, Minus, Setminus, sub, In in H3. 
      inversion H3; clear H3... apply minus_dim in H10. rewrite H13 in H10. inversion H10...
      unfold Minus, In at 1 in H3. inversion H3... assert (dim x = S (S n))...
      apply minus_dim in H10. 
      apply plus_dim in H9. assert (S (S (dim x0)) = S (S n))... rewrite <- H7.
      rewrite H10... inversion H11... 

    assert (is_a_cell
        (sup (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S'),
        sup (sup (sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
           ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
               ∪ Minus (plus x)) ∩ √Plus (plus x))) (n - 1) ∪ ((sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ Minus S') ∩ √Plus S'))
      ∧ Minus S' ∩ sub (sup (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (n - 1)
            ∪ ((sub (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) n
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n == Empty_set)
    as S'2.
      apply (Hyp1 mS')...
      unfold celldim... setdimtac...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (setdim_Included _ (sub M (S n)))... apply setdim_sub...
        apply (Included_trans _ (sub M (S n))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))... 
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      rewrite sub_Union.
      rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left.
      assert (sub ((sub (sup tM (n - 1) ∪ B) n ∪ Minus (plus x)) ∩ √Plus (plus x)) n == (B ∪ Minus (plus x)) ∩ √Plus (plus x)).
        rewrite sub_Union at 1. 
        rewrite Union_trans. 
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        rewrite Bdim.
        unfold Same_set, Included...
          unfold sub, In at 1 in H3...
          unfold sub, In at 1...
          repeat (basic; intuition)... rewrite <- Bdim in H3...
          apply (Minus_dim _ _ _ plusxdim)... trivial. 
      rewrite H3. 
      rewrite <- Adef.
      apply Prop_2_1_dual...
      exists (sub M n)...

(* this is tidying up, it is completely optional, doesn't change the meaning of anything, but might change
   whether the proofs compile *) (*
    fold (is_a_cell' ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) ∪ T) (tP ∪ T)) in T1.
    rewrite targetrel in T1. rewrite <- Bdef in T1.
    unfold tM in T1.
    rewrite sup_Union in T1. 
    rewrite sup_idemp in T1. 
    rewrite sup_sub_comm in T1.
    rewrite sub_sup_Empty_set in T1.
    rewrite Empty_set_ident_left in T1. 
    unfold tP in T1.
    unfold is_a_cell' in T1. 
    fold (is_a_cell' (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (
       sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T))) in T2.
    rewrite targetrel in T2. rewrite <- Bdef in T2.
    unfold tM in T2.
    rewrite sup_Union in T2. 
    rewrite sup_idemp in T2. 
    rewrite sup_sub_comm in T2.
    rewrite sub_sup_Empty_set in T2.
    rewrite Empty_set_ident_left in T2. 
    unfold tP in T2.
    rewrite sup_sup_min in T2.
    unfold is_a_cell' in T2. 
    inversion T2 as [T2a T2b]; clear T2. *)

    assert ((minus x) moves A to B) as moves4. 
      apply Prop_3_1. 
      assumption. 
      admit. (* ?? -- receptivity condition, see bottom of p326 *)

    assert ((S' ∪ (minus x)) moves (sub M n) to B) as moves5.
      refine (Prop_2_3 _ _ _ _ _ movesMtoA _ _)...
      assert (∃ n : nat, Cardinal S' n). apply Cardinality_exists... 
      inversion H5 as [p J]. 
      induction p. 
        apply Cardinality_zero_Empty_set in J. 
         rewrite J. 
         constructor... inversion H6. inversion H7...
        constructor...
         apply In_Intersection in H6...
         inversion H7 as [w R ]; clear H7...
         inversion H8 as [v R']; clear H8...
         set (Z := fun y => In S' y /\ triangle_rest S' w y).
         assert (exists m : carrier, m ∈ Z /\ 
            (forall y : carrier, y ∈ Z → triangle_rest Z m y -> m = y)).
         refine (maximal_exists p _ _ (S n) _)... admit. admit.
         inversion H10 as [u [uinZ umax]]; clear H10...
         assert (plus u ∩ Minus (plus x) == Empty_set).
           apply (Prop_1_2_dual _ v)...
           right with w. exists x0...
           apply (rest_implies_full S').
           unfold Z, In at 1 in uinZ...
         set (A' := Intersection (Union A (minus u)) (Complement (plus u))).
         set (B' := Intersection (Union B (minus u)) (Complement (plus u))).
         assert ((plus x) moves A' to B').
           unfold A', B'.
           apply Prop_2_2... 
           unfold Included, A; intros; apply In_Intersection...
             right. exists u... unfold Z, In at 1 in uinZ...
             apply In_Complement...
             inversion H12; clear H12...
             assert (triangle_rest S' u x2).
               right with x2...
               unfold Z, In at 1 in uinZ... 
               exists x1...
               left...
             admit.
           constructor... 
             apply In_Intersection in H11... 
             unfold MinusPlus in H12; apply In_Intersection in H12. 
             assert (In (Empty_set) x1)... 
               rewrite <- H10. 
               apply In_Intersection...
           constructor... 
             apply In_Intersection in H11... 
             inversion H13; clear H13...
             assert (less x2 u).
               exists x1...
             refine (initial_property _ (plus x) _ S'initial _ _ u x2 _ _ _)...
               apply Disjoint_sym...
               unfold Z, In at 1 in uinZ...
           admit. 
         admit. 
       
    assert (((minus x) ∪ T) moves A  to (sub P n)) as moves6.
      refine (Prop_2_3 _ _ _ _ _ moves4 _ _)... 
      admit. 

    assert (((S' ∪ (minus x)) ∪ T) moves (sub M n) to (sub P n)) as moves7.
      assert (Disjoint (Minus (minus x)) (Plus T)) as Disjtemp. 
        admit.
      refine (Prop_2_3 _ _ _ _ _ moves5 _ _)... 
      apply Disjoint_intersection_condition.
      rewrite Minus_Union_compat.
      rewrite I_U_dist_r. 
      assert ((Minus S' ∩ Plus T) == Empty_set).
        unfold Same_set, Included...
        exfalso. 
        apply In_Intersection in H5... 
        inversion H6. inversion H7...
        refine (final_property _ (S') _ Tfinal _ _ x1 x2 _ _ _)...
          rewrite DisjUnion... 
        rewrite Disjoint_sym...
        exists x0... 
        inversion H5. 
        rewrite H5; clear H5. rewrite Empty_set_ident_left.
      apply (Disjoint_intersection_condition)...

    assert (well_formed (S' ∪ (minus x))) as WF1.
      apply tttt... 
      apply (well_formed_Included (sub M (S n)))... 
      apply (well_formed_Included    M         )... apply MPcell. unfold Included, S', In at 1...
      inversion H7; clear H7... inversion H8... 
        admit.
      assert ((S' ∪ minus x) == sub (S' ∪ minus x) (S n)).
        unfold Same_set, Included... unfold sub, In at 1... repeat (basic; intuition)...
        unfold S', In at 1 in H9... inversion H10; clear H10... inversion H11... unfold sub, In at 1 in H5...
      rewrite H5... unfold Same_set, Included, sub, In... rewrite H9 in H8; exfalso... inversion H8... 

    assert (well_formed ((minus x) ∪ T)) as WF2.
      (* as above *)
      admit.

    assert (well_formed ((S' ∪ minus x) ∪ T)) as WF3.
      admit.

    assert (Y == (S' ∪ minus x) ∪ T) as Ycond.
      unfold Y. 
      rewrite DisjUnion. 
      rewrite Xsing.
      rewrite Minus_Singleton, Plus_Singleton.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      repeat (rewrite <- Disjoint_result)... 
      rewrite Union_trans, <- (Union_sym _ T). 
      rewrite <- Union_trans... 
      apply Disjoint_intersection_condition... apply Disjoint_sym...
      apply Disjoint_intersection_condition... apply Disjoint_sym...
      apply Disjoint_intersection_condition... apply Disjoint_sym...
 
    (* real work begins *)
    
    split.
    unfold is_a_cell...

    rewrite Ycond. apply (Inhabited_Included (minus x)). 
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    rewrite Ycond. apply (Inhabited_Included (minus x)). 
      apply minus_Inhabited. rewrite xdim... 
      unfold Included; intros; right;left;right...

    apply well_formed_Union... 
    apply (well_formed_Included M). 
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H8. rewrite (Sn_minus_1 n) in H7. assert (dim x0 <= n)... 
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8... 
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    apply well_formed_Union... 
    apply (well_formed_Included P). 
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H8. rewrite (Sn_minus_1 n) in H7. assert (dim x0 <= n)... 
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8... 
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    rewrite (Sn_minus_1 n). 
    rewrite Ycond... 
    repeat (apply Finite_Union)...
      apply all_decidable. apply Finite_sup_n... apply MPcell.
      apply all_decidable. apply Finite_Union... apply Finite_sup_n... apply MPcell.

    rewrite (Sn_minus_1 n). 
    rewrite Ycond... 
    repeat (apply Finite_Union)...
    apply all_decidable... apply Finite_sup_n... apply MPcell.
    apply all_decidable. apply Finite_Union... apply Finite_sup_n... apply MPcell.
 
    (* there is some condition about splitting dimensions that should make this work *)
    rewrite (Sn_minus_1 n). 
    unfold moves_def... 
      assert (forall k, sub (sup P n ∪ Y) k == sub (((sup M n ∪ Y) ∪ Plus (sup M n ∪ Y)) ∩ √Minus (sup M n ∪ Y)) k). 
        intros.
        assert ({k <= (S n)} + {(S n) < k})...
        inversion a; clear a... 
          rewrite <- Setminus_is_Intersection_Complement. 
          rewrite sub_Setminus. 
          repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
          repeat (rewrite sub_sup_Empty_set || rewrite Empty_set_ident_left)...
          assert (sub Y (S (S n)) == Empty_set). 
            admit. 
          repeat (rewrite H6).
          rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
          subst.
          assert (sub Y k == Empty_set).
            admit.
          admit. 
        assert (Y == sub Y (S n)). admit.
        rewrite H5.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite sub_Setminus. 
        repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        repeat (rewrite sub_sup_Empty_set || rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left)...
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set...
        rewrite H6 in b...
      apply FFF in H5...
      assert (forall k, sub (sup M n ∪ Y) k == sub (((sup P n ∪ Y) ∪ Minus (sup M n ∪ Y)) ∩ √Plus (sup M n ∪ Y)) k). 
        intros.
        assert ({k <= (S n)} + {(S n) < k})...
        inversion a; clear a... 
          rewrite <- Setminus_is_Intersection_Complement. 
          rewrite sub_Setminus. 
          repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
          repeat (rewrite sub_sup_Empty_set || rewrite Empty_set_ident_left)...
          assert (sub Y (S (S n)) == Empty_set). 
            admit. 
          repeat (rewrite H6).
          rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
          subst.
          assert (sub Y k == Empty_set).
            admit.
          admit. 
        assert (Y == sub Y (S n)). 
          admit.
        rewrite H5.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite sub_Setminus. 
        repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        repeat (rewrite sub_sup_Empty_set || rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left)...
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set...
        rewrite H6 in b...
      apply FFF in H5...

    rewrite (Sn_minus_1 n). 
    unfold moves_def... 
    unfold moves_def... 
      assert (forall k, sub (sup P n ∪ Y) k == sub (((sup M n ∪ Y) ∪ Plus (sup P n ∪ Y)) ∩ √Minus (sup P n ∪ Y)) k). 
        intros.
        assert ({k <= (S n)} + {(S n) < k})...
        inversion a; clear a... 
          rewrite <- Setminus_is_Intersection_Complement. 
          rewrite sub_Setminus. 
          repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
          repeat (rewrite sub_sup_Empty_set || rewrite Empty_set_ident_left)...
          assert (sub Y (S (S n)) == Empty_set). 
            admit. 
          repeat (rewrite H6).
          rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
          subst.
          assert (sub Y k == Empty_set).
            admit.
          admit. 
        assert (Y == sub Y (S n)). admit.
        rewrite H5.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite sub_Setminus. 
        repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        repeat (rewrite sub_sup_Empty_set || rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left)...
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set...
        rewrite H6 in b...
      apply FFF in H5...
      assert (forall k, sub (sup M n ∪ Y) k == sub (((sup P n ∪ Y) ∪ Minus (sup P n ∪ Y)) ∩ √Plus (sup P n ∪ Y)) k). 
        intros.
        assert ({k <= (S n)} + {(S n) < k})...
        inversion a; clear a... 
          rewrite <- Setminus_is_Intersection_Complement. 
          rewrite sub_Setminus. 
          repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
          repeat (rewrite sub_sup_Empty_set || rewrite Empty_set_ident_left)...
          assert (sub Y (S (S n)) == Empty_set). 
            admit. 
          repeat (rewrite H6).
          rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
          subst.
          assert (sub Y k == Empty_set).
            admit.
          admit. 
        assert (Y == sub Y (S n)). 
          admit.
        rewrite H5.
        rewrite <- Setminus_is_Intersection_Complement. 
        rewrite sub_Setminus. 
        repeat (rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)... 
        repeat (rewrite sub_sup_Empty_set || rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left)...
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set...
                rewrite H6 in b...
      apply FFF in H5...

    rewrite Xsing. 
    rewrite Minus_Singleton.
    rewrite DisjUnion.
    repeat (rewrite I_U_dist_l).
    unfold Same_set, Included... exfalso. 
      repeat (basic; intuition). 
    admit. 
    admit.
    inversion H.
    inversion H5...
  Qed.

  Lemma Lemma_3_2_b_0_m :
    forall m, (Lemma_3_2_b_st 0 (S m)).
  Proof with intuition. 
    unfold Lemma_3_2_b_st. 
    intros.
    
    assert (exists z, (sub M 0) == Singleton z).
      apply dim_0_Singleton.
      apply (M_0_Inhabited' M P)... apply H0.
    inversion H2 as [z K]; clear H2.
    
    assert (Finite X) as XFin.
      apply (Cardinal_are_Finite _ _ H)...
    
    assert (PlusMinus X == Singleton z). 
      assert (Finite (PlusMinus X)). 
        apply (Finite_Included'' (Plus X))... 
        unfold PlusMinus, Included... apply In_Intersection in H4... 
      apply all_decidable...
      apply Finite_Empty_or_Inhabited in H2... 
        exfalso. 
      assert (Inhabited (PlusMinus X)). 
        apply (PlusMinus_Inhabited _ 0)... apply Cardinal_Sn in H...
        rewrite H5 in H2. inversion H2...
      apply Included_Singleton... rewrite <- K...
    
    split.

    assert (sup M (0 - 1) == Empty_set) as JA. admit. (* error, sort this out later *)
    assert (sup P (0 - 1) == Empty_set) as JB. admit. (* error, sort this out later *)
    assert ((sub M 0) ∩ √(Plus X) == Empty_set). 
      unfold Same_set, Included...
      exfalso. apply In_Intersection in H5... 
      rewrite K in H7; inversion H7; clear H7.
      assert (In (PlusMinus X) x).
        rewrite <- H5, H2... unfold PlusMinus in H7. apply In_Intersection in H7...
      inversion H5.
    assert (exists w, MinusPlus X == Singleton w). 
      (* Definitely true, not so easy to prove *)
      (* first, use X inhabited and X wellformed to show that MinusPlus is inhabited *)
      (* this all relies on the fact that X is well_formed and of dimension 1 *)
      (* it is unique to dimension 1, this doesn't seem at all easy, check how ross does
         it before bothering to prove it. *) 
      admit.
    inversion H4 as [w E]; clear H4.
    assert (dim w = 0).
      assert (In (MinusPlus X) w). rewrite E...
      unfold MinusPlus in H4. apply In_Intersection in H4...
      inversion H1... apply minus_dim in H11... assert (dim x = 1)...
      rewrite H7 in H11; inversion H11...
    apply (Same_set_is_a_cell (Singleton w) (Singleton w)). 
    unfold is_a_cell...
      exists w...
      exists w...
      unfold moves_def. 
        split; rewrite Plus_Singleton, Minus_Singleton, plus_zero, minus_zero, Empty_set_ident_right, Complement_Empty_set, Full_set_ident_right...
      unfold moves_def. 
        split; rewrite Plus_Singleton, Minus_Singleton, plus_zero, minus_zero, Empty_set_ident_right, Complement_Empty_set, Full_set_ident_right...
     
    rewrite JA, I_U_dist_r, H3, <- E, Empty_set_ident_left, Empty_set_ident_left...

    rewrite JB, I_U_dist_r, H3, <- E, Empty_set_ident_left, Empty_set_ident_left...

    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H5...
      rewrite K in H8. rewrite <- H2 in H8. unfold PlusMinus in H8.
      apply In_Intersection in H8...
      exfalso... 
  Qed. 

  Lemma Lemma_3_2_b :
    forall n m, (Lemma_3_2_b_st n m).
  Proof.
    intros n.
    induction n.
      intros m; destruct m. 
      apply Lemma_3_2_b_n_0.
      apply Lemma_3_2_b_0_m.
    destruct m.
      apply Lemma_3_2_b_n_0.
    apply Lemma_3_2_Step_2'.
    apply Lemma_3_2_Step_3'.
    simpl. 
    rewrite <- (minus_n_O).
    apply IHn.
  Qed.
 
  Lemma all_receptive : (forall M P : Ensemble carrier, is_a_cell (M, P) -> cell_receptive (M, P)).
  Admitted.  

  Lemma Lemma_3_2_c :
    forall n m, (Lemma_3_2_c_st n m).
  Proof.
    intros.
    apply Lemma_3_2_Step_1'.
    apply Lemma_3_2_b.
  Qed.

  Lemma Prop_3_4 :
    forall M P, is_a_cell (M, P) ->
    forall z n, dim z = S n ->
    minus z ⊆ P ->
    Minus M ∩ plus z == Empty_set.
  Admitted.

  Lemma Prop_3_5 :
    forall M P N Q, is_a_cell (M, P) /\ is_a_cell (N, Q) ->
    (forall n m, m < n-1 -> (M == N /\ P == Q /\ P = N)) -> 
    (Minus M ∩ Plus N == Empty_set) /\ is_a_cell (M, N).
  Admitted.

  Lemma Theorem_3_6b :
    forall M P N Q (n: nat), 
      is_a_cell (M, P) -> is_a_cell (N, Q) -> 4 = 4 ->
      Minus (M ∪ P) ∩ Plus (N ∪ Q) == Empty_set.
  Admitted. 

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* mu and pi                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Function mu' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier := 
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => MinusPlus (mu' x (S n)) 
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x. 
      induction (dim x).
        - induction n...
            + inversion teq.
        - induction n0...
            + apply IHn. simpl in teq... simpl in teq0... 
     Qed.

  Definition mu (x : carrier) := fun y => exists n, In (mu' x n) y.

  Function pi' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier := 
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => PlusMinus (pi' x (S n)) 
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x. 
      induction (dim x).
        - induction n...
            + inversion teq.
        - induction n0...
            + apply IHn. simpl in teq... simpl in teq0... 
     Qed.
  
  Definition pi (x : carrier) := fun y => exists n, In (pi' x n) y.
  
  Notation "'<<' x '>>'" := ((mu x), (pi x)) (at level 85).

  Lemma atom_is_a_cell : forall x, is_a_cell (<< x >>).
  Admitted.

  Lemma atom_dim : forall x n, dim x = n -> celldim (<<x>>) n.
  Admitted.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results from definitions                       *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma mu'_Singleton : forall x, (mu' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x. 
    rewrite mu'_equation.
    assert (leb (dim x) (dim x) = true). 
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true). 
      induction (dim x)... 
    rewrite H, H0...
  Qed.

  Lemma mu'_Empty_set : forall n x, S (dim x) <= n -> (mu' x n) = Empty_set.
  Proof with intuition.
    intros... 
    rewrite mu'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H. 
        - induction n0... 
           + inversion H. 
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0... 
  Qed.

  Lemma mu'_MinusPlus : forall n x, S n <= (dim x) -> (mu' x n) = MinusPlus (mu' x (S n)).
  Proof with intuition.
    intros n x... 
    rewrite mu'_equation.
    assert (leb n (dim x) = true). 
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
         simpl in H0... 
    rewrite H0, H1...
  Qed.

  Lemma mu'_ind' : 
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (mu' x (S n)) → P n (MinusPlus (mu' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e... 
       apply beq_nat_false in e0... 
       induction e... 
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Hint Resolve le_not_gt.

  Lemma DDD : forall S, Finite S -> Finite (MinusPlus S). 
  Proof with intuition. 
    intros...
  Qed. 

  Lemma mu'_Finite : forall n x, Finite (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind'...
  Qed.

  Lemma mu'_dim : forall x n y, In (mu' x n) y -> dim y = n. 
  Proof with intuition. 
    intros x n.
    apply mu'_ind'...
     - inversion H...
     - unfold MinusPlus in H1...
       apply In_Intersection in H1... 
       unfold Minus, In at 1 in H2... 
       inversion H2; clear H2... 
       assert (dim x0 = S n0)... 
     - inversion H0...
  Qed.

  Lemma sub_mu : forall x n, sub (mu x) n == mu' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold mu, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply mu'_dim in H...
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply mu'_dim in H...
  Qed.

  Lemma pi'_Singleton : forall x, (pi' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x. 
    rewrite pi'_equation.
    assert (leb (dim x) (dim x) = true). 
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true). 
      induction (dim x)... 
    rewrite H, H0...
  Qed.

  Lemma pi'_Empty_set : forall n x, S (dim x) <= n -> (pi' x n) = Empty_set.
  Proof with intuition.
    intros... 
    rewrite pi'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H. 
        - induction n0... 
           + inversion H. 
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0... 
  Qed.

  Lemma pi'_PlusMinus : forall n x, S n <= (dim x) -> (pi' x n) = PlusMinus (pi' x (S n)).
  Proof with intuition.
    intros n x... 
    rewrite pi'_equation.
    assert (leb n (dim x) = true). 
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n. 
      induction (dim x)... 
        inversion H... 
        induction n0... 
         simpl. apply IHn. apply le_S_n...
         simpl in H0... 
    rewrite H0, H1...
  Qed.

  Lemma pi'_ind' : 
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (pi' x (S n)) → P n (PlusMinus (pi' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e... 
       apply beq_nat_false in e0... 
       induction e... 
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Lemma EEE : forall S, Finite S -> Finite (PlusMinus S). 
  Proof with intuition. 
    intros...
  Qed. 

  Lemma pi'_Finite : forall n x, Finite (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind'...
  Qed.

  Lemma pi'_dim : forall x n y, In (pi' x n) y -> dim y = n. 
  Proof with intuition. 
    intros x n.
    apply pi'_ind'...
     - inversion H...
     - unfold PlusMinus in H1...
       apply In_Intersection in H1... 
       unfold Plus, In at 1 in H2... 
       inversion H2; clear H2... 
       assert (dim x0 = S n0)...
       assert (S (dim y) = dim x0)...
       rewrite H1 in H5...
     - inversion H0...
  Qed.

  Lemma sub_pi : forall x n, sub (pi x) n == pi' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold pi, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply pi'_dim in H...
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply pi'_dim in H...
  Qed.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 4                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Axiom mu_is_tight : forall x n, tight (sub (mu x) n). 
  Axiom pi_is_tight : forall x n, tight (sub (pi x) n). 

  Lemma Finite_eq_decidable : forall T, @Finite carrier T -> forall R, Finite R -> ((T == R) \/ ~(T == R)).
  Proof with intuition.
    intros T TFin.
      induction TFin; intros. 
      - apply Finite_Empty_or_Inhabited in H... 
        right...
        rewrite <- H in H0; inversion H0...
      - assert ((In R x) \/ ~(In R x))...
          apply all_decidable...
        + assert (R == Add (Setminus R (Singleton x)) x).
            apply add_subtract...
          assert (A == (Setminus R (Singleton x)) ∨ (A == (Setminus R (Singleton x)) → False))...
            apply IHTFin...
            apply Setminus_Finite'...
          * left...
            rewrite H4...
          * right...
            apply H4...
            rewrite <- H3...
            unfold Same_set, Included, Setminus...
            unfold In at 1...
            inversion H6; clear H6. apply H; rewrite H7...
            unfold In at 1 in H5...
            unfold Add in H6... apply In_Union in H6... 
        + right... apply H2...  rewrite <- H1... 
      - rewrite H...
  Qed.


  Lemma Theorem_4_1 :
    forall M P n, is_a_cell (M, P) -> celldim (M, P) n ->
    forall u, u ∈ (sub M n) -> ~((M, P) === << u >>) ->
    exists N Q L R m, 
      is_a_cell (N, Q) /\ 
      is_a_cell (L, R) /\
      (m < n) /\ 
      ~(celldim (N, Q) m) /\ 
      ~(celldim (L, R) m) /\  
      ((M, P) === composite m (N, Q) (L, R)).
  Proof with intuition.
    intros M P n cellcond dimcond u udim notatomic.  

    set (Z := (fun m => (n <= m) \/ ((sub M (S m), sub P (S m)) === (sub (mu u) (S m), sub (pi u) (S m))))).
    assert (Inhabited Z) as ZInhab.
      exists (S n)... unfold Z, In at 1...
    assert (exists m, (In Z m /\ forall r, In Z r -> m <= r)) as max_exists.
      apply decidable_nat_have_minimum_le_element...
      unfold decidable, Z, In... 
      assert ({n <= x} + {x < n})...
      assert ((sub M (S x) == sub (mu u) (S x)) \/ ~((sub M (S x) == sub (mu u) (S x))))...
      apply Finite_eq_decidable... apply Finite_sub... apply cellcond. 
        rewrite sub_mu. apply mu'_Finite.
      assert ((sub P (S x) == sub (pi u) (S x)) \/ ~((sub P (S x) == sub (pi u) (S x))))...
      apply Finite_eq_decidable... apply Finite_sub... apply cellcond. 
        rewrite sub_pi. apply pi'_Finite.
      right. intros...
        apply le_not_lt in H2... 
      inversion H2...
      right. intros...
        apply le_not_lt in H1...
      inversion H1...
    inversion max_exists as [m H]; clear max_exists; inversion H as [minZ mmax]; clear H. 
    
    assert (m < n) as mltn. 
      assert ({n <= m} + {m < n})... 
        exfalso.
        apply notatomic...
        assert (celldim (<< u >>) n)... 
          apply atom_dim...
        unfold Same_pair...
          apply (TT (n))... unfold celldim in H. unfold setdim in *... unfold celldim, setdim in *... 
            admit. (* something to do with m being a maximum !HERE *)
          apply (TT (n))... unfold celldim in H. unfold setdim in *... unfold celldim, setdim in *... 
            admit. 

    assert ((sub M (S m)) == (sub (mu u) (S m)) ∪ ((sub M (S m)) ∩ (sub P (S m)))) as Mcond. 
      unfold Z, In in minZ. 
      inversion minZ as [minZa | minZb]; clear minZ.
        exfalso. apply le_not_lt in minZa...
        inversion minZb; clear minZb. 
          unfold Same_set, Included; repeat (basic; intuition)...
    assert ((sub P (S m)) == (sub (pi u) (S m)) ∪ ((sub M (S m)) ∩ (sub P (S m)))) as Pcond. 
      unfold Z, In in minZ. 
      inversion minZ as [minZa | minZb]; clear minZ.
        exfalso. apply le_not_lt in minZa...
        inversion minZb; clear minZb. 
          unfold Same_set, Included; repeat (basic; intuition)...
    assert (Disjoint (sub (mu u) (S m)) (sub M (S m) ∩ sub P (S m))) as JJ. 
      constructor... 
      admit.
    assert (Disjoint (sub (pi u) (S m)) (sub M (S m) ∩ sub P (S m))) as KK'. admit.
  
    assert (Inhabited ((sub M (S m)) ∩ (sub P (S m)))) as MPInhab.
      assert (((sub M (S m)) ∩ (sub P (S m))) == Empty_set \/ Inhabited ((sub M (S m)) ∩ (sub P (S m))))... 
        apply Finite_Empty_or_Inhabited. 
        apply Finite_Intersection... apply Finite_sub... apply cellcond...
        apply all_decidable. apply Finite_sub... apply cellcond...
      exfalso.
      admit. (* implies that sub M (S m) == sub (mu u) (S m)... does that make m not maximal? *)
    inversion MPInhab as [w winMP]; clear MPInhab.
    
    set (X := fun k => triangle_rest (sub M (S m)) k w).
    assert (exists x, (In X x /\ forall r, In X r -> (triangle_rest X r x) -> x = r)) as Xhasmin. 
      refine (minimal_exists' _ _ (S m) _ )... 
      apply (Finite_Included'' (sub M (S m))). apply Finite_sub. apply cellcond.
      unfold X. unfold Included... unfold In at 1 in H... inversion H...
      idtac... 
      unfold X, In. 
      apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold X, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S m)))... 
      unfold X, Included... unfold In in H. inversion H...
    inversion Xhasmin as [x xismin]; clear Xhasmin.

    set (Y := fun k => triangle_rest (sub M (S m)) w k).
    assert (exists x, (In Y x /\ forall r, In Y r -> (triangle_rest Y x r) -> x = r)) as Yhasmax. 
      refine (maximal_exists' _ _ (S m) _ )... 
      apply (Finite_Included'' (sub M (S m))). apply Finite_sub. apply cellcond.
      unfold Y. unfold Included... unfold In at 1 in H1... apply triangle_rest_in_set in H1... 
      idtac... 
      unfold Y, In. 
      apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold Y, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S m)))... 
      unfold Y, Included... unfold In in H1. apply triangle_rest_in_set in H1... 
    inversion Yhasmax as [y yismax]; clear Yhasmax.

    assert ((minus x ⊆ sub M m) /\ (plus y ⊆ sub P m)) as specialcond. 
    split.
      apply (Included_trans _ (sub (MinusPlus M) m))...
        unfold Included...
        assert (dim x = S m) as AA. 
          unfold X, In at 1 in H...  inversion H...
        assert (S (dim x0) = dim x)...
        unfold sub, In at 1...
        unfold MinusPlus; apply In_Intersection... 
          exists x... unfold X, In at 1 in H... inversion H... apply H5... apply H5...
          apply In_Complement... unfold In, Plus in H5. 
          inversion H5; clear H5... 
          assert (triangle_rest X x1 x). 
            apply (tr_trans _ _ x)... unfold X, In at 1... 
            apply (tr_trans _ _ x)... unfold sub, In at 1... assert (S (dim x0) = dim x1)... 
            assert (S (dim x0) = dim x)... rewrite <- H6, H8... 
            exists x0... exists x0... left...  
          assert (x = x1). 
          apply (H0)... unfold X, In at 1... 
          apply (triangle_rest_trans _ _ x)... 
        apply (triangle_rest_Included X)...
        unfold X, Included, In at 1... inversion H8... 
        rewrite <- H8 in H7...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1 M M)...
      apply cellcond. exists P. apply cellcond.
      apply (Included_trans _ (sub (PlusMinus M) m))...
        unfold Included...
        assert (dim y = S m) as AA. 
          unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1... 
        assert (S (dim x0) = dim y)...
        unfold sub, In at 1...
        unfold PlusMinus; apply In_Intersection... 
          exists y... unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1... apply sub_Included in H6... 
          apply In_Complement... unfold In, Minus in H5. 
          inversion H5; clear H5... 
          assert (triangle_rest Y y x1).
            assert (In (sub M (S m)) x1)...
              unfold sub, In at 1... symmetry. rewrite <- AA, <- H4...
            assert (In (Y) x1)...
              unfold Y, In at 1...
              apply (triangle_rest_trans _ _ y)...
              apply (tr_trans _ _ x1)...
              unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...  
              exists x0... left...
            apply (tr_trans _ _ x1)... exists x0...
            left...
          assert (y = x1). 
          apply (H2)... unfold Y, In at 1... 
          apply (triangle_rest_trans _ _ y)... 
        apply (triangle_rest_Included Y)...
        unfold Y, Included, In at 1... apply triangle_rest_in_set in H8... 
        rewrite <- H8 in H7...
        rewrite AA in H4... 
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1_dual M P)...
      apply cellcond. exists M. apply cellcond. 
      
    assert (~(x ∈ (sub (mu u) (S m))) \/ ~(y ∈ (sub (mu u) (S m)))) as ASD. 
      assert (~((x ∈ (sub (mu u) (S m))) /\ (y ∈ (sub (mu u) (S m))))) as Q.
        unfold not...
        assert (is_a_segment (sub (mu u) (S m)) (sub M (S m))).
          apply Prop_1_3...
          rewrite sub_mu. apply mu'_Finite. 
          apply mu_is_tight. 
          pose (well_formed_by_dimension M)...
          apply H... apply cellcond.
          rewrite Mcond...
        apply ZZZb in H...  
        assert (w ∈ sub (mu u) (S m)).
          refine (H9 x y _ w _)...
        inversion JJ.
        apply (H10 w)... 
      assert ((x ∈ sub (mu u) (S m)) \/ ~(x ∈ sub (mu u) (S m))) as DD. 
        apply Finite_are_decidable... 
        rewrite sub_mu. 
        apply mu'_Finite.
      inversion DD; clear DD; [right |left]...

    assert ((x ∈ ((sub M (S m)) ∩ (sub P (S m)))) \/ (y ∈ ((sub M (S m)) ∩ (sub P (S m))))) as xory. 
      inversion ASD as [WER | WER]; clear ASD; [left | right].
        inversion xismin as [QQQ WWW]; clear xismin. 
        assert (In (sub M (S m)) x) as OOO. unfold In, X in QQQ. inversion QQQ...
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
        inversion yismax as [QQQ WWW]; clear yismax. 
        assert (In (sub M (S m)) y) as OOO. unfold In, Y in QQQ. 
        apply triangle_rest_in_set in QQQ... 
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
    clear ASD.

  Ltac splits := 
    match goal with
    | H: _ |- _ /\ _ => split; [idtac | try splits]
    end.
  
    inversion xory; clear xory.
    (* x case *)
    - set (R := (P ∩ (√(Singleton x)))).
      set (L := ((M ∩ √(Singleton x)) ∪ plus x) ∩ √minus x).
      set (Q := ((((sub M m) ∪ (plus x)) ∩ √(minus x))) ∪ (sup P (m-1)) ∪ (Singleton x)).
      set (N := ((sup M m) ∪ ((Singleton x)))).
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      + unfold N, Q. 
        admit. 

      + unfold L, R. 
        admit.

      + unfold N, Q, celldim, setdim in H0...
        assert (dim x <= m).
          apply (H0)...
        assert (dim x = S m)...
          rewrite <- sub_Intersection in H...
        rewrite H8 in H7...

      + unfold L, R, celldim, setdim in H0.
        assert (Finite (sub M (S m))).
          apply Finite_sub... apply cellcond.
        (* somehow, there is an element of (sub M (S m) ∪ sub P (S m)) that is not x *)
        (* if this were not true, then there would be some contradiction on the
           size of m *) 
        assert (Inhabited ((sub M (S m) ∪ sub P (S m)) ∩ √Singleton x)). admit. 
        inversion H8; clear H8...
        assert (dim x0 = S m)...
          apply In_Intersection in H9...
          apply In_Union in H8...
        assert (dim x0 <= m)...
          apply (H0 x0)...
          apply In_Intersection in H9...
          apply In_Union in H10...
          left... apply In_Intersection...
          left... apply In_Intersection... unfold sub, In at 1 in H9...
          apply In_Complement...
          assert (dim x0 = m)...
          rewrite H12 in H8...
          right... apply In_Intersection... unfold sub, In at 1 in H9...
        rewrite H8 in H10... 
       
      + split. 
      
        * unfold N, L...
          assert (dim x = S m) as dimx.
            unfold X, In at 1 in H0... apply triangle_rest_in_set in H0... 
          unfold Same_set, Included...
            assert ({dim x0 <= (S m)} + {(S m) < (dim x0)})... 
            inversion a; clear a... 
              assert ((x0 = x) \/ ~(x0 = x))... apply carrier_decidable_eq.
              right... 
              apply In_Intersection...
              apply In_Intersection...
              left... 
              apply In_Intersection...
              apply In_Complement... inversion H7... 
                apply In_Complement... 
                assert (S (dim x0) = dim x)...
                rewrite dimx, H8 in H10...
              apply In_Complement... assert (dim x0 = m)... rewrite H10 in H8...
              subst. 
              left...
            repeat (basic; intuition)...
              right... apply In_Intersection...
              apply In_Intersection...
              left...
              apply In_Intersection...
              apply In_Complement...
              inversion H12; clear H12...
              subst. assert (dim x0 = S m)...
              apply In_Complement...
                assert (S (dim x0) = dim x)...
                rewrite <- dimx, <- H13 in b...
              apply In_Complement... unfold sub, In at 1 in H12...
            repeat (rewrite <- Setminus_is_Intersection_Complement in H6). 
            repeat (rewrite <- sub_Union in H6 || rewrite <- sub_Setminus in H6). 
            repeat (rewrite    Setminus_is_Intersection_Complement in H6).
            repeat (basic; intuition)...
              unfold sup, In at 1 in H6...
              inversion H6; clear H6; subst...
              unfold sub, In at 1 in H9...
              exfalso. apply H13...
              unfold sub, In at 1...
              assert (S (dim x0) = dim x)...
              rewrite dimx in H12...

        * unfold Q, R... 
          unfold Same_set, Included...
            assert ((x = x0) \/ ~(x = x0))...
              apply carrier_decidable_eq... 
            left. 
              apply In_Intersection...
              apply In_Complement...
              assert (dim x0 = m)... 
              assert (dim x0 = (S m))... 
              rewrite <- H8. 
              unfold X, In at 1 in H0...
              apply triangle_rest_in_set in H0...
              rewrite H10 in H9...
            right... apply In_Intersection... apply In_Complement...
            repeat (rewrite <- Setminus_is_Intersection_Complement in H6). 
            repeat (rewrite sub_Union in H6 || rewrite sub_Setminus in H6).
            repeat (rewrite Setminus_is_Intersection_Complement in H6). 
            repeat (basic; intuition)...
              exfalso. apply H13...
              left; left. apply In_Intersection...
              apply In_Complement... apply H14...
              unfold sub, In at 1 in H12... 
              exfalso. apply H13...
              left; left. apply In_Intersection... right... 
              unfold sub, In at 1...
              assert (dim x = (S m))...
              assert (S (dim x0) = dim x)...
              rewrite H12 in H15...
              apply In_Complement... apply H14...
              unfold sub, In at 1 in H12...
              unfold sup, In at 1 in H6...
              inversion H12; clear H12... rewrite H6 in H10. unfold sub, In at 1 in H10...

      (* y case *)
    - set (N := (M ∩ (√(Singleton y)))).
      set (Q := ((P ∩ √(Singleton y)) ∪ minus y) ∩ √plus y).
      set (L := ((sup M (m-1) ∪ (((sub P m) ∪ (minus y)) ∩ √(plus y))) ∪ (Singleton y))).
      set (R := ((sup P m) ∪ ((Singleton y)))).
      assert (sup (sup M (m - 1) ∪ sub P m) (m - 1) == sup M (m-1)). 
        crush. exfalso. rewrite H7 in H8... apply (qwer'' m)... left... 
      assert ((sub (sup M (m - 1) ∪ sub P m) m) == sub P m).
        crush. exfalso. rewrite H9 in H8... apply (qwer'' m)... right... 
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      (* N and Q case *)
      + unfold N, Q. 
        unfold is_a_cell...
        * pose (M_0_Inhabited' _ _ cellcond). inversion i; clear i. exists x0. 
          split. apply H8. apply In_Complement... inversion H9... 
          assert (dim y = S m)... apply In_Intersection in H...
          assert (dim x0 = 0)... rewrite H10 in *. rewrite H12 in H11... 
          inversion H11. 
        * assert (Inhabited (MinusPlus (Singleton y))). apply (MinusPlus_Inhabited _ m)... 
            apply In_Intersection in H... unfold Included... inversion H... 
            rewrite <- H10... exists y...
          inversion H8. exists x0. rewrite I_U_dist_r. right.
          unfold MinusPlus in H9. rewrite Plus_Singleton, Minus_Singleton in H9...  
        * apply (well_formed_Included M). apply cellcond. apply Intersection_Included_cancel_right...
        * (* ?? *) admit. 
        * rewrite <- Setminus_is_Intersection_Complement...
          apply Setminus_Finite'... apply cellcond.
        * apply Setminus_Finite... rewrite Union_sym.
          apply Finite_Union...
          apply Setminus_Finite... apply cellcond. 
        * unfold moves_def... admit. admit.
        * unfold moves_def... admit. admit.

      (* L and R case *)
      + assert (dim y = S m) as ydim.
          unfold Y, In at 1 in H4. apply triangle_rest_in_set in H4...
        unfold L, R.  
        apply (Same_set_is_a_cell ((sup M (m - 1) ∪ ((sub P m ∪ Minus (Singleton y)) ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P m ∪ Singleton y))... 
        apply (Same_set_is_a_cell ((sup (sup M (m - 1) ∪ sub P m) (m - 1)
        ∪ ((sub (sup M (m - 1) ∪ sub P m) m ∪ Minus (Singleton y))
        ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P m ∪ Singleton y))... 
        apply (Lemma_3_2_c _ 1). 
        apply Cardinality_Singleton_is_one. 
        split. remember (target_is_a_cell m M P cellcond). unfold target in i.
        apply (Same_set_is_a_cell _ _ i). apply Union_sym. reflexivity.
        unfold celldim, setdim...
          inversion H8; clear H8; subst.
          inversion H9; clear H9; subst.
          apply (le_trans _ (m-1))...
          unfold sub, In at 1 in H8...
          rewrite H10; left. 
          apply H9.
        split.
        unfold Included... 
          inversion H8; clear H8; subst.
          unfold In, sub... 
          constructor.
        apply well_formed_Singleton.
        rewrite sub_Union.
        rewrite sub_idemp.
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        unfold Included...
          apply H7...
          unfold PlusMinus in H8. rewrite Plus_Singleton in H8...
          apply In_Intersection in H8...
          trivial. 
        rewrite H0, H1... 
        rewrite (Minus_Singleton y), (Plus_Singleton y)...
        
      + unfold celldim, setdim, N, Q in H2...
          assert (Inhabited ((sub M (S m) ∩ sub P (S m)) ∩ √Singleton y)). 
            (* ?? *) admit.
          inversion H9; clear H9.
          assert (dim x0 <= m).
            apply H2...
            left... 
            repeat (basic; intuition)... unfold sub, In at 1 in H10...
          assert (dim x0 = S m)...
            repeat (basic; intuition)...
          rewrite H11 in H9...
        
      + unfold celldim, setdim, L, R in H2... 
          assert (dim y <= m).
            apply H2...
          assert (dim y = S m)...
            apply In_Intersection in H...
          rewrite H10 in H9...

      + assert (dim y = S m) as ydim.
          unfold Y, In at 1 in H4. apply triangle_rest_in_set in H4...

        split.

        * unfold L, N...
          repeat (rewrite sub_Union).
          rewrite sub_sup_Empty_set.
          assert ( sub (Singleton y) m == Empty_set) as HH. 
            unfold sub, Same_set, Included, In... 
            exfalso. inversion H9; clear H9. rewrite <- H8, ydim in H10...
          rewrite HH. clear HH.
          rewrite Empty_set_ident_left.
          rewrite Empty_set_ident_right.
          assert (sub ((sub P m ∪ minus y) ∩ √plus y) m == ((sub P m ∪ minus y) ∩ √plus y) ) as BB.
            unfold sub at 1, Same_set, Included... 
            unfold In at 1 in H8; inversion H8; assumption.
            unfold In at 1... 
            inversion H8; clear H8; subst.
            inversion H9; clear H9; subst.
            unfold sub, In in H8...
            apply minus_dim in H8. rewrite ydim in H8.
            inversion H2... 
          rewrite BB.
          set (KK := ((sub P m ∪ minus y) ∩ √plus y)).
          unfold Same_set, Included... 
            assert (x0 = y ∨ x0 ≠ y) as OP. 
              apply carrier_decidable_eq.
            inversion OP; [right | left]; clear OP...
            subst. 
            apply In_Intersection... 
            apply In_Complement; unfold not... 
            unfold KK in H9. rewrite <- BB in H9.
            unfold sub at 1, In at 1 in H9... rewrite ydim in H11. 
            apply (n_Sn m)... 
            apply In_Intersection... 
            apply In_Complement; unfold not...
            inversion H10; subst...
            apply In_Union in H8...
            apply In_Intersection in H9...
            apply In_Intersection in H9...
            apply In_Union in H8...
            apply In_Union in H9...
            unfold sup, In at 1 in H8... 
            exfalso. unfold Complement, In at 1 in H10... 
            inversion H9; clear H9. rewrite <- H8.
            unfold Y, In at 1 in H4. apply triangle_rest_in_set in H4... apply H11. trivial. 

        * unfold Q, R.
          assert (forall k, (sub P k) ==
            sub (((((P ∩ √Singleton y) ∪ minus y) ∩ √plus y)
            ∩ √sub (((P ∩ √Singleton y) ∪ minus y) ∩ √plus y) m)
            ∪ (sup P m ∪ Singleton y)) k).
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement). 
          repeat (rewrite sub_Union || rewrite sub_Setminus). 
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_sup_cancel k m) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (Setminus_Empty_set) || 
                  rewrite (Empty_set_ident_left) || 
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)... 
          assert (m = k) as K; intuition; rewrite K in a... 
          assert (m = k) as K; intuition; rewrite K in a... 
          rewrite <- H8 in a...
          rewrite <- b in *.
          repeat (rewrite (sub_idemp k) || 
                  rewrite (sub_plus y k) || 
                  rewrite (sub_minus y k) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite (sub_idemp k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)... 
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left.
          rewrite sub_sup_cancel...
          rewrite H8 in ydim... 
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (sub_Singleton y k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set m k) ||
                  rewrite Setminus_Empty_set); try (rewrite b)... 
          apply Add_Setminus_Singleton. 
            apply carrier_decidable_eq. 
            apply In_Intersection in H... 
          rewrite ydim in H8... rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set m k) || 
                  rewrite (sub_plus_Empty_set y k) || 
                  rewrite (sub_minus_Empty_set y k) || 
                  rewrite (sub_Singleton_Empty_set y k) || 
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set m k) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in *)... 
          rewrite    H8 in b... 
          rewrite    H8 in b...
          apply sub_Same_set' in H8... 
 Qed.

End ParityComplexTheory.                                    





