
(* Written by Mitchell Buckley 13/06/2014 *)

Require Import Ensembles.
Require Import myFiniteDefs.
Require Import Relations.
Require Import mySetoids.
Require Import Utf8_core.
Require Import Max Le.
Require Import Arith.
Require Import Setoid.
Require Import Recdef.
Require Import PreparityComplexes.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Parity Complex Definitions                           *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Module Type ParityComplex.

  Declare Module C : PreParity.
  Import C.
  Module PPT := PreParityTheory C.
  Import PPT.

  Axiom axiom1 :
    forall (x : carrier),
      Union (Plus (plus x)) (Minus (minus x)) == Union (Plus (minus x)) (Minus (plus x)).

  Axiom axiom2a :
    forall x, well_formed (plus x).

  Axiom axiom2b :
    forall x, well_formed (minus x).

  Axiom axiom3a:
    forall x y : carrier,
      triangle x y -> triangle y x -> x = y.

  Axiom axiom3b:
    forall x y z : carrier,
    triangle x y ->
    (~ (In (plus z) x /\ In (minus z) y) /\ ~ (In (plus z) y /\ In (minus z) x)).

  Hint Resolve axiom2a axiom2b.

End ParityComplex.

Module ParityComplexTheory (M : ParityComplex).

  Import M.
  Import C.
  Import PPT.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma triangle_rest_dec : 
    forall T, 
      Finite T -> 
      forall x z, (triangle_rest T z x \/ ~(triangle_rest T z x)).
  Proof with intuition.
   intros T TFin. 
   assert (exists n, Cardinal T n) as K.
   apply Cardinality_exists... 
   inversion K as [n TCard]; clear K. 
   revert n T TFin TCard. 
   refine (strong_induction _ _ _)...
     - right... 
       apply Cardinality_zero_Empty_set in TCard. 
       rewrite TCard in H...
       apply triangle_rest_in_set in H...
     - set (R := fun r => less z r /\ In T r).
       assert (Finite R) as RFin. 
         apply (Finite_Included'' T)... 
         unfold R, Included... unfold In at 1 in H0...
         assert ((less z x0) \/ ~(less z x0))...
         apply less_decidable. 
         left... unfold R, In at 1... 
         right... unfold R, In at 1 in H1...
       assert (exists n, Cardinal R n) as J.
       apply Cardinality_exists... 
       inversion J as [k RCard]; clear J...
       assert (decidable T) as Tdec.
         apply Finite_are_decidable...       
       assert ((In T x) \/ ~(In T x))... 
         apply Tdec.
       assert ((In T z) \/ ~(In T z))... 
         apply Tdec.
       assert ((z = x) \/ ~(z = x))... 
         apply carrier_decidable_eq.       
       left. 
       rewrite H3; left...
                     
       destruct k. 
       + right...
         inversion H0...
         assert (In R y).
           unfold R, In at 1...
           apply triangle_rest_in_set in H6... 
         apply Cardinality_zero_Empty_set in RCard. 
         rewrite RCard in H9... 
       + set (T' := Setminus T (Singleton z)). 
         assert (Finite T') as T'Fin. 
           unfold T'... 
           rewrite Setminus_is_Intersection_Complement. 
           apply Setminus_Finite...  
         set (Q := fun w => triangle_rest T' w x).
         assert (Finite Q) as QFin. 
           apply (Finite_Included'' T)... 
           unfold Q, Included, In at 1...
           apply triangle_rest_in_set in H0...
           unfold T', In at 1 in H4... inversion H4... 
           assert ((x0 = z) \/ ~(x0 = z)). 
             apply carrier_decidable_eq... 
           idtac... 
           right... 
           rewrite H5 in H4.
           assert (In T' z). 
             unfold Q, In at 1 in H4... 
             apply triangle_rest_in_set in H4... 
           unfold T', In at 1 in H6...
           inversion H6...
           assert (triangle_rest T' x0 x ∨ (triangle_rest T' x0 x → False)). 
             apply (H n)...
             unfold T'. apply (Cardinal_Setminus carrier_decidable_eq (S n))... 
           idtac...  
         assert (Finite (Intersection R Q)).
           apply Finite_Intersection...
         apply (Finite_Empty_or_Inhabited) in H0...
         * right...
           inversion H0...
            subst.
           assert (In Empty_set y)...
             rewrite <- H4.
             apply In_Intersection...
             unfold R, In at 1...
             apply triangle_rest_in_set in H7... 
             unfold Q, In at 1...         
             assert (triangle z y)...
             right with y... left...
             
             assert (~(z = y)).
               intuition. rewrite H9 in H6; apply less_irrefl in H6...
             clear H6.
             induction H7...
               left...
               unfold T', Setminus...
               right with y...
               unfold T', Setminus, In...
               apply H11...
               apply clos_rt_rt1n_iff. 
               apply clos_rt_rtn1_iff. right with x...
               apply clos_rt_rtn1_iff. 
               apply clos_rt_rt1n_iff. apply H8.
               rewrite H12 in *; clear H12.
               apply H9; apply axiom3a... right with y... left...

         * left... 
           inversion H4; clear H4.
           apply In_Intersection in H0... 
           unfold R, In at 1 in H4.
           unfold Q, In at 1 in H5.
           right with x0... 
           apply (triangle_rest_Included T')...
           unfold T'... 
           apply Setminus_Included. 

       + right... apply H2... apply triangle_rest_in_set in H0... 
       + right... apply H1... apply triangle_rest_in_set in H0... 
  Qed.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma weird_lemma_1 : forall X Y n k,
   Included X (sub Full_set (S n)) ->
   Included Y (sup Full_set (S k)) ->
    ~(n <= k) -> (forall y, In X y /\ In Y y -> False).
  Proof with intuition.
    intros...
    assert (dim y = n)...
    assert (dim y <= k)...
    rewrite H2 in H5...
  Qed.

  Lemma well_formed_sup : forall R n, well_formed R -> well_formed (sup R n).
  Proof with intuition.
    intros.
    apply (well_formed_Included R)...
  Qed.

  Lemma well_formed_sub : forall R n, well_formed R -> well_formed (sub R n).
  Proof with intuition.
    intros.
    apply (well_formed_Included R)...
  Qed.

  Lemma minimal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set (S n))
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X y m) -> m = y).
  Proof with intuition.   
    refine (strong_induction _ _ _)...
  
    - apply Cardinality_one_Singleton in H.
      inversion H; clear H.
      exists x... rewrite H1...
   
    - assert (Inhabited X).
        apply Cardinal_Sn in H0...
      inversion H2; clear H2.
  
      set (Z := (fun y => triangle_rest X y x)).

      assert (Z ⊆ X) as SS.
        unfold Z, Included, In at 1... inversion H2...

      assert (Finite Z /\ Inhabited Z).
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0...
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0...
        exists x... unfold Z, In at 1... left...

      assert (exists k, Cardinal Z (S k)) as K.
        apply Finite_Inhabited_Cardinal_Sn...
        inversion K as [k L]; clear K...
   
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L...
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n).
          assert (S (S k) <= S (S n))...
            refine (Cardinal_le carrier_decidable_eq Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n...

        inversion H2; clear H2.
   
        * assert (X == Z).
            apply (Cardinal_eq_Included_Same_set carrier_decidable_eq (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧
             (∀ y : carrier, y ∈ W → triangle_rest W y m → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply (Cardinal_Setminus carrier_decidable_eq (S (S k)))... rewrite H6...
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...

          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ).
            apply axiom3a. apply (rest_implies_full X). rewrite H12...
            apply (rest_implies_full X). assert (In X maxZ)... apply H7. rewrite H2 in H11...
          rewrite <- H11 in H7...
          unfold W, In at 1, Setminus in H7...
          induction H10...
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear x0 H15.
            assert (z = x).
            apply axiom3a. apply (rest_implies_full X). assert (In Z z)...
            rewrite <- H2... apply triangle_rest_in_set in H12...
            apply (rest_implies_full X). apply (tr_trans _ _ y)...
            rewrite H13 in H7.
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
         
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z y m → m = y)) as M.
          refine (H (S k) _ _ _ n0 _ )... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          induction H10. 
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ z)...
            apply (tr_trans _ _ y)...
  Qed.

  Lemma maximal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set (S n))
      -> exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y).
  Proof with intuition.  
    refine (strong_induction _ _ _)...
  
    - apply Cardinality_one_Singleton in H.
      inversion H; clear H.
      exists x... rewrite H1...
   
    - assert (Inhabited X).
        apply Cardinal_Sn in H0...
      inversion H2; clear H2.
  
      set (Z := (fun y => triangle_rest X x y)).

      assert (Z ⊆ X) as SS.
        unfold Z, Included, In at 1...
        apply triangle_rest_in_set in H2...

      assert (Finite Z /\ Inhabited Z).
        split. apply (Finite_Included'' X)... apply Cardinal_are_Finite in H0...
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0...
        exists x... unfold Z, In at 1... left...

      assert (exists k, Cardinal Z (S k)) as K.
        apply Finite_Inhabited_Cardinal_Sn...
        inversion K as [k L]; clear K...
   
      destruct k...

      + exists x...
        assert (In Z y)...
        assert (In Z x)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L...
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n).
          assert (S (S k) <= S (S n))...
            refine (Cardinal_le carrier_decidable_eq Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n...

        inversion H2; clear H2.
   
        * assert (X == Z).
            apply (Cardinal_eq_Included_Same_set carrier_decidable_eq (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧
             (∀ y : carrier, y ∈ W → triangle_rest W m y → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply (Cardinal_Setminus carrier_decidable_eq (S (S k)))... rewrite H6...
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...

          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ).
            apply axiom3a.
            apply (rest_implies_full X). assert (In X maxZ)... apply H7.
            rewrite H2 in H11...
            apply (rest_implies_full X). rewrite H12...
          rewrite <- H11 in H7...
          unfold W, In at 1, Setminus in H7...
          apply triangle_rest_equiv in H10...
          apply triangle_rest_equiv.
          induction H10...
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear z H15.
            assert (x0 = x).
            apply axiom3a. apply (rest_implies_full X). assert (In Z x0)...
            rewrite <- H2...
            apply triangle_rest_equiv in H12.
            apply triangle_rest_in_set in H12...
            apply triangle_rest_equiv.
            right with y...
            apply (rest_implies_full X).
            assert (In Z x0)... rewrite <- H2.
            apply triangle_rest_equiv in H12. apply triangle_rest_in_set in H12...
            rewrite H13 in H7.
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...
         
          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z m y → m = y)) as M.
          refine (H (S k) _ _ _ n0 _)... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (In Z y)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          apply triangle_rest_equiv in H10.
          apply triangle_rest_equiv.
          induction H10. 
            left...
            assert (In Z y).
            unfold Z, In at 1... apply (triangle_rest_trans X _ x0)...
            apply triangle_rest_equiv...
            right with y...
  Qed.

  Lemma minimal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X ->
         ∀ n : nat,
         X ⊆ sub Full_set (S n) ->
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X y m → m = y).
  Proof with intuition.
    intros X H1.
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn...
    inversion H; clear H.
    apply (minimal_exists x)...
  Qed.

  Lemma maximal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X ->
         ∀ n : nat,
         X ⊆ sub Full_set (S n) ->
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X m y → m = y).
  Proof with intuition.
    intros X H1.
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn...
    inversion H; clear H.
    apply (maximal_exists x)...
  Qed.

  Lemma wf_maximal_exists :
    forall X n, Finite X /\ Inhabited X /\ (X ⊆ sub Full_set (S (S n))) ->
      well_formed X ->
        exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    idtac...
        unfold well_formed in H0...
        inversion H; clear H...
        set (Z := fun s => triangle_rest X x s).
        assert (Finite Z /\ Inhabited Z)...
          apply (Finite_Included'' X)...
          unfold Z, Included, In at 1... apply triangle_rest_in_set in H...
          assert ((triangle_rest X x x0) \/ ~(triangle_rest X x x0))...
            apply triangle_rest_dec...
          exists x... unfold Z, In at 1... left...
        assert (∃ m : carrier, m ∈ Z ∧ (∀ y : carrier, y ∈ Z → triangle_rest Z m y → m = y)).
          refine (maximal_exists' _ _ (S n) _ )...
          apply (Included_trans _ X)... unfold Z. crush. apply triangle_rest_in_set in H...
          unfold Z, Included...
        inversion H as [m K]; clear H.
        exists m...
        unfold Z, In at 1 in H...
        apply triangle_rest_in_set in H...
        constructor...
        apply In_Intersection in H8...
        inversion H10; clear H10...
        assert (less m x1).
          exists x0...
        assert (m = x1).
          apply H7...
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          right with x1... left...
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          rewrite H12 in H8.
          inversion H8... apply In_Intersection in H13...
  Qed.

  Lemma PlusMinus_Inhabited :
    forall X n,
      Included X (sub Full_set (S (S n))) ->
      Finite X ->
      Inhabited X ->
      Inhabited (PlusMinus X).
  Proof with intuition.
    intros...
    assert (Finite (PlusMinus X))...
    apply Finite_Empty_or_Inhabited in H2...
    exfalso. rename H3 into H2.
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X m y) -> m = y)).
      refine (maximal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (plus max)).
      apply plus_Inhabited. apply H in H2. subsuptac... apply eq_add_S in H6... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d).
    apply H3.
    unfold PlusMinus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Plus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less max r). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ r)... left...
    rewrite H9 in H7; unfold less in H7...
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)...
    idtac...
  Qed.

  Lemma MinusPlus_Inhabited :
    forall X n,
      Included X (sub Full_set (S (S n))) ->
      Finite X ->
      Inhabited X ->
      Inhabited (MinusPlus X).
  Proof with intuition.
    intros...
    assert (Finite (MinusPlus X))...
    apply Finite_Empty_or_Inhabited in H2...
    exfalso. rename H3 into H2.
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X y m) -> m = y)).
      refine (minimal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (minus max)).
      apply minus_Inhabited. apply H in H2. subsuptac... apply eq_add_S in H6... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d).
    apply H3.
    unfold MinusPlus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Minus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less r max). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ max)... left...
    rewrite H9 in H7; unfold less in H7...
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)...
    idtac...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 1                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_1_1 :
    forall x,
    (Plus (plus x)) ∩ (Minus (minus x)) == (Empty_set) == (Plus (minus x)) ∩ (Minus (plus x))
    /\
    (MinusPlus (minus x)) == Intersection (Minus (minus x)) (Minus (plus x)) == (MinusPlus (plus x))
    /\
    (PlusMinus (minus x)) == Intersection (Plus (minus x)) (Plus (plus x))   == (PlusMinus (plus x)).
  Proof with repeat basic; auto.
    remember axiom3b as axiom3b. clear Heqaxiom3b.
    assert (H: forall x y, (In (Plus (plus x)) y /\ In (Minus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus, In in H0. 
      unfold Minus, In in H1...
      rename x0 into v. rename x1 into w.
      assert (less w v).
        unfold less. refine (Inhabited_intro  _ _ u _)...
      assert (triangle w v).
        right with v...  left...
      apply (axiom3b _ _ x) in H4...

    assert (K: forall x y, (In (Minus (plus x)) y /\ In (Plus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus in H2. unfold In in H2.
      unfold Minus in H1. unfold In in H1...
      rename x0 into v. rename x1 into w.
      assert (less v w).
        unfold less. refine (Inhabited_intro _ _ u _)...
      assert (triangle v w).
        right with w...
        left...
      apply (axiom3b _ _ x) in H5...

    intros; split; split.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (H x x0)...
    symmetry.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (K x x0)...

    split; unfold MinusPlus, Same_set, Included... rename x0 into y.
    assert (In (Union (Plus (minus x)) (Minus (plus x))) y).
      rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (K x x0)...

    unfold Same_set, Included...
    apply In_Complement... apply (H x x0)...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...

    split; unfold PlusMinus, Same_set, Included...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (H x x0)...
   
    unfold Same_set; unfold Included...
    apply In_Complement... apply (K x x0)...
    assert (In (Union (Plus (minus x)) (Minus (plus x))) x0).
    rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0...
  Qed.

  Lemma Prop_1_2 :
    forall u v x,
    triangle u v ->
    In (plus x) v ->
    (minus u) ∩ (Plus (minus x)) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Plus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less w u).
         exists x0...
       assert (triangle w v).
         right with u...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_2_dual :
       forall u v x : carrier,
       triangle v u -> v ∈ minus x -> plus u ∩ Minus (plus x) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Minus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less u w).
         exists x0...
       assert (triangle v w).
         unfold triangle.
         apply clos_rt_rt1n_iff.
         apply clos_rt_rtn1_iff.
         refine (Relation_Operators.rtn1_trans _ _ v u w _ _)...
         apply clos_rt_rtn1_iff.
         apply clos_rt_rt1n_iff...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_3 :
    forall R S', Finite R ->
      tight R -> well_formed S' -> R ⊆ S' -> is_a_segment R S'.
  Proof with repeat basic; auto.
    unfold is_a_segment.
    unfold tight.
    unfold well_formed.
    unfold triangle.
    intros R S' RFin...
    assert (exists m, (dim x = S m)) as K.
      inversion H4... apply plus_dim in H8. exists (dim x0). auto. 
    rename x into w. rename y into u. rename z into v.
    assert (dim w = dim u) as J. apply equal_dim. unfold triangle.
      right with u... left...
    inversion H4 as [y]...
    assert (minus u ∩ PlusMinus R == Empty_set) as L.
      apply (H u v).
      apply (rest_implies_full S')...
      assumption. 
    assert (~(In (PlusMinus R) y)) as M.
      unfold not; intros... assert (In (Empty_set) y).
      rewrite <- L... inversion H11. unfold not in M.
    assert (In (Plus R) y) as N.
      unfold Plus. unfold In. exists w...
    assert (In (Minus R) y) as P.
      assert (y ∈ Minus R \/ ~(y ∈ Minus R)).
        apply all_decidable...
      inversion H0. assumption. exfalso. apply M.
      unfold PlusMinus...
    inversion P as [z]...
    assert (u = z).
      refine (H3 _ _ _ x _ _ _)...  
      assert (forall T u' v', In T v' -> triangle_rest T u' v' -> In T u') as Q...
        inversion H13...
      apply (Q _ u v)...
      rewrite <- J. apply H8.
      apply minus_dim in H12. rewrite <- H12. rewrite <- H8.
      apply plus_dim in H9...
      unfold perp in H0...
      apply Disjoint_Intersection_condition in H14.
      inversion H14. apply (H0 y)...
      rewrite H0...
  Qed.

  Lemma xplus_is_tight :
    forall x, tight (plus x).
  Proof with repeat basic; auto.
    unfold tight; intros.
    assert (Intersection (minus u) (Plus (minus x)) == Empty_set) as A.
      apply (Prop_1_2 u v)...
    assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as B.
      apply (Prop_1_1 x).
    rewrite <- B.
    rewrite <- Intersection_trans.
    rewrite A.
    unfold Same_set, Included; split; intros... inversion H1.
  Qed.

  (* Section 2 *)
 
  Lemma Observation_p322 :
    forall (T Z : Ensemble carrier),
    well_formed (Union T Z) ->
    Disjoint T Z ->
    Perp T Z.
  Proof with repeat basic; auto.
    intros T Z WF Disj. remember (Union T Z) as S'.
    unfold well_formed in WF...
    rename H into WF0.
    rename H0 into WFSn.
    rename H1 into Disj.
    unfold Perp...

    apply Disjoint_Intersection_condition. constructor. unfold not in *.
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Plus in PT. unfold In in PT.
    unfold Plus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (x0 = x1).
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left...
    apply H. assumption.
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H6.
    inversion H6 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...

    apply Disjoint_Intersection_condition. constructor. unfold not in *.
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Minus in PT. unfold In in PT.
    unfold Minus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (x0 = x1).
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left...
    apply H. assumption.
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H7.
    inversion H7 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Cells                                                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

    Definition Same_pair (A B: Ensemble carrier * Ensemble carrier) : Prop.
  inversion A as [M  P ].
  inversion B as [M' P'].
  exact (M == M' /\ P == P').
  Defined.

  Hint Unfold Same_pair.

  Notation " F === G" := (Same_pair F G) (at level 89).

  Definition is_a_cell (G : Ensemble carrier * Ensemble carrier) : Prop.
  inversion G as [M P].
  exact ( Inhabited M  /\ Inhabited P /\
    well_formed M /\ well_formed P /\
    Finite M /\ Finite P /\
    (M moves M to P) /\ (P moves M to P)).
  Defined.

  Definition celldim (G : Ensemble carrier * Ensemble carrier) (n : nat) : Prop.
    inversion G as [M P].
    exact (setdim (Union M P) n).
  Defined.

  Definition source (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sup M (S n) , sub M (S n) ∪ sup P n).
  Defined.

  Definition target (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sub P (S n) ∪ sup M n , sup P (S n) ).
  Defined.

  Definition composable (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Prop :=
    target n A === source n B.

  Definition composite (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
   inversion A as [M P].
   inversion B as [N Q].
   exact ((M ∪ (N ∩ √(sub N (S n)))), ((P ∩ √(sub P (S n))) ∪ Q)).
  Defined.

  Definition receptive (S : Ensemble carrier) : Prop :=
    (forall x, (Plus (minus x)) ∩ (Plus (plus x)) ⊆ S ->
       (Inhabited (S ∩ (Minus (minus x))) -> False) ->
       (Inhabited (S ∩ (Minus (plus x))) -> False))  /\
    (forall x, (Minus (plus x)) ∩ (Minus (minus x)) ⊆ S ->
       (Inhabited (S ∩ (Plus (plus x))) -> False) ->
       (Inhabited (S ∩ (Plus (minus x))) -> False)).

  Add Parametric Morphism : (receptive) with
    signature (@Same_set carrier) ==> (iff) as is_a_cell_Same_set.
  Proof with intuition.
    unfold receptive.
    intros.
    split; intros K; inversion K as [A B]; clear K.
      split; intros z; rewrite <- H; [apply (A z) | apply (B z)].
      split; intros z; rewrite    H; [apply (A z) | apply (B z)].
  Qed.

  Definition cell_receptive (G : Ensemble carrier * Ensemble carrier) : Prop.
    inversion G as [M P].
    exact (receptive M /\ receptive P).
  Qed.

  Hint Unfold is_a_cell.

  Definition is_a_cell' (S T : Ensemble carrier) := is_a_cell (S, T).

  Hint Unfold is_a_cell'.

  Add Parametric Morphism : (is_a_cell') with
    signature (@Same_set carrier) ==> (@Same_set carrier) ==> (iff) as receptive_Same_set.
  Proof with intuition.
    intuition.
    symmetry in H.
    symmetry in H0.
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H...
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H).
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...

    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H...
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H).
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
  Qed.

  Lemma Same_set_is_a_cell : forall S T,
    is_a_cell (S, T) -> forall S' , S == S' -> forall T', T == T' -> is_a_cell (S', T').
  Proof.
    intros.
    fold (is_a_cell' S T).
    fold (is_a_cell' S' T').
    rewrite <- H0, <- H1.
    intuition.
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma receptive_by_dimension  : forall T, receptive T -> (forall n, receptive (sub T n)).
  Proof with intuition. 
    unfold receptive.
    intros...
    + apply (H0 x)...
      - apply Included_trans with (sub T n)...
      - apply H2.
        inversion H4; exists x0.
        repeat (basic; intuition)...
        unfold sub, In at 1...
        assert (dim x = S n).
          inversion H3.
          apply In_Intersection in H5...
          assert (S (dim x1) = n)...
          inversion H9; clear H9...
          assert (S (dim x1) = dim x2)...
          assert (S (dim x2) = dim x )...
          rewrite <- H10, H5 in H12...
        inversion H7; clear H7...
        assert (S (dim x1) = dim x )...
        assert (S (dim x0) = dim x1)...
        rewrite H5 in H8.
        assert (dim x1 = n)...
        rewrite H11 in H10...
      - inversion H3; clear H3...
        exists x0...
        repeat (basic; intuition).
    + apply (H1 x)...
      - apply Included_trans with (sub T n)...
      - apply H2.
        inversion H4; exists x0.
        repeat (basic; intuition)...
        unfold sub, In at 1...
        assert (dim x = S n).
          inversion H3.
          apply In_Intersection in H5...
          assert (S (dim x1) = n)...
          inversion H9; clear H9...
          assert (S (dim x1) = dim x2)...
          assert (S (dim x2) = dim x )...
          rewrite <- H10, H5 in H12...
        inversion H7; clear H7...
        assert (S (dim x1) = dim x )...
        assert (S (dim x0) = dim x1)...
        rewrite H5 in H8.
        assert (dim x1 = n)...
        rewrite H11 in H10...
      - inversion H3; clear H3...
        exists x0...
        repeat (basic; intuition).
  Qed.

  Lemma receptive_by_dimension'  : 
      forall T, (forall n, receptive (sub T n)) -> receptive T.
  Proof with intuition. 
    unfold receptive.
    intros...
    - inversion H2; clear H2.
      assert (S (S (dim x0)) = dim x)...
        apply In_Intersection in H3...
        inversion H4...
        assert (S (dim x0) = dim x1)...
        rewrite H3...
      specialize H with (S (dim x0))... 
      apply (H4 x)...
      + unfold sub, Included, In at 2...
        apply In_Intersection in H...
        inversion H6... 
        assert (S (dim x1) = dim x2)...
        assert (S (dim x2) = dim x )...
        rewrite <- H2 in H10; inversion H10...
      + apply H1. 
        apply (Inhabited_Included (sub T (S (dim x0)) ∩ Minus (minus x)))...
        unfold Included; repeat (basic; intuition).
      + exists x0... 
        repeat (basic; intuition)...
    - inversion H2; clear H2.
      assert (S (S (dim x0)) = dim x)...
        apply In_Intersection in H3...
        inversion H4...
        assert (S (dim x0) = dim x1)...
        rewrite H3...
      specialize H with (S (dim x0))... 
      apply (H5 x)...
      + unfold sub, Included, In at 2...
        apply In_Intersection in H...
        inversion H6... 
        assert (S (dim x1) = dim x2)...
        assert (S (dim x2) = dim x )...
        rewrite <- H2 in H10; inversion H10...
      + apply H1. 
        apply (Inhabited_Included (sub T (S (dim x0)) ∩ Plus (plus x)))...
        unfold Included; repeat (basic; intuition).
      + exists x0... 
        repeat (basic; intuition)...
  Qed. 

  Lemma Empty_set_moves : forall M, Empty_set moves M to M.
  Proof with intuition.
    intros...
    unfold moves_def...
    rewrite <- Setminus_is_Intersection_Complement.
    rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
    rewrite <- Setminus_is_Intersection_Complement.
    rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
  Qed.

  Lemma cell_has_dim : forall M P, is_a_cell (M, P) -> exists m, celldim (M, P) m.
  Proof with repeat basic; auto.
    intros.
    unfold is_a_cell in H...
    assert (Finite (Union M P)).
    apply Finite_Union.
    apply all_decidable...
    assumption.
    assumption.
    apply Finite_carrier_have_max_dim_element in H6.
    inversion H6 as [m]; clear H6...
    exists (dim m).
    unfold celldim.
    unfold setdim.
    intros...
    inversion H8; apply H9...
    inversion H0.
    apply (Inhabited_intro _ _ x).
    left...
  Qed.

  Lemma target_dim : forall M P, is_a_cell (M, P) -> forall m,
    (celldim (target m (M, P)) m).
  Proof with intuition.
    intros...
    unfold target, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (S (dim x)))...
  Qed.

  Lemma source_dim : forall M P, is_a_cell (M, P) -> forall m,
    celldim (source m (M, P)) m.
  Proof with intuition.
    intros...
    unfold source, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (S (dim x)))...
  Qed.

 Lemma cell_dim_n_property :
    forall M P, is_a_cell (M, P) -> forall n, celldim (M, P) n -> sub M (S n) == sub P (S n).
  Proof with intuition.
    intros M P K n J.
    unfold is_a_cell in K... unfold moves_def in *...
    unfold sub, Same_set, Included, In...

    fold (In P x). rewrite H6.
    repeat basic. left... apply In_Complement. unfold not...
    unfold In, Minus in H7. inversion H7; clear H7... apply minus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...

    fold (In M x). rewrite H9.
    repeat basic. left... apply In_Complement. unfold not...
    unfold In, Plus in H7. inversion H7; clear H7... apply plus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...
  Qed.    

  Lemma M_n_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        Inhabited (sub M (S (S n))) ->
        Inhabited (sub M (  (S n))).
  Proof with intuition.
    intros...

    assert (exists m, In (sub M (S (S n))) m /\ (forall y, In (sub M (S (S n))) y -> (triangle_rest (sub M (S (S n))) y m) -> (m = y))).
      refine (minimal_exists' _ _ (S n) _)...
      refine (Finite_sub M _ _). apply H.
      unfold sub, Included... unfold In at 1. unfold In at 1 in H1...
    inversion H1 as [w J]; clear H1...

    assert ( MinusPlus (sub M (S (S n))) ⊆ sub M (S n)).
      assert (MinusPlus M ⊆ M).
        unfold is_a_cell in H...
        apply Prop_2_1...
        exists P...
      unfold MinusPlus.
      rewrite <- Setminus_is_Intersection_Complement.
      repeat (rewrite <- sub_Minus || rewrite <- sub_Plus || rewrite <- sub_Setminus).
      rewrite    Setminus_is_Intersection_Complement.
      fold (MinusPlus M).
      apply sub_Included_compat...

    assert (Finite (sub M (S n))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso.
    assert (MinusPlus (sub M (S (S n))) == Empty_set).
      apply (Included_Empty_set _ (sub M (S n)))...
    assert (forall x, In (Minus (sub M (S (S n)))) x -> (In (Plus (sub M (S (S n))))) x)...
      assert (x ∈ Plus (sub M (S (S n))) \/ ~(x ∈ Plus (sub M (S (S n)))))...
        apply all_decidable...
        apply Plus_Finite. apply Finite_sub... apply H.
      exfalso.
      assert (In (MinusPlus (sub M (S (S n)))) x); unfold MinusPlus...
      rewrite H4 in H7. inversion H7...
    assert (Inhabited (minus w))...
      apply minus_Inhabited. assert (dim w = (S n))... unfold sub in H1... rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Plus (sub M (S (S n)))).
      apply H6... exists w...
    unfold Plus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less z w).
      unfold less. exists p...
    assert (w = z).
      apply H2... apply (tr_trans _ _ w)... left...
    subst. unfold less in H9...
  Qed.

  Lemma P_n_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        Inhabited (sub P (S (S n))) ->
        Inhabited (sub P (  (S n))).
  Proof with intuition.
    intros...

    assert (exists m, In (sub P (S (S n))) m /\ (forall y, In (sub P (S (S n))) y -> (triangle_rest (sub P (S (S n))) m y) -> (m = y))).
      refine (maximal_exists' _ _ (S n) _)...
      refine (Finite_sub P _ _).
      apply H.
    inversion H1 as [w J]; clear H1...
   
    assert ( PlusMinus (sub P (S (S n))) ⊆ sub P (S n)).
      assert (PlusMinus P ⊆ P).
        unfold is_a_cell in H...
        apply Prop_2_1_dual...
        exists M...
      unfold PlusMinus.
      rewrite <- Setminus_is_Intersection_Complement.
      repeat (rewrite <- sub_Minus || rewrite <- sub_Plus || rewrite <- sub_Setminus).
      rewrite    Setminus_is_Intersection_Complement.
      fold (PlusMinus M).
      apply sub_Included_compat...

    assert (Finite (sub P (S n))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso.
    assert (PlusMinus (sub P (S (S n))) == Empty_set).
      apply (Included_Empty_set _ (sub P (S n)))...
    assert (forall x, In (Plus (sub P (S (S n)))) x -> (In (Minus (sub P (S (S n))))) x)...
      assert (x ∈ Minus (sub P (S (S n))) \/ ~(x ∈ Minus (sub P (S (S n)))))...
        apply all_decidable.
        apply Minus_Finite. apply Finite_sub. apply H.
      exfalso.
      assert (In (PlusMinus (sub P (S (S n)))) x); unfold PlusMinus...
      rewrite H4 in H7...
    assert (Inhabited (plus w))...
      apply plus_Inhabited.
      assert (dim w = (S n))...
      rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Minus (sub P (S (S n)))).
      apply H6...
      exists w...
    unfold Minus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less w z).
      unfold less. exists p...
    assert (w = z).
      apply H2... apply (tr_trans _ _ z)... left...
    subst.
    unfold less in H9...
  Qed.

  Lemma M_n_Empty_set :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        sub M (  (S n)) == Empty_set ->
        sub M (S (S n)) == Empty_set.
  Proof with intuition.
    intros...
    assert (Finite (sub M (S (S n)))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (M_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma P_n_Empty_set :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        sub P (  (S n)) == Empty_set ->
        sub P (S (S n)) == Empty_set.
  Proof with intuition.
    intros...
    assert (Finite (sub P (S (S n)))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (P_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma M_0_not_empty :
    forall M P,
      is_a_cell (M, P) ->
       ((sub M 1) == Empty_set) -> False.
  Proof with intuition.
    unfold not...
    assert ( forall n, ((sub M (S n)) == Empty_set))...
      induction n...
      apply (M_n_Empty_set M P)...
    unfold is_a_cell in H...
    inversion H2 as [z W]...
    assert (Inhabited (sub M (S (dim z))))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma P_0_not_empty :
    forall M P,
      is_a_cell (M, P) ->
       ((sub P 1) == Empty_set) -> False.
  Proof with intuition.
    unfold not...
    assert ( forall n, ((sub P (S n)) == Empty_set))...
      induction n...
      apply (P_n_Empty_set M P)...
    unfold is_a_cell in H...
    inversion H as [z W]...
    assert (Inhabited (sub P (S (dim z))))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma M_0_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      exists z, (sub M 1) == Singleton z.
  Proof with intuition.
    intros.
    assert (Inhabited (sub M 1)).
      assert (Finite (sub M 1)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (M_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H2...
      rewrite H1...
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma P_0_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      exists z, (sub P 1) == Singleton z.
  Proof with intuition.
    intros.
    assert (Inhabited (sub P 1)).
      assert (Finite (sub P 1)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (P_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H3...
      rewrite H1...
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma M_0_Inhabited' :
    forall M P,
      is_a_cell (M, P) -> Inhabited (sub M 1).
  Proof with intuition.
    intros.
    assert (Finite (sub M 1))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso.
    apply (M_0_not_empty M P)...
  Qed.

  Lemma P_0_Inhabited' :
    forall M P,
      is_a_cell (M, P) -> Inhabited (sub P 1).
  Proof with intuition.
    intros.
    assert (Finite (sub P 1))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso.
    apply (P_0_not_empty M P)...
  Qed.

  Lemma source_is_a_cell : forall (m : nat) (M P : Ensemble carrier),
    is_a_cell (M, P) ->
    celldim (M, P) (S m) ->
    forall n,
      n <= m ->
      is_a_cell (source n (M, P)).
  Proof with intuition.
    intros m M P MPcell MPdim n nltm.
    unfold source.
   
    destruct n.
    - apply (Same_set_is_a_cell (sub M 1) (sub M 1))...
        apply M_0_Inhabited in MPcell.
        inversion MPcell; clear MPcell.
      apply (Same_set_is_a_cell (Singleton x) (Singleton x))...
      assert (dim x = 0) as dimx.
        assert (In (sub M 1) x)... rewrite H...
      unfold is_a_cell...
        exists x...
        exists x...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

    rewrite (sup_zero P).
    rewrite Empty_set_ident_right...

    - unfold is_a_cell in *...

  + assert (Inhabited (sub M 1)).
      assert (exists z, (sub M 1) == Singleton z). apply (M_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... repeat subsuptac... rewrite H10...

  + assert (Inhabited (sub P 1)).
      assert (exists z, (sub P 1) == Singleton z).
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... right. repeat subsuptac... rewrite H10...

  + apply well_formed_sup...
     
  + apply well_formed_Union...
      apply well_formed_sub...
      apply well_formed_sup...
      assert (dim x = S n)...
      assert (dim y <= n)...
      rewrite <- H8, H6 in H11...

  + apply Finite_Union...

  + apply moves_by_dim'.
    intros k.
    repeat (rewrite sub_Union).
    assert ({k < (S n)} + {k = S n} + {k = S (S n)} + {S (S n) < k})...
      apply lt_eq_eq_lt_dec.
    * repeat (rewrite sub_sub_Empty_set || rewrite sub_sup_cancel ||
              rewrite Empty_set_ident_left)...
      apply moves_by_dim...
      rewrite <- H6 in a...
    * rewrite b.
      repeat (rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply moves_by_dim...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set  ||
              rewrite (sub_sup_cancel (S (S n)) (S (S n))) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
    * repeat (rewrite sub_sub_Empty_set ||
              rewrite sub_sup_Empty_set ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
  + apply moves_by_dim'.
    intros k.
    repeat (rewrite sub_Union).
    assert ({k < (S n)} + {k = S n} + {k = S (S n)} + {S (S n) < k})...
      apply lt_eq_eq_lt_dec.
    * repeat (rewrite sub_sub_Empty_set || rewrite sub_sup_cancel ||
              rewrite Empty_set_ident_left)...
      apply moves_by_dim...
      rewrite <- H6 in a...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel (S n)) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply moves_by_dim...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel (S (S n)) (S (S n))) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
    * repeat (rewrite sub_sub_Empty_set ||
              rewrite sub_sup_Empty_set ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
  Qed.

  Lemma target_is_a_cell : forall (m : nat) (M P : Ensemble carrier),
    is_a_cell (M, P) ->
    celldim (M, P) (S m) ->
    forall n,
      n <= m ->
    is_a_cell (target n (M, P)).
  Proof with intuition.
    intros m M P MPcell MPdim n nltm.
    unfold target.
   
    destruct n.
    - apply (Same_set_is_a_cell (sub P 1) (sub P 1))...
        apply P_0_Inhabited in MPcell.
        inversion MPcell; clear MPcell.
      apply (Same_set_is_a_cell (Singleton x) (Singleton x))...
      assert (dim x = 0) as dimx.
        assert (In (sub P 1) x)... rewrite H...
      unfold is_a_cell...
        exists x...
        exists x...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

    rewrite (sup_zero M).
    rewrite Empty_set_ident_right...

    - unfold is_a_cell in *...

  + assert (Inhabited (sub M 1)).
      assert (exists z, (sub M 1) == Singleton z).
        apply (M_0_Inhabited M P). unfold is_a_cell...
        inversion H6; clear H6. exists x...
        rewrite H8...
    inversion H6; clear H6.
    exists x...
    right... repeat subsuptac... rewrite H9...

  + assert (Inhabited (sub P 1)).
      assert (exists z, (sub P 1) == Singleton z).
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... repeat subsuptac... rewrite H10...

  + apply well_formed_Union...
      apply well_formed_sub...
      apply well_formed_sup...
      assert (dim x = S n)...
      assert (dim y <= n)...
      rewrite <- H8, H6 in H11...

  + apply well_formed_sup...      

  + apply Finite_Union...

  + unfold moves_def in *...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set (S n)) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set (S n)) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

  + unfold moves_def in *...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel ) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel ) || 
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
  Qed.

  Lemma maximal_property :
    forall X, Finite X -> Inhabited X -> forall n, Included X (sub Full_set (S n))
      -> exists x, In X x /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    intros X hyp1 hyp2 n hyp3.
    assert (exists m, In X m /\ (forall y, In X y -> (triangle_rest X m y) -> m = y)) as hyp4.
      refine (maximal_exists' _ _ n _)...
    inversion hyp4 as [m]; clear hyp4...
    exists m...
    apply Disjoint_Intersection_condition.
    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H...
      unfold Minus, In at 1 in H3...
      inversion H3 as [z]; clear H3...
      assert (less m z). unfold less. exists x...
      assert (m = z). apply H1... apply (tr_trans _ _ z)... left...
      rewrite H5 in H; unfold less in H... pose (plus_minus_Disjoint z)...
      inversion d... inversion H. apply (H6 x0)...
    inversion H.
  Qed.

  Lemma Finite_eq_decidable : forall T, @Finite carrier T -> forall R, Finite R -> ((T == R) \/ ~(T == R)).
  Proof with intuition.
    intros T TFin.
      induction TFin; intros.
      - apply Finite_Empty_or_Inhabited in H...
        right...
        rewrite <- H in H0; inversion H0...
      - assert ((In R x) \/ ~(In R x))...
          apply all_decidable...
        + assert (R == Add (Setminus R (Singleton x)) x).
            apply add_subtract...
          assert (A == (Setminus R (Singleton x)) ∨ (A == (Setminus R (Singleton x)) → False))...
            apply IHTFin...
            apply Setminus_Finite'...
          * left...
            rewrite H4...
          * right...
            apply H4...
            rewrite <- H3...
            unfold Same_set, Included, Setminus...
            unfold In at 1...
            inversion H6; clear H6. apply H; rewrite H7...
            unfold In at 1 in H5...
            unfold Add in H6... apply In_Union in H6...
        + right... apply H2...  rewrite <- H1...
      - rewrite H...
  Qed.

  Lemma well_formed_Setminus : forall S, well_formed S -> forall T, well_formed (Setminus S T).
  Proof with intuition.
    intros.
    apply (well_formed_Included S)...
    crush.
  Qed.

  Lemma well_formed_Empty_set : well_formed Empty_set.
  Proof with intuition.
    unfold well_formed...
    exfalso...
    exfalso...
  Qed.

  Lemma Disjoint_Plus : forall M R T, Disjoint R T ->
     Included R M -> Included T M ->
     well_formed M ->
     Disjoint (Plus R) (Plus T).
  Proof with intuition.
    intros...
    constructor...
    apply In_Intersection in H3...
    inversion H4; clear H4...
    inversion H5; clear H5...
    assert (x0 = x1)...
      unfold well_formed in H2...
      remember (dim x0) as n.
      destruct n...
      exfalso.
      assert (In Empty_set x)...
        rewrite <- (plus_zero x0)...
      refine (H8 _ _ _ n _ _ _)...
      assert (S (dim x) = dim x0)...
      assert (S (dim x) = dim x1)...
      rewrite Heqn, <- H9...
      unfold perp in H2...
      assert (In Empty_set x)...
        rewrite <- H9...
    subst.
    inversion H...
    apply (H3 x1)...
  Qed.

  Lemma Disjoint_Minus : forall M R T, Disjoint R T ->
     Included R M -> Included T M ->
     well_formed M ->
     Disjoint (Minus R) (Minus T).
  Proof with intuition.
    intros...
    constructor...
    apply In_Intersection in H3...
    inversion H4; clear H4...
    inversion H5; clear H5...
    assert (x0 = x1)...
      unfold well_formed in H2...
      remember (dim x0) as n.
      destruct n...
      exfalso.
      assert (In Empty_set x)...
        rewrite <- (minus_zero x0)...
      refine (H8 _ _ _ n _ _ _)...
      assert (S (dim x) = dim x0)...
      assert (S (dim x) = dim x1)...
      rewrite Heqn, <- H9...
      unfold perp in H2...
      assert (In Empty_set x)...
        rewrite <- H10...
    subst.
    inversion H...
    apply (H3 x1)...
  Qed.

Lemma weird_moves_lemma1 : forall M P, forall x, In (Intersection M P) x
                     -> Disjoint M (plus x) -> Included (minus x) M ->
    ((Singleton x) moves M to Setminus (M ∪ plus x) (minus x)).
Proof with intuition.
   unfold moves_def...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Setminus_is_Intersection_Complement...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite add_subtract'.
        rewrite I_U_dist_r.
        rewrite Empty_set_property.
        rewrite Empty_set_ident_right.
        apply Disjoint_result.
        apply Disjoint_Intersection_condition...
        apply all_decidable...
        apply Union_Included_cancel_right...
Qed.

Lemma weird_moves_lemma2 : forall M P, forall x, In (Intersection M P) x
                     -> Disjoint P (minus x) -> Included (plus x) P ->
    ((Singleton x) moves Setminus (P ∪ minus x) (plus x) to P).
Proof with intuition.
   unfold moves_def...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite add_subtract'.
        rewrite I_U_dist_r.
        rewrite Empty_set_property.
        rewrite Empty_set_ident_right.
        apply Disjoint_result.
        apply Disjoint_Intersection_condition...
        apply all_decidable...
        apply Union_Included_cancel_right...

        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Setminus_is_Intersection_Complement...
Qed.

Lemma P_moves_Mx_to_Px : forall M P, is_a_cell (M, P) ->
               forall x, In (Intersection M P) x ->
               P moves Setminus M (Singleton x) to Setminus P (Singleton x).
  Proof with intuition.
    intros M P cellcond x Inters.
    unfold moves_def.
      repeat (rewrite Setminus_is_Intersection_Complement).
      repeat (rewrite U_I_dist_r).
      repeat (rewrite Intersection_trans).
      rewrite (Intersection_sym _ (√Minus P)).
      rewrite (Intersection_sym _ (√Plus P)).
      repeat (rewrite <- Intersection_trans).
      assert (P == (M ∪ Plus P) ∩ √Minus P).
        apply cellcond.
      rewrite <- H; clear H.
      assert (M == (P ∪ Minus P) ∩ √Plus P).
        apply cellcond.
      rewrite <- H; clear H.
      unfold Same_set, Included; repeat (basic; intuition)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint M (Plus P)).
          apply Prop_2_1.
        apply cellcond. exists P; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint P (Minus P)).
          apply Prop_2_1_dual.
        apply cellcond. exists M; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
Qed.

Lemma M_moves_Mx_to_Px : forall M P, is_a_cell (M, P) ->
               forall x, In (Intersection M P) x ->
               M moves Setminus M (Singleton x) to Setminus P (Singleton x).
  Proof with intuition.
    intros M P cellcond x Inters.
    unfold moves_def.
      repeat (rewrite Setminus_is_Intersection_Complement).
      repeat (rewrite U_I_dist_r).
      repeat (rewrite Intersection_trans).
      rewrite (Intersection_sym _ (√Minus M)).
      rewrite (Intersection_sym _ (√Plus M)).
      repeat (rewrite <- Intersection_trans).
      assert (P == (M ∪ Plus M) ∩ √Minus M).
        apply cellcond.
      rewrite <- H; clear H.
      assert (M == (P ∪ Minus M) ∩ √Plus M).
        apply cellcond.
      rewrite <- H; clear H.
      unfold Same_set, Included; repeat (basic; intuition)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint M (Plus M)).
          apply Prop_2_1.
        apply cellcond. exists P; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint P (Minus M)).
          apply Prop_2_1_dual.
        apply cellcond. exists M; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 3                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_3_1 :
    forall x M P,
      (plus x) moves M to P ->
      receptive M ->
      (minus x) moves M to P.
  Proof with intuition.
    intros.
    assert (exists P', plus x moves M to P').
      exists P...
    apply Prop_2_1 in H1...
    assert (MinusPlus (minus x) == MinusPlus (plus x)).
      remember (Prop_1_1 x) as prop_1_1.
      apply (Same_set_trans _ (Minus (minus x) ∩ Minus (plus x))). apply prop_1_1. apply prop_1_1.
    assert (MinusPlus (minus x) ⊆ M). unfold Included...
    assert (Disjoint M (Plus(minus x))).
      unfold receptive in H0... constructor...
      apply (H6 x).
      Focus 3. apply (Inhabited_intro _ _ x0)...
      Focus 2. intros... inversion H7; clear H7...
      unfold moves_def in H... rewrite H9 in H8...
        rewrite Intersection_trans in H8. repeat basic...
      unfold moves_def in H... unfold Included...
        assert ((In (Plus (plus x)) x1) \/ ~(In (Plus (plus x)) x1))... apply all_decidable...
        pose (Prop_1_1 x)... exfalso. assert (In (Empty_set) x1). rewrite <- H12...
        apply In_Intersection... apply In_Intersection in H... inversion H14.
        rewrite H8... apply In_Intersection... right... apply In_Intersection in H...
    assert (exists Y, minus x moves M to Y).
      apply Prop_2_1...
    inversion H6 as [P']; clear H6.
    assert (P == P').
      unfold moves_def in H7...
      rewrite H6.
      symmetry.
      rewrite I_U_dist_r.
      pose (Prop_1_1 x)...
      unfold PlusMinus in H7. rewrite H7.
      unfold moves_def in H...
      rewrite H12.
      rewrite I_U_dist_r.
      assert ((Plus (plus x) ∩ √Minus (plus x)) == (Plus (minus x) ∩ Plus (plus x))).       
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... assert (In (Empty_set) x0)... rewrite H11. apply In_Intersection...
      assert ((M ∩ √Minus (plus x)) == (M ∩ √Minus (plus x) ∩ √Plus (minus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
          apply In_Complement... apply (H17 x0)...
      assert ((M ∩ √Minus (minus x)) == (M ∩ √Minus (minus x) ∩ √Plus (plus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... apply (H5 x0). apply In_Intersection...
      rewrite H, H16, H17.
      repeat rewrite (Intersection_trans M _ _).
      repeat rewrite Union_Complement_compat.
      rewrite (Union_sym (Minus (minus x)) _).
      rewrite (axiom1 x).
      rewrite (Union_sym _ (Minus (plus x)))...
     
    unfold moves_def in *...
      rewrite H6...
      rewrite H6...
  Qed.
  
  Definition Lemma_3_2_b_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)), (sup P n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)) )
    /\ (Minus X ∩ (sub M (S n))) == Empty_set))).

  Definition Lemma_3_2_c_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)) ∪ X, P ∪ X)
    ))).

  Definition Lemma_3_2_b'_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((MinusPlus X) ⊆ (sub P (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)), (sup P n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)) )
    /\ (Plus X ∩ (sub P (S n))) == Empty_set))).

  Definition Lemma_3_2_c'_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((MinusPlus X) ⊆ (sub P (S n)))) ->
    is_a_cell ( M ∪ X, (sup P n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)) ∪ X)
    ))).


  Lemma Prop_3_3 : forall M P : Ensemble carrier, is_a_cell (M, P) -> receptive M /\ receptive P.
  Proof with intuition.
  Admitted. 

  Lemma Lemma_3_2_b_n_0 : forall n, Lemma_3_2_b_st n 0.
  Proof with intuition.
    intros n.
    unfold Lemma_3_2_b_st.
    intros X Xcard.
    assert (X == Empty_set) as XEmpty.
      apply Cardinality_zero_Empty_set; assumption.
    assert (Finite X) as XFinite.
      apply (Cardinal_are_Finite 0)...
    intros M P H.
    inversion H as [MPcell MPdim]; clear H.
    intros H.
    inversion H as [Xdim K]; clear H.
    inversion K as [Xwf Xcond]; clear K.
    split.

    (* is_a_cell' *)
    assert (Minus X == Empty_set) as MXE.
      rewrite XEmpty.
      unfold Minus, Same_set, Included, In... inversion H...
    assert (Plus X == Empty_set) as PXE.
      rewrite XEmpty.
      unfold Plus, Same_set, Included, In... inversion H...
    assert (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X) == M) as MM.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    assert (sup P n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X) == P) as PP.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      rewrite (cell_dim_n_property M P).
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    assumption.
    assumption.
    symmetry in MM; symmetry in PP.
    apply (Same_set_is_a_cell M P)...

    (* Disjoint *)
    apply Disjoint_Intersection_condition.
    constructor.
    unfold not; intros.
    basic...
    unfold In, Minus in H0...
    inversion H0 as [z J]...
    assert (In Empty_set z). rewrite <- XEmpty...
    inversion H3.
  Qed.

  Lemma Lemma_3_2_b_0_1 : Lemma_3_2_b_st 0 1.
  Proof with intuition.
    unfold Lemma_3_2_b_st.
    intros X Xcard M P J K.
    inversion J as [MPcell MPdim]; clear J.
    inversion K as [Xdim L]; clear K.
    inversion L as [Xwf Xcond]; clear L.
    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    set (Y := ((sub M 1 ∪ Minus X) ∩ √Plus X)).
   
    assert (dim x = 1) as dimx.
      rewrite Xsing in Xdim.
      autounfold with * in Xdim... assert (S (dim x) = 2)... apply Xdim...
    assert (sub M 1 == plus x) as subM0.
      assert (exists d, sub M 1 == Singleton d).
      apply dim_0_Singleton.
      apply (M_0_Inhabited' M P)...
      apply MPcell. inversion H as [f L]; clear H.
      assert (plus x == Singleton f). apply Included_Singleton.
      apply plus_Inhabited. rewrite dimx...
      rewrite <- L.
      assert (PlusMinus X == plus x).
      unfold PlusMinus. rewrite Xsing.
      assert (Plus (Singleton x) ∩ √Minus (Singleton x) == PlusMinus (Singleton x)).
      unfold PlusMinus...
      rewrite H.
      rewrite PlusMinus_Singleton...
      rewrite <- H... rewrite <- H in L...
    assert (Y == minus x) as Ydef.
      unfold Y.
      rewrite Xsing, subM0, Plus_Singleton, Minus_Singleton.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_left.
      apply Intersection_Included_left.
      apply Disjoint_property_right.
      apply plus_minus_Disjoint.
    assert (sup M 0 ∪ Y == minus x) as HypA.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero M), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.
    assert (sup P 0 ∪ Y == minus x) as HypB.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero P), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.

    split.

    apply (Same_set_is_a_cell (minus x) (minus x))...
    unfold is_a_cell...
        apply minus_Inhabited. rewrite dimx. auto.
        apply minus_Inhabited. rewrite dimx. auto.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.

      rewrite Xsing, Minus_Singleton, subM0.
      apply Disjoint_Intersection_condition.
      apply Disjoint_sym. apply plus_minus_Disjoint.
  Qed.


  Lemma Lemma_3_2_Step_1' :
    forall n m, (Lemma_3_2_b_st n m) -> (Lemma_3_2_c_st n m).
  Proof with intuition.
    unfold Lemma_3_2_b_st, Lemma_3_2_c_st.
    intros n m Hyp1 X Xcard M P J K.
   
    assert (Finite X) as XFin.
      apply (Cardinal_are_Finite m)...

    set (Y := ((sub M (S n) ∪ Minus X) ∩ √Plus X))...

    assert (is_a_cell
               (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X),
                sup P n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X))
             ∧ Minus X ∩ sub M (S n) == Empty_set) as Hyp2.
      apply Hyp1...
      intuition.
   
    assert (X moves Y to (sub M (S n))) as movement_result.
      unfold moves_def...
      unfold Y.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      rewrite I_U_dist_r.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      fold (PlusMinus X).
      assert (sub M (S n) ∩ √Minus X == sub M (S n)).
        unfold Same_set, Included...
        apply In_Intersection in H6...
        apply In_Intersection...
        apply In_Complement...
        assert (In Empty_set x)...
          rewrite <- H5.
          apply In_Intersection...
      rewrite H6.
      rewrite Union_Included_right...

      assert (X == sub X (S (S n))) as dimX.
        unfold Same_set, Included, sub...
        unfold In at 1 in H6...
      assert (Y == sub Y (S n)) as dimY.
        unfold Same_set, Included...
        unfold sub, In at 1... unfold Y in H6.
        apply In_Intersection in H6...
        apply In_Union in H7...
        assert ((dim x) = n)...
        apply (Minus_dim _ _ _ H1)...

    assert ((sub Y (S n)) moves (sub M n) to (sub P n)) as movement_result2.
      unfold is_a_cell in H2...
      fold Y in H11.
      assert ((sub (sup M n ∪ Y) (S n)) moves (sub (sup M n ∪ Y) n) to (sub (sup P n ∪ Y) n)).
        apply moves_by_dim...
      assert (sub Y n == Empty_set).
        rewrite dimY. rewrite sub_sub_Empty_set...
      repeat (rewrite sub_Union in H12 || rewrite H14 in H12 ).
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_Empty_set n) in H12)...
      repeat (rewrite Empty_set_ident_left in H12|| rewrite Empty_set_ident_right in H12).
      trivial.    


    unfold is_a_cell in *...
    - apply (Inhabited_Included (sup M n ∪ Y))...

    - apply (Inhabited_Included P)...
     
    - rewrite dimY, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < n} + {n0 = n} + {n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
          apply eq_add_S in H18. rewrite <- H18 in a0...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S (S n))) ||
                  rewrite Empty_set_ident_right || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
          unfold Y.
          assert (well_formed (sub (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X)) (S n))).
          apply well_formed_sub...
          rewrite sub_Union in H18.
          rewrite sub_sup_Empty_set in H18...
          rewrite Empty_set_ident_left in H18...
          rewrite <- Setminus_is_Intersection_Complement in H18.
          rewrite sub_Setminus in H18.
          rewrite sub_Union in H18.
          rewrite sub_Plus in H18.
          rewrite sub_Minus in H18.
          rewrite sub_idemp in H18.
          rewrite <- dimX in H18.
          rewrite Setminus_is_Intersection_Complement in H18...
          + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S n)) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...          
    

    - assert (P == sup P (S n)) as dimP.
        unfold Same_set, Included, sup, In...
      rewrite dimP, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < S n} + {n0 = S n} + {S n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
        + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_Empty_set.

    - apply Finite_Union...

    - apply Finite_Union...

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        assert (S n = n0)... rewrite <- H21 in a...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_Empty_set n (S n)) ||
                rewrite (sub_sup_cancel) || rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- dimX.
        rewrite Setminus_is_Intersection_Complement. fold Y.
        pose (moves_by_dim _ _ _ H17 n).
        fold Y in m0.
        repeat (rewrite sub_Union in m0).
        rewrite dimY in m0.
        repeat (rewrite sub_idemp in m0).
        rewrite (sub_sup_Empty_set _ (S n)) in m0...
        rewrite dimY.
        rewrite sub_sub_Empty_set in m0.
        rewrite (sub_sup_cancel) in m0...
        rewrite (sub_sup_cancel) in m0...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- (sub_idemp _ M).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        rewrite <- (cell_dim_n_property M P)...
        rewrite <- dimX.
        rewrite <- dimY... unfold is_a_cell...
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite (sub_sub_Empty_set _ (S (n0))) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P n0 == Empty_set).
          unfold sub, Same_set, Included...
          exfalso. unfold In at 1 in H18...
          assert (dim x <= n)...
          assert ( n < n)...
            apply (lt_le_trans _ (dim x))...
            rewrite <- H22 in b...
            inversion H18...
        rewrite (H18).
        rewrite Empty_set_ident_left...
        apply Empty_set_moves.

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        apply eq_add_S in H18... rewrite <- H18 in a...
      + rewrite <- b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_cancel n0 n0) || rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P (S (S n)) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        rewrite H18; rewrite Empty_set_ident_left.
        rewrite <- (sub_idemp _ P).
        rewrite <- (sub_idemp _ M).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        rewrite <- (cell_dim_n_property M P)...
        apply moves_by_dim... unfold is_a_cell...
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set (S (S n)) (S n0)) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left || 
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P (S n0) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        assert (sub P (n0) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1... unfold In at 1 in H21...
          rewrite H21.
          rewrite sub_sup_Empty_set...
        rewrite H18, H21. rewrite Empty_set_ident_left.
        apply Empty_set_moves.
  Qed.

  Lemma Lemma_3_2_Step_2' :
    forall n, ((Lemma_3_2_b_st n 1) -> (forall m, Lemma_3_2_b_st n (S m))).
  Proof with intuition.
    intros n hypothesis_for_1 m.

    induction m. assumption.

    unfold Lemma_3_2_b_st in *.
    intros X Xcard M P H J.
    inversion H as [MPcell MPdim]; clear H.
    inversion J as [Xdim K]; clear J.
    inversion K as [Xwf Xcond]; clear K.

    assert (exists x, In X x /\ Disjoint (plus x) (Minus X)) as R.  (* maximal *)
      apply (wf_maximal_exists X n)...
      apply (Cardinal_are_Finite (S (S m)))...
      apply Cardinal_Sn in Xcard...
    inversion R as [x xcond]; clear R.
    inversion xcond as [xinX disj]; clear xcond.
    assert (dim x = S n) as dimx. idtac...

    assert (plus x ⊆ sub M (S n)) as K.
      apply (Included_trans _ (PlusMinus X))...
        unfold PlusMinus. rewrite <- (Intersection_idemp (plus x)).
        apply Intersection_Included_compat...
          unfold Included, Plus, In... exists x...
        apply Disjoint_property_left...

    assert (is_a_cell
                 (sup M n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
                 sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
               ∧ Minus (Singleton x) ∩ sub M (S n) == Empty_set).
        apply hypothesis_for_1...
        apply Cardinality_Singleton_is_one.
        unfold Included... inversion H; subst...
        rewrite PlusMinus_Singleton...
    inversion H as [LA LB]; clear H.
   
    set (N :=  sup M n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Q :=  sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Z := Intersection X (Complement (Singleton x))).
    set (Y' := (sub N (S n) ∪ (Minus Z)) ∩ √Plus Z).
    set (Y  := (sub M (S n) ∪ (Minus X)) ∩ √Plus X).
    assert (X == Union (Singleton x) Z) as XZrel.
      unfold Z.
      rewrite Union_sym. rewrite U_I_dist_r.
      rewrite Full_set_property. rewrite Full_set_ident_right.
      unfold Same_set, Included... apply In_Union in H... inversion H0. rewrite <- H...
      intuition.

    assert (Cardinal Z (S m) /\ Z ⊆ sub Full_set (S (S n)) /\ well_formed Z) as Zproperties.
      idtac...
      unfold Z. rewrite <- Setminus_is_Intersection_Complement.
      apply (Cardinal_Setminus carrier_decidable_eq (S (S m)))...
      apply (Included_trans _ X _)...
      unfold Z.
      apply Intersection_Included_cancel_right...
        unfold Z. apply (well_formed_Included X)...
        apply Intersection_Included_cancel_right...
    inversion Zproperties as [Zcard T].
    inversion T as [Zdim Zwf]. clear T Zproperties.

    split.

    assert (is_a_cell ((sup N n  ∪ Y'), (sup Q n ∪ Y')) /\ Minus Z ∩ sub N (S n) == Empty_set) as AA.
      apply (IHm Z)...
        unfold celldim, N, Q, setdim...
          apply In_Union in H...
          apply In_Union in H0...
          unfold sup, In at 1 in H...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
          apply In_Union in H0...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...

        assert (sub N (S n) == Intersection (Union (sub M (S n)) (minus x)) (Complement (plus x))) as JA.
            unfold N.
            rewrite sub_Union.
            rewrite sub_Intersection. rewrite sub_Union.
            rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left...
            rewrite sub_idemp.
            rewrite Minus_Singleton.
            rewrite Plus_Singleton.
            unfold Same_set, Included;
              repeat basic...
              right.
              repeat subsuptac...
        assert (PlusMinus Z ⊆ Intersection (Union (PlusMinus X) (minus x)) (Complement (plus x))) as JB.
          unfold PlusMinus.
          rewrite XZrel.
          rewrite Plus_Union.
          rewrite Minus_Union.
          rewrite Plus_Singleton.
          rewrite Minus_Singleton.
          rewrite <- Union_Complement_compat.
          unfold Included; repeat (basic; intuition).
          assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
            assert (Finite (minus x))... assert (decidable (minus x))... apply H3.
            apply In_Complement; unfold not...
            unfold Plus, Z, In at 1 in H1.
            inversion H1 as [d SS]...
            apply In_Intersection in H3...
            unfold well_formed in Xwf...
            assert (x = d).
            refine (H7 _ _ _ n _ _ _)... unfold perp in H8...
            assert (In Empty_set x0). rewrite <- H9. apply In_Intersection... inversion H8. rewrite H8 in H6.
            apply In_Complement in H6; unfold not in H6...
       
      rewrite JA, JB.
        apply Intersection_Included_compat...
        apply Union_Included_compat...

      assert (sup N n == sup M n) as J1.
        unfold N.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1...
        repeat subsuptac...
        apply In_Intersection in H1...
        apply In_Union in H2...
        repeat subsuptac...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1.
        rewrite H5 in H3. exfalso...

      assert (sup Q n == sup P n) as J2.
        unfold Q.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1...
        repeat subsuptac...
        apply In_Intersection in H1...
        apply In_Union in H2...
        assert (dim x0 = n)...  rewrite H2 in H3. exfalso...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1.
        rewrite H5 in H3. exfalso...

      assert (Y == Y') as J3.
        unfold Y, Y', N.   
        rewrite XZrel.
        rewrite Minus_Union.
        rewrite Plus_Union.
        rewrite <- Union_Complement_compat.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left.
        rewrite sub_Intersection. rewrite sub_Union. rewrite sub_idemp. rewrite sub_Minus.
        rewrite <- Intersection_trans.
        rewrite <- Union_trans.
        rewrite I_U_dist_r.
        rewrite sub_Singleton...
        rewrite Minus_Singleton, Plus_Singleton.
        unfold Same_set, Included; repeat (basic; intuition).
        left; repeat (basic; intuition).
        left; repeat (basic; intuition).
        right; repeat (basic; intuition).
        apply In_Complement... apply (H2 x0)...
        apply In_Intersection... apply (Minus_Included Z)...
        rewrite XZrel...
      fold (is_a_cell' (sup N n ∪ Y') (sup Q n ∪ Y')) in AA.
      rewrite J1, J2, <- J3 in AA...
      fold N in LA.
      fold Q in LA.

    assert (celldim (N, Q) n) as NQdim.
      unfold celldim, N, Q.
      setdimtac...
      rewrite dimx...
      rewrite dimx...
    assert (sub N (S n) == (sub M (S n) ∪ (minus x)) ∩ √(plus x)).
      unfold N.
      rewrite Minus_Singleton, Plus_Singleton.
      unfold Same_set, Included, sub, sup; repeat (basic; intuition)...
        exfalso. rewrite H2 in H3...
        right; basic...
    assert (Minus Z ∩ sub N (S n) == Empty_set).
      apply (IHm Z Zcard N Q)...
      rewrite H.
      unfold PlusMinus, Z, Included; repeat (basic; intuition)...
        inversion H2; clear H2...
        assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
          apply all_decidable...
          left; apply Xcond...
          unfold PlusMinus; repeat basic... exists x1...
          apply In_Complement...
          apply H3... inversion H2; clear H2...
          exists x2; repeat basic...
          apply In_Complement...
          inversion H7; clear H7...
          rewrite <- H9 in *...
          apply In_Complement...
          inversion H2...
          apply In_Intersection in H5...
          assert (x = x1)... unfold well_formed in Xwf...
          refine (H8 _ _ _ n _ _ _)...
          unfold perp in H9... assert (In (Empty_set) x0)...
          rewrite <- H10...
    assert (Disjoint (sub M (S n)) (minus x)).
      rewrite Disjoint_Intersection_condition.
      rewrite Intersection_sym.
      rewrite Minus_Singleton in LB...
    assert ((sub N (S n) ∪ (plus x)) ∩ √(minus x) == sub M (S n)).
      rewrite H.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property...
      rewrite Empty_set_ident_right.
      assert (Included (minus x) (√(sub M (S n)))).
        apply Disjoint_property_right...
      apply Complement_Included_compat in H2...
      rewrite Complement_Complement_compat in H2...
      assert (Included (minus x) (√(sub M (S n)))).
        apply Disjoint_property_right...
      unfold Same_set, Included; repeat (basic; intuition)...
       apply all_decidable... apply Finite_sub... apply MPcell.
    rewrite <- H2.
    rewrite XZrel.
    rewrite Minus_Union.
    rewrite Minus_Singleton.
    rewrite <- Intersection_trans. 
    rewrite I_U_dist_l.
    rewrite (I_U_dist_r (sub N (S n))).
    rewrite (I_U_dist_r (plus x)).
    rewrite H0; clear H0.
    unfold Same_set, Included...
    exfalso; repeat (basic; intuition)...
    apply (H1 x0)... basic...
    apply (Minus_Included Z X)... rewrite XZrel...
  Qed.

  Lemma Lemma_3_2_Step_3' :
    forall n, (forall m , Lemma_3_2_b_st n m) -> (Lemma_3_2_b_st (S n) 1). 
  Proof with intuition.
    intros n Hyp1.

    (* n > 0 *)
    intros X Xcard M P K L.
    inversion K as [MPcell MPdim]; clear K.
    inversion L as [Xdim J]; clear L.
    inversion J as [Xwf Xcond]; clear J.
    assert (Finite X) as XFin. apply (Cardinal_are_Finite 1)...

    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    assert (In X x) as xinX. rewrite Xsing...

    assert (plus x ⊆ sub M (S (S n))) as plusxdim.
      assert (PlusMinus X == plus x) as K.
        unfold PlusMinus. rewrite Xsing.
        rewrite Plus_Singleton, Minus_Singleton.
        apply Intersection_Included_left. apply Disjoint_property_left.
        apply plus_minus_Disjoint.
      rewrite <- K...
    set (Y := (sub M (S (S n)) ∪ Minus X) ∩ √Plus X).

    set (S' := (fun z =>  ~(In (plus x) z) /\ exists w, In (plus x) w /\ triangle_rest (sub M (S (S n))) z w)).
    set (T  := Setminus ((Setminus (sub M (S (S n)))) S') (plus x)).
    assert ((sub M (S (S n))) == S' ∪ (plus x) ∪ T) as DisjUnion.
      unfold Same_set, Included...
        assert (In (plus x) x0 \/ ~(In (plus x) x0))... apply Finite_are_decidable...
        assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)))...
          apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left; left. unfold S', In at 1...
        right. unfold T, Setminus... unfold In at 1... unfold In at 1... unfold S', In at 1 in H0...
        apply In_Union in H... apply In_Union in H0... unfold S', In at 1 in H... inversion H1; clear H1...
        inversion H2... unfold T, Setminus in H0; repeat (basic; intuition)...
    assert (Disjoint (plus x) S') as DisjMS'.
      unfold S', Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    assert (Disjoint (plus x) T) as DisjMT.
      unfold T, Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    assert (Disjoint T S') as DisjTS'.
      unfold T, S', Setminus. constructor...
      apply In_Intersection in H...
      unfold In at 1 in H1...
      unfold In at 1 in H0...
      unfold In at 1 in H1...
    assert (is_initial_segment S' (sub M (S (S n)))) as S'initial.
      unfold is_initial_segment.
      split. unfold S', Included...
      unfold In at 1 in H... inversion H1; clear H1... induction H2...
      unfold S'... unfold In at 1 in H0... unfold In at 1... apply H1...
      inversion H2 as [w E]; clear H2...
      assert (is_a_segment (plus x) (sub M (S (S n))))... apply Prop_1_3... apply xplus_is_tight.
      apply (well_formed_Included M). apply MPcell. unfold Included, sub, In...
      apply weird_lemma_4 in H4...
      refine (H6 y w _ _ _)...
      inversion H2 as [a A]; exists a...
      apply (triangle_rest_trans _ _ z)...
    assert (is_final_segment T (sub M (S (S n)))) as Tfinal.
      unfold is_final_segment.
      split. unfold T, Setminus, Included, In...
      unfold T... unfold Setminus, In at 1 in H0... unfold In at 1 in H1...
      unfold Setminus, In at 1... unfold In at 1... apply triangle_rest_in_set in H... apply H3.
      unfold is_initial_segment in S'initial... apply (H5 y z)...
      assert (is_initial_segment (Union S' (plus x)) (sub M (S (S n)))).
        unfold is_initial_segment... rewrite DisjUnion. unfold Included...
        apply In_Union in H5... left.
        unfold is_initial_segment in S'initial... apply (H7 y0 z0)...
        assert ((y0 ∈ plus x) \/ ~(y0 ∈ plus x))... apply Finite_are_decidable... left. unfold S', In at 1... exists z0...
      unfold is_initial_segment in H4... assert (y ∈ S' ∪ plus x). apply (H6 y z)...
      apply In_Union in H4...
    assert (Finite S') as S'Fin.
      apply (Finite_Included'' (sub M (S (S n))))... apply Finite_sub. apply MPcell.
      unfold S', Included, In ... inversion H1; clear H1... inversion H2...
      assert ((In (plus x) x0) \/ ~(In (plus x) x0))... apply Finite_are_decidable...
      right... unfold S', In at 1 in H0...
      assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)))...
        apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left... unfold S', In at 1... right...  apply H2. unfold S', In at 1 in H0...
    assert (Finite T) as TFin.
      unfold T. apply Setminus_Finite'...
      apply Setminus_Finite'...
      apply Finite_sub. apply MPcell.
    assert (sub T (S (S n)) == T) as Tdim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold T, Setminus in H... unfold In at 1, In at 1 in H...
    assert (sub S' (S (S n)) == S') as S'dim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold S', Setminus in H... unfold In at 1 in H...
      inversion H1; clear H1...
      apply triangle_rest_in_set in H2...

    assert ((S' ∪ plus x moves sub M (S n)
               to (sub M (S n) ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x))
              ∧ (T moves (sub P (S n) ∪ Minus T) ∩ √Plus T to sub P (S n))
                ∧ (sub P (S n) ∪ Minus T) ∩ √Plus T ==
                  (sub M (S n) ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)).
    apply Prop_2_4_exact... apply Finite_Union...
    rewrite <- DisjUnion...
    apply moves_by_dim... apply MPcell...
    apply (Included_trans _ (PlusMinus (sub M (S (S n))))).
     unfold T, PlusMinus.
     repeat (rewrite Setminus_is_Intersection_Complement)...
     unfold Included; repeat (basic; intuition)...
     inversion H3... exists x1... repeat (basic; intuition)...
     apply In_Complement... apply H4...
     rewrite Intersection_trans.
     rewrite Union_Complement_compat.
     inversion H0... exists x1... repeat (basic; intuition)...
     inversion H3...              repeat (basic; intuition)...
       apply In_Complement... apply In_Union in H5...
       unfold S', In at 1 in H12...
       inversion H13; clear H13...
       apply (H1 x3)... apply In_Intersection...
       unfold is_final_segment in Tfinal...
       refine (H15 x2 _ _ _). apply (tr_trans _ _ x1)... exists x0...
       unfold T, In at 1; repeat (basic; intuition)...
       rewrite DisjUnion in H8; repeat (basic; intuition)...
       assert (In T x1)...
       unfold is_final_segment in Tfinal...
       refine (H13 x2 _ _ _)... apply (tr_trans _ _ x1)... exists x0...
       left... unfold T, Setminus in H8... unfold In at 1, In at 1 in H8; repeat (basic; intuition)...
    rewrite <- sub_PlusMinus...
    apply sub_Included_compat.
    apply Prop_2_1_dual... apply MPcell... exists M... apply MPcell...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_three...
    apply Disjoint_sym...
    rewrite <- DisjUnion.
    pose (well_formed_by_dimension M).
    inversion i. apply H.
    apply MPcell...
    apply Finite_Union...
    assert (dim b = S n). rewrite <- Tdim in H1...
    assert (dim a = S n). apply In_Union in H0... rewrite <- S'dim in H2...
    rewrite H, H2...

    set (B := (sub M (S n) ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)).
    fold B in H.
    assert (sub B (S n) == B) as Bdim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H1...
        unfold In at 1...
        unfold B in H1...
        repeat (basic; intuition)...
        inversion H1; clear H1...
        assert (dim x1 = S n)...
          apply In_Union in H1...
          rewrite <- S'dim in H6...
        assert (S (dim x0) = dim x1)...
        rewrite H6 in H9...

    assert ((S' moves sub M (S n) to (sub M (S n) ∪ Plus S') ∩ √Minus S')
              ∧ (plus x moves (B ∪ Minus (plus x)) ∩ √Plus (plus x) to B)
                ∧ (B ∪ Minus (plus x)) ∩ √Plus (plus x) ==
                  (sub M (S n) ∪ Plus S') ∩ √Minus S') as JJJ.
    apply Prop_2_4_exact...
    unfold B, Included, PlusMinus...
      rewrite Plus_Union.
      rewrite Minus_Union.
      rewrite <- Union_Complement_compat.
      repeat (basic; intuition)...
      apply In_Complement... apply H7... exfalso.
      inversion H6... inversion H1...
        assert (less x1 x2)... exists x0...
        apply (H5 x1)... basic...
        unfold is_initial_segment in S'initial...
        apply (H14 _ x2)... apply (tr_trans _ _ x2)... left...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_sym...
    apply (well_formed_Included M).
    apply MPcell...
    apply (Included_trans _ (sub M (S (S n))))...
    rewrite DisjUnion...
    assert (dim a = S n). rewrite <- S'dim in H3...
    assert (dim b = S n). assert (S (dim b) = dim x)...
    rewrite H1, H5...
    set (A := (sub M (S n) ∪ Plus S') ∩ √Minus S').
    fold A in JJJ.
    assert (sub A (S n) == A) as Adim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H2...
        unfold In at 1...
        unfold A in H2...
        repeat (basic; intuition)...
        inversion H2; clear H2...
        assert (dim x1 = S n)...
          rewrite <- S'dim in H2...
        assert (S (dim x0) = dim x1)...
        rewrite H9 in H12...

    inversion H as [movesMtoB [movesBtoP Bdef]].
    clear H. symmetry in Bdef. rewrite <- Bdef in movesBtoP.
    inversion JJJ as [movesMtoA [movesAtoB Adef]].
    clear JJJ. symmetry in Adef. rewrite <- Adef in movesAtoB.

    assert (dim x = S (S n)) as xdim.
      idtac...

    set (tM := sub P (S n) ∪ sup M n).
    set (tP := sup P (S n)).
    assert (is_a_cell (tM, tP)) as tMPcell.
      unfold tM, tP. apply (target_is_a_cell n)...
    assert (celldim (tM, tP) n) as tMPdim.
      apply target_dim...
    assert (sub tM (S n) == sub P (S n)) as targetrel.
        unfold tM...
        rewrite sub_Union. rewrite sub_idemp. rewrite sub_sup_Empty_set...
     
(*
    assert (is_a_cell ((sup M (n - 1) ∪ B ∪ T          , sup P n ∪ T))        ).
    assert (is_a_cell ((sup M (n - 1) ∪ B              , sup P (n - 1) ∪ B))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ A ∪ (plus x)   , sup P n ∪ (plus x))) ).
    assert (is_a_cell ((sup M (n - 1) ∪ A              , sup P (n - 1) ∪ A))    ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n) ∪ S' , sup P n ∪ S'))       ).
    assert (is_a_cell ((sup M (n - 1) ∪ (sub M n)      , sup P (n - 1) ∪ (sub M n))) ).
  *)  (* I don't know what this is for, leave it until i'm sure the lemma works *)

    assert (exists mT, Cardinal T mT). apply Cardinality_exists. assumption.
      inversion H as [mT Tcard]; clear H.
   

    (* is a cell (M + B + T) (P + T) *)
    assert (is_a_cell ((sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T) ∪ T, tP ∪ T))) as T1.
      apply (Lemma_3_2_Step_1' _ mT)...
      unfold Included... subsuptac...
      assert (In (sub M (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...
   
    (* is a cell (M + B) (P + B) *)
    assert (is_a_cell ((sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)  , sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)))
       /\ (Minus T) ∩ sub tM (S n) == Empty_set) as T2.
      apply (Hyp1 mT)...
      unfold Included... subsuptac...
      assert (In (sub M (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...
   
    assert (exists mplusx, Cardinal (plus x) mplusx).
      apply Cardinality_exists...
      inversion H as [mplusx plusxcard]; clear H.

    (* is a cell (M + A + x) (P + B + x) *)
    assert (is_a_cell
             ((sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ (plus x),
             (sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) ∪ (plus x))) as plusx1.
      apply (Lemma_3_2_Step_1' _ mplusx)...
      unfold celldim...
        setdimtac.
        unfold T; setdimtac.
        unfold T; setdimtac.
        unfold Included, sub... unfold In at 1...
      rewrite targetrel.
      rewrite <- Bdef.
      assert (sub ((sup tM n ∪ B)) (S n) == B).
        rewrite sub_Union... rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A... 
   
    assert (is_a_cell
               (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)),
               sup (sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)))
             ∧ Minus (plus x) ∩ sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n) == Empty_set) as plusx2.
      apply (Hyp1 mplusx)...
      unfold celldim...
        setdimtac...
        unfold T; setdimtac...
        unfold T; setdimtac...
      unfold Included... unfold sub, In at 1...
      rewrite targetrel.
      rewrite <- Bdef.
      assert (sub ((sup tM n ∪ B)) (S n) == B).
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...
   
    assert (exists mS', Cardinal S' mS').
      apply Cardinality_exists...
    inversion H as [mS' S'card]; clear H.

    assert (is_a_cell
        ((sup (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ ((sub (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (S n) ∪ Minus S') ∩ √Plus S')) ∪ S', (sup (sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
           ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
               ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ S')) as S'1.
      apply (Lemma_3_2_Step_1' _ mS')...
      unfold celldim. setdimtac.
        apply (setdim_Included _ _ plusxdim)... setdimtac.
        apply (setdim_Included _ _ plusxdim)... setdimtac.
        apply (Included_trans _ (sub M (S (S n)))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      unfold Included; intros.
      rewrite sub_Union at 1. right.
      assert (PlusMinus S' ⊆ A). apply Prop_2_1_dual...
      exists (sub M (S n))... apply H4 in H3; clear H4.
      rewrite Adef in H3...
      unfold sub at 1, In at 1...  assert ((sub (sup tM n ∪ B) (S n) == B)).
        rewrite sub_Union. rewrite Bdim.
        rewrite sub_sup_Empty_set...
      rewrite H4... repeat (basic; intuition). rewrite Bdef in H3.
      repeat (basic; intuition). unfold T, Minus, Setminus, sub, In in H3.
      inversion H3; clear H3... apply minus_dim in H10... apply eq_add_S in H13. rewrite H13 in H10. inversion H10...
      unfold Minus, In at 1 in H3. inversion H3... assert (dim x = S (S n))...
      apply minus_dim in H10.
      apply plus_dim in H9. assert (S (S (dim x0)) = S (S n))... rewrite <- H7.
      rewrite H10...

    fold (is_a_cell'
        ((sup
            (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
             ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                 ∪ Minus (plus x)) ∩ √Plus (plus x))) n
          ∪ ((sub
                (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T))
                   n
                 ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T))
                       (S n) ∪ Minus (plus x)) ∩ √Plus (plus x))) (S n) ∪ Minus S')
             ∩ √Plus S')) ∪ S') (
        (sup (sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
         ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
             ∪ Minus (plus x)) ∩ √Plus (plus x))) ∪ S')) in S'1.
    rewrite targetrel in S'1. rewrite <- Bdef in S'1.
    unfold tM in S'1.
    unfold is_a_cell' in S'1.

    assert (is_a_cell
        (sup (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ ((sub (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (S n) ∪ Minus S') ∩ √Plus S'),
        sup (sup (sup tP n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
           ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
               ∪ Minus (plus x)) ∩ √Plus (plus x))) n ∪ ((sub (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (S n) ∪ Minus S') ∩ √Plus S'))
      ∧ Minus S' ∩ sub (sup (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) n
            ∪ ((sub (sup tM n ∪ ((sub tM (S n) ∪ Minus T) ∩ √Plus T)) (S n)
                ∪ Minus (plus x)) ∩ √Plus (plus x))) (S n) == Empty_set)
    as S'2.
      apply (Hyp1 mS')...
      unfold celldim. setdimtac.
        apply (setdim_Included _ _ plusxdim)... setdimtac.
        apply (setdim_Included _ _ plusxdim)... setdimtac.
        apply (Included_trans _ (sub M (S (S n)))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      rewrite targetrel.
      rewrite <- Bdef.
      rewrite sub_Union.
      rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left.
      assert (sub ((sub (sup tM n ∪ B) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)) (S n) == (B ∪ Minus (plus x)) ∩ √Plus (plus x)).
        rewrite sub_Union at 1.
        rewrite Union_trans.
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        rewrite Bdim.
        unfold Same_set, Included...
          unfold sub, In at 1...
          repeat (basic; intuition)... rewrite <- Bdim in H3...
          apply eq_S. apply (Minus_dim _ _ _ plusxdim)...
          idtac...
      rewrite H3.
      rewrite <- Adef.
      apply Prop_2_1_dual...
      exists (sub M (S n))...

(* this is tidying up, it is completely optional, doesn't change the meaning of anything, but might change
   whether the proofs compile *) (*
    fold (is_a_cell ((sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) ∪ T) (tP ∪ T)) in T1.
    rewrite targetrel in T1. rewrite <- Bdef in T1.
    unfold tM in T1.
    rewrite sup_Union in T1.
    rewrite sup_idemp in T1.
    rewrite sup_sub_comm in T1.
    rewrite sub_sup_Empty_set in T1.
    rewrite Empty_set_ident_left in T1.
    unfold tP in T1.
    unfold is_a_cell in T1.
    fold (is_a_cell' (sup tM (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T)) (
       sup tP (n - 1) ∪ ((sub tM n ∪ Minus T) ∩ √Plus T))) in T2.
    rewrite targetrel in T2. rewrite <- Bdef in T2.
    unfold tM in T2.
    rewrite sup_Union in T2.
    rewrite sup_idemp in T2.
    rewrite sup_sub_comm in T2.
    rewrite sub_sup_Empty_set in T2.
    rewrite Empty_set_ident_left in T2.
    unfold tP in T2.
    rewrite sup_sup_min in T2.
    unfold is_a_cell in T2.
    inversion T2 as [T2a T2b]; clear T2. *)

    assert ((minus x) moves A to B) as moves4.
      apply Prop_3_1.
      assumption.
      apply Prop_3_3 in plusx1...
      rewrite targetrel in H1.
      rewrite <- Bdef in H1.
      rewrite (sub_Union _ _ (S n)) in H1.
      rewrite Bdim in H1.
      rewrite sub_sup_Empty_set in H1...
      rewrite Empty_set_ident_left in H1.
      rewrite <- Adef in H1.
      assert (receptive (sub ((sup (sup tM n ∪ B) n ∪ A) ∪ plus x) (S n))).
      apply receptive_by_dimension...
      repeat (rewrite sub_Union in H7).
      rewrite sub_sup_Empty_set in H7...
      assert (sub (plus x) (S n) == Empty_set).
        unfold Same_set, Included...
          exfalso. unfold sub, In at 1 in H8...
          apply plusxdim in H9...
          assert (S (dim x0) = S (S n))...
          rewrite H8 in H10... inversion H8...
      rewrite H8 in H7.
      rewrite Empty_set_ident_left, Empty_set_ident_right in H7...
      rewrite <- Adim...

    assert (Disjoint (Minus S') (Plus (minus x))) as HardDisj.
      assert (∃ n : nat, Cardinal S' n).
        apply Cardinality_exists...
      inversion H as [p J].
      induction p.
        apply Cardinality_zero_Empty_set in J.
         rewrite J.
         constructor...
         inversion H6.
         inversion H7...
        constructor...
         apply In_Intersection in H6...
         inversion H7 as [w R ]; clear H7...
         inversion H8 as [v R']; clear H8...
         set (Z := fun y => In S' y /\ triangle_rest S' w y).
         assert (exists m : carrier, m ∈ Z /\
            (forall y : carrier, y ∈ Z → triangle_rest Z m y -> m = y)).
           refine (maximal_exists' _ _ (S n) _)...
           apply (Finite_Included'' S')... unfold Z; crush.
           assert ((triangle_rest S' w x1) \/ ~(triangle_rest S' w x1))...
             apply triangle_rest_dec.
           apply Cardinal_are_Finite in J... left; unfold Z, In at 1...
           right; unfold Z, In at 1... exists w; unfold Z, In at 1... left...
           apply (Included_trans _ (sub M (S (S n))))...
           apply (Included_trans _ S')...
           unfold Z; crush. rewrite DisjUnion...
         inversion H10 as [u [uinZ umax]]; clear H10...
         assert (plus u ∩ Minus (plus x) == Empty_set).
           apply (Prop_1_2_dual _ v)...
           right with w. exists x0...
           apply (rest_implies_full S').
           unfold Z, In at 1 in uinZ...
         set (A' := Intersection (Union A (minus u)) (Complement (plus u))).
         set (B' := Intersection (Union B (minus u)) (Complement (plus u))).
         assert ((plus x) moves A' to B').
           unfold A', B'.
           apply Prop_2_2...
           unfold Included, A; intros; apply In_Intersection...
             right. exists u... unfold Z, In at 1 in uinZ...
             apply In_Complement...
             inversion H12; clear H12...
             assert (triangle_rest S' u x2).
               right with x2...
               unfold Z, In at 1 in uinZ...
               exists x1...
               left...
             assert (u = x2)...
               apply umax...
               unfold Z, In at 1...
               apply (triangle_rest_trans _ _ u)...
               unfold Z, In at 1 in uinZ...
               clear H10 umax H11.
               induction H13...
                 left...
                 right with y...
                 apply IHtriangle_rest... unfold Z, In at 1...
                 apply triangle_rest_in_set in H13...
                 apply triangle_rest_equiv.
                 right with x2...
                 apply triangle_rest_in_set in H13...
                 apply triangle_rest_equiv. unfold Z, In at 1 in uinZ...
             rewrite H15 in H11...
           constructor...
             apply In_Intersection in H11...
             unfold MinusPlus in H12; apply In_Intersection in H12.
             assert (In (Empty_set) x1)...
               rewrite <- H10.
               apply In_Intersection...
           constructor...
             apply In_Intersection in H11...
             inversion H13; clear H13...
             assert (less x2 u).
               exists x1...
             refine (initial_property _ (plus x) _ S'initial _ _ u x2 _ _ _)...
               apply Disjoint_sym...
               unfold Z, In at 1 in uinZ...
           constructor...
             apply In_Intersection in H11...
             inversion H13; clear H13...
             assert (well_formed (sub M (S (S n))))...
               apply well_formed_sub. apply MPcell.
             unfold well_formed in H11...
             assert (u = x2)...
               refine (H16 _ _ _ n _ _ _)...
               rewrite DisjUnion...
               left; left. unfold Z, In at 1 in uinZ...
               unfold Z, In at 1 in uinZ...
               assert (In (sub M (S (S n))) u)...
               rewrite DisjUnion...
               unfold perp in H11...
               assert (In Empty_set x1)...
                 rewrite <- H18...
               inversion DisjMS'.
               apply (H17 x2)... apply In_Intersection...
               rewrite <- H11.
               unfold Z, In at 1 in uinZ...
         assert (is_a_cell (sup M n ∪ A, sup P n ∪ A)) as HHJJKK. 
           apply (Same_set_is_a_cell _ _ H2). 
           rewrite Adef, Bdef.
           repeat (rewrite <- Setminus_is_Intersection_Complement).
           rewrite <- Tdim. unfold tM.
           repeat (rewrite sup_Union || rewrite sup_Setminus ||
                   rewrite sub_Union || rewrite sub_Setminus ||
                   rewrite sub_idemp || rewrite sup_idemp ||
                   rewrite sub_Minus || rewrite sub_Plus ||
                   rewrite sup_Minus || rewrite sup_Plus ||
                   rewrite sub_sup_Empty_set || rewrite sup_sub_Empty_set
                  )...
           repeat (rewrite sup_Empty_set ||
                   rewrite Minus_Empty_set || rewrite Plus_Empty_set ||
                   rewrite Empty_set_ident_left || 
                   rewrite Empty_set_ident_right || 
                   rewrite Setminus_Empty_set
                  )...
           rewrite Adef, Bdef.
           repeat (rewrite <- Setminus_is_Intersection_Complement).
           rewrite <- Tdim. unfold tP, tM.
           repeat (rewrite sup_Union || rewrite sup_Setminus ||
                   rewrite sub_Union || rewrite sub_Setminus ||
                   rewrite sub_idemp || rewrite sup_idemp ||
                   rewrite sub_Minus || rewrite sub_Plus ||
                   rewrite sup_Minus || rewrite sup_Plus ||
                   rewrite sub_sup_Empty_set || rewrite sup_sub_Empty_set
                  )...
           repeat (rewrite sup_Empty_set ||
                   rewrite Minus_Empty_set || rewrite Plus_Empty_set ||
                   rewrite Empty_set_ident_left || 
                   rewrite Empty_set_ident_right || 
                   rewrite Setminus_Empty_set
                  )...
           rewrite sup_sup_min... 
         assert ((minus x) moves A' to B').
           refine (Prop_3_1 _ _ _ _ _)...
           assert (is_a_cell ((sup M n) ∪ A', (sup P n) ∪ A')).
             unfold Lemma_3_2_b_st in Hyp1.
             unfold A'.
             assert (is_a_cell
              (sup (sup M n ∪ A) n
               ∪ ((sub (sup M n ∪ A) (S n) ∪ Minus (Singleton u))
                  ∩ √Plus (Singleton u)),
              sup (sup P n ∪ A) n
              ∪ ((sub (sup M n ∪ A) (S n) ∪ Minus (Singleton u))
                 ∩ √Plus (Singleton u)))).
             apply Hyp1 with (m := 1) (X := Singleton u)... 
             apply Cardinality_Singleton_is_one. 
             unfold celldim, setdim, A.
               repeat (basic; intuition)... 
               apply le_trans with (S (dim x1))... 
               assert (dim x1 = n)... rewrite H...
               rewrite <- S'dim in H13. rewrite <- sub_Plus in H13...
               assert (dim x1 = n)... rewrite H...
               apply le_trans with (S (dim x1))...
               assert (dim x1 = n)... rewrite H...
               rewrite <- S'dim in H13. rewrite <- sub_Plus in H13...
               assert (dim x1 = n)... rewrite H...
             unfold Included... inversion H12; clear H12... rewrite <- H13.
             unfold sub, In at 1... unfold Z, In at 1 in uinZ... rewrite <- S'dim in H12.
             assert (dim u = (S n))...
             rewrite PlusMinus_Singleton. 
               rewrite sub_Union. rewrite sub_sup_Empty_set...
               rewrite Empty_set_ident_left...
               unfold Included, sub, In at 2...
               unfold A. repeat (basic; intuition).
               right; exists u... unfold Z, In at 1 in uinZ...
               apply In_Complement...
               inversion H... assert (u = x3)...
               apply umax... unfold Z, In at 1... apply triangle_rest_trans with u... 
               apply uinZ. right with x3... apply uinZ... exists x1... left... 
               right with x3... exists x1... left... 
               unfold Z, In at 1... apply triangle_rest_trans with u... 
               apply uinZ. right with x3... apply uinZ... exists x1... left... 
               rewrite H17 in *...
               assert (S (dim x1) = dim u)...
               rewrite H13. unfold Z, In at 1 in uinZ...
               rewrite <- S'dim in H14...
             apply (Same_set_is_a_cell _ _ H12).
             rewrite Minus_Singleton. rewrite Plus_Singleton. rewrite sup_Union.
             rewrite sub_Union. rewrite sup_idemp. 
             rewrite <- Adim.
             rewrite sup_sub_Empty_set...
             rewrite sub_sup_Empty_set...
             rewrite sub_idemp.
             rewrite Empty_set_ident_left.
             rewrite Empty_set_ident_right. auto.
             rewrite Minus_Singleton. rewrite Plus_Singleton. rewrite sup_Union.
             rewrite sub_Union. rewrite sup_idemp. 
             rewrite <- Adim.
             rewrite sup_sub_Empty_set...
             rewrite sub_sup_Empty_set...
             rewrite sub_idemp.
             rewrite Empty_set_ident_left.
             rewrite Empty_set_ident_right. auto.
           apply Prop_3_3 in H12...
           apply (receptive_by_dimension) with (n:= S n) in H13.
           rewrite sub_Union in H13.
           rewrite sub_sup_Empty_set in H13...
           rewrite Empty_set_ident_left in H13.
           assert (A' == sub A' (S n)).
             unfold Same_set, Included...
             unfold sub, In at 1...
             apply eq_S. 
             unfold A' in H12. rewrite <- Adim in H12.
             repeat (basic; intuition)...
             assert (S (dim x1) = dim u)...
             assert (dim u = S n)...
               unfold In, Z in uinZ...
               unfold S', In in H20... 
               inversion H23; clear H23... apply triangle_rest_in_set in H24... 
           rewrite H12...
         assert (Included ((Plus (minus x)) ∩ (minus u)) Empty_set).
           apply (Included_trans _ (Plus (minus x) ∩ A')).
           unfold A', Included; repeat (basic; intuition)...
           assert (Disjoint A' (Plus (minus x))).
             apply Prop_2_1...
             exists B'...
           apply Disjoint_Intersection_condition.
           apply Disjoint_sym...
         assert (~(w = u))...
           rewrite <- H14 in *.
           assert (In Empty_set x0)... 
           apply H13. 
           apply In_Intersection... exists v...
         set (S'' := Setminus S' (Singleton u)).
         assert (Disjoint (Minus (S'')) (Plus (minus x))).
           admit. (* USE INDUCTION, FIX THIS LATER *)
         assert (In Empty_set x0)...
           apply Disjoint_Intersection_condition in H15.
           rewrite <- H15.
           apply In_Intersection...
           unfold S''; exists w...
           unfold Setminus, In at 1...
           inversion H16...
           exists v...

    assert ((S' ∪ (minus x)) moves (sub M (S n)) to B) as moves5.
      refine (Prop_2_3 _ _ _ _ _ movesMtoA _ _)...

    assert (Disjoint (Minus (minus x)) (Plus T)) as HardDisj2. 
        admit. (* ?? *)
  
    assert (((minus x) ∪ T) moves A  to (sub P (S n))) as moves6.
      refine (Prop_2_3 _ _ _ _ _ moves4 _ _)...

    assert (((S' ∪ (minus x)) ∪ T) moves (sub M (S n)) to (sub P (S n))) as moves7.
      refine (Prop_2_3 _ _ _ _ _ moves5 _ _)...
      apply Disjoint_Intersection_condition.
      rewrite Minus_Union.
      rewrite I_U_dist_r.
      assert ((Minus S' ∩ Plus T) == Empty_set).
        unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H5...
        inversion H6. inversion H7...
        refine (final_property _ (S') _ Tfinal _ _ x1 x2 _ _ _)...
          rewrite DisjUnion...
        rewrite Disjoint_sym...
        exists x0...
        inversion H5.
        rewrite H5; clear H5. rewrite Empty_set_ident_left.
      apply (Disjoint_Intersection_condition)...

    assert ( Minus S' ∩ Minus (minus x) == Empty_set) as PerpS'minusxB.
      unfold Same_set...
      rewrite <- (Intersection_idemp (Minus (minus x))).
      assert (Minus (minus x) ⊆ Plus (minus x) ∪ Minus (plus x) ).
        rewrite <- axiom1...
      rewrite H5 at 2...
      rewrite <- Intersection_trans...
      rewrite I_U_dist_l...
      unfold Included; intros; exfalso.
      apply In_Union in H6...
      apply In_Intersection in H7...
      apply In_Intersection in H6...
      inversion HardDisj...
      apply (H6 x0)...
      apply In_Intersection in H7...
      apply In_Intersection in H6...
      assert (Disjoint (Minus S') (Minus (plus x))).
      apply (Disjoint_Minus (sub M (S (S n))))...
      apply Disjoint_sym...
      rewrite DisjUnion...
      apply well_formed_sub... apply MPcell.
      inversion H6...
      apply (H10 x0)...

    assert ( Plus S' ∩ Plus (minus x) == Empty_set) as PerpS'minusxA.
      assert (Disjoint A (Plus (minus x))). 
        apply Prop_2_1...  exists B... 
      assert (Included (PlusMinus S') A).
        unfold PlusMinus, A. unfold Included; repeat (basic; intuition).
      assert (Setminus (Plus (minus x)) (Minus S') == Plus (minus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H9 x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_sym (Plus (minus x))).
      rewrite <- Intersection_trans.
      fold (PlusMinus S').
      rewrite H0...

    assert ( Plus T ∩ Plus (minus x) == Empty_set) as PerpTminusxA.
      unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H5...
        assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
        rewrite axiom1...
        apply In_Union in H5...
        assert (Disjoint (Plus (plus x)) (Plus T) ).
        apply (Disjoint_Plus (sub M (S (S n))))...
        rewrite DisjUnion...
        apply well_formed_sub...
        apply MPcell.
        inversion H5...
        apply (H9 x0)...
        inversion HardDisj2.
        apply (H5 x0)...
        inversion H5...

    assert ( Minus T ∩ Minus (minus x) == Empty_set) as PerpTminusxB.
      assert (Disjoint B (Minus (minus x))). 
        apply Prop_2_1_dual...  exists A... 
      assert (Included (MinusPlus T) B).
        unfold MinusPlus. rewrite Bdef. unfold Included; repeat (basic; intuition).
      assert (Setminus (Minus (minus x)) (Plus T) == Minus (minus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_sym (Minus (minus x))).
      rewrite <- Intersection_trans.
      fold (MinusPlus T).
      rewrite H0...

    assert (well_formed (S' ∪ (minus x))) as WF1.
      assert (Perp S' (minus x))...
      assert (True)...
      assert (sub (S' ∪ minus x) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H6...
          apply In_Union in H7...
          assert (dim x0 = S n)...
            rewrite <- S'dim in H6...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H7...
          inversion H6...
      apply weird_lemma_2...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.
        rewrite DisjUnion...

    assert (well_formed ((minus x) ∪ T)) as WF2.
      assert (Perp (minus x) T)...
        unfold Perp; split; rewrite Intersection_sym; assumption.
      assert (sub (minus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H6...
          apply In_Union in H7...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H7...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H6...
          inversion H6...
      apply weird_lemma_2...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.
        rewrite DisjUnion...

    assert (well_formed ((S' ∪ minus x) ∪ T)) as WF3.
      assert (Perp ((S' ∪ minus x)) T).
        unfold Perp.
        rewrite Plus_Union, Minus_Union.
        split.
        rewrite I_U_dist_r. rewrite (Intersection_sym (Plus (minus x))).
        rewrite PerpTminusxA. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Plus (sub M (S (S n))))...
          rewrite DisjUnion...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
        rewrite I_U_dist_r. rewrite (Intersection_sym (Minus (minus x))).
        rewrite PerpTminusxB. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Minus (sub M (S (S n))))...
          rewrite DisjUnion...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
      assert (sub (S' ∪ minus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H6...
          apply In_Union in H7...
          apply In_Union in H6...
          assert (dim x0 = S n)...
            rewrite <- S'dim in H7...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H6...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H6...
          inversion H6...
      apply weird_lemma_2...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.
        rewrite DisjUnion...

    assert (Y == (S' ∪ minus x) ∪ T) as Ycond.
      unfold Y.
      rewrite DisjUnion.
      rewrite Xsing.
      rewrite Minus_Singleton, Plus_Singleton.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      repeat (rewrite <- Disjoint_result)...
      rewrite Union_trans, <- (Union_sym _ T).
      rewrite <- Union_trans...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...

    assert (Y == (sub Y (S (S n)))) as dimY.
      unfold Y, Same_set, Included...
        unfold sub, In at 1...
        repeat (basic; intuition)...
        apply eq_S.
        apply (Minus_dim X Full_set (S n))...

    (* real work begins *)
    split.
    unfold is_a_cell...

    rewrite Ycond. apply (Inhabited_Included (minus x)).
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    rewrite Ycond. apply (Inhabited_Included (minus x)).
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    apply well_formed_Union...
    apply (well_formed_Included M).
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H8. assert (dim x0 <= n)...
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8...
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    apply well_formed_Union...
    apply (well_formed_Included P).
    apply MPcell. unfold tP. apply sup_Included...
    rewrite Ycond...
    unfold Y in H8. assert (dim x0 <= n)...
    apply In_Intersection in H8...
    apply In_Union in H9...
    assert (dim y = S n)... rewrite H6, H9 in H5...
    assert (dim y = S n)... unfold Minus, In at 1 in H8... inversion H8; clear H8...
    assert (dim x1 = S (S n))... rewrite H6, H9 in H5...

    rewrite Ycond...
    repeat (apply Finite_Union)...
      apply all_decidable. apply Finite_sup... apply MPcell.
      apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    rewrite Ycond...
    repeat (apply Finite_Union)...
    apply all_decidable... apply Finite_sup... apply MPcell.
    apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H5.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- dimY || rewrite <- sub_Setminus)...
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond. unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H5... rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell. apply eq_add_S in H5.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H5.
          rewrite <- H5 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

    rewrite Xsing.
    rewrite Minus_Singleton.
    rewrite DisjUnion.
    repeat (rewrite I_U_dist_l).
    unfold Same_set, Included...
      exfalso.
      repeat (basic; intuition).
      unfold S', In at 1 in H12...
      inversion H13; clear H13...
      assert (triangle x0 x1).
        apply rest_implies_full in H14...
      apply (axiom3b _ _ x) in H12...
      assert (Inhabited (plus x0))...
        apply plus_Inhabited...
        assert (S (dim x0) = dim x)...
        assert (dim x = S (S n))...
        rewrite H13 in H11. inversion H11.
        rewrite H15...
      inversion H11; clear H11...
      assert (In (Plus (minus x)) x1)...
        exists x0...
      assert (In (Plus T) x1)...
        exists x0...
      assert (In (Plus (plus x) ∪ Minus (minus x)) x1)...
        rewrite axiom1...
      apply In_Union in H15...
        inversion H14; clear H14...
        inversion H16; clear H16...
        assert (well_formed (sub M (S (S n))))... apply well_formed_sub. apply MPcell.
        assert (x2 = x3)...
          unfold well_formed in H15...
          refine (H20 _ _ _ n _ _ _)...
          rewrite DisjUnion...
          assert (In (sub M (S (S n))) x2)... rewrite DisjUnion...
          unfold perp in H15...
          assert (In Empty_set x1)...
            rewrite <- H21...
        apply (H9 x2); subst...
        apply (H6 x1)...
    inversion H5...
  Qed.

  Lemma Lemma_3_2_b_0_m :
    forall m, (Lemma_3_2_b_st 0 (S m)).
  Proof with intuition.
    apply Lemma_3_2_Step_2'.
    apply Lemma_3_2_b_0_1.
  Qed. 

  Lemma Lemma_3_2_b :
    forall n m, (Lemma_3_2_b_st n m).
  Proof.
    intros n.
    induction n.
      intros m; destruct m.
      apply Lemma_3_2_b_n_0.
      apply Lemma_3_2_b_0_m.
    destruct m.
      apply Lemma_3_2_b_n_0.
    apply Lemma_3_2_Step_2'.
    apply Lemma_3_2_Step_3'.
    apply IHn.
  Qed.

  Lemma Lemma_3_2_c :
    forall n m, (Lemma_3_2_c_st n m).
  Proof.
    intros.
    apply Lemma_3_2_Step_1'.
    apply Lemma_3_2_b.
  Qed.

  Lemma Lemma_3_2_b' :
    forall n m, (Lemma_3_2_b'_st n m).
  Proof.
    admit.
  Qed.

  Lemma Lemma_3_2_c' :
    forall n m, (Lemma_3_2_c'_st n m).
  Proof.
    admit.
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* mu and pi                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Function mu' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier :=
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => MinusPlus (mu' x (S n))
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x.
      induction (dim x).
        - induction n...
            + inversion teq0.
            + inversion teq.
        - induction n0...
            + rewrite Sn_minus_1...
            + apply IHn. simpl in teq... simpl in teq0...
     Qed.

  Definition mu (x : carrier) := fun y => exists n, In (mu' x n) y.

  Function pi' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier :=
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => PlusMinus (pi' x (S n))
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x.
      induction (dim x).
        - induction n...
            + inversion teq0.
            + inversion teq.
        - induction n0...
            + rewrite Sn_minus_1...
            + apply IHn. simpl in teq... simpl in teq0...
     Qed.
 
  Definition pi (x : carrier) := fun y => exists n, In (pi' x n) y.
 
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results from definitions                       *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma mu'_Singleton : forall x, (mu' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x.
    rewrite mu'_equation.
    assert (leb (dim x) (dim x) = true).
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true).
      induction (dim x)...
    rewrite H, H0...
  Qed.

  Lemma mu'_Empty_set : forall n x, S (dim x) <= n -> (mu' x n) = Empty_set.
  Proof with intuition.
    intros...
    rewrite mu'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H.
        - induction n0...
           + inversion H.
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0...
  Qed.

  Lemma mu'_MinusPlus : forall n x, (S n <= (dim x)) -> (mu' x n) = MinusPlus (mu' x (S n)).
  Proof with intuition.
    intros n x...
    rewrite mu'_equation.
    assert (leb n (dim x) = true).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
         simpl in H0...
    rewrite H0, H1...
  Qed.

  Lemma mu'_ind' :
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (mu' x (S n)) → P n (MinusPlus (mu' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e...
       apply beq_nat_false in e0...
       induction e...
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Hint Resolve le_not_gt.

  Lemma mu'_Finite : forall n x, Finite (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind'...
  Qed.

  Lemma mu'_dim : forall x n y, In (mu' x n) y -> dim y = n.
  Proof with intuition.
    intros x n.
    apply mu'_ind'...
     - inversion H...
     - unfold MinusPlus in H1...
       apply In_Intersection in H1...
       unfold Minus, In at 1 in H2...
       inversion H2; clear H2...
       assert (dim x0 = S n0)...
     - inversion H0...
  Qed.

  Lemma sub_mu : forall x n, sub (mu x) (S n) == mu' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold mu, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply mu'_dim in H...
       apply eq_add_S in H1.
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply mu'_dim in H...
  Qed.

  Lemma pi'_Singleton : forall x, (pi' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x.
    rewrite pi'_equation.
    assert (leb (dim x) (dim x) = true).
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true).
      induction (dim x)...
    rewrite H, H0...
  Qed.

  Lemma pi'_Empty_set : forall n x, S (dim x) <= n -> (pi' x n) = Empty_set.
  Proof with intuition.
    intros...
    rewrite pi'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H.
        - induction n0...
           + inversion H.
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0...
  Qed.

  Lemma pi'_PlusMinus : forall n x, S n <= (dim x) -> (pi' x n) = PlusMinus (pi' x (S n)).
  Proof with intuition.
    intros n x...
    rewrite pi'_equation.
    assert (leb n (dim x) = true).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
         simpl in H0...
    rewrite H0, H1...
  Qed.

  Lemma pi'_ind' :
     forall (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (pi' x (S n)) → P n (PlusMinus (pi' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e...
       apply beq_nat_false in e0...
       induction e...
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Lemma pi'_Finite : forall n x, Finite (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind'...
  Qed.

  Lemma pi'_dim : forall x n y, In (pi' x n) y -> dim y = n.
  Proof with intuition.
    intros x n.
    apply pi'_ind'...
     - inversion H...
     - unfold PlusMinus in H1...
       apply In_Intersection in H1...
       unfold Plus, In at 1 in H2...
       inversion H2; clear H2...
       assert (dim x0 = S n0)...
       assert (S (dim y) = dim x0)...
       rewrite H1 in H5...
     - inversion H0...
  Qed.

  Lemma sub_pi : forall x n, sub (pi x) (S n) == pi' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold pi, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply pi'_dim in H...
       apply eq_add_S in H1.
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply pi'_dim in H...
  Qed.

  Lemma mu'_Inhabited : forall x, forall n, n <= dim x -> Inhabited (mu' x n).
  Proof with intuition. 
    intros x.
    refine (mu'_ind' x (fun m => fun W => (m <= dim x -> Inhabited W)) _ _ _)...
    + exists x...
    + apply (MinusPlus_Inhabited _ n)... 
      - rewrite <- sub_mu.
        crush.
      - apply mu'_Finite.
    + exfalso. 
      apply le_not_gt in H0... 
  Qed.

  Lemma pi'_Inhabited : forall x, forall n, n <= dim x -> Inhabited (pi' x n).
  Proof with intuition. 
    intros x.
    refine (pi'_ind' x (fun m => fun W => (m <= dim x -> Inhabited W)) _ _ _)...
    + exists x...
    + apply (PlusMinus_Inhabited _ n)... 
      - rewrite <- sub_pi.
        crush.
      - apply pi'_Finite.
    + exfalso. 
      apply le_not_gt in H0... 
  Qed.

  Lemma perp_sym : forall a b, perp a b -> perp b a.
  Proof with intuition.
    unfold perp; intuition; rewrite Intersection_sym; assumption.
  Qed.

Lemma well_formed_fffff : forall A B, 
  well_formed A -> 
  well_formed B -> 
  (forall a b n, In A a -> In B b -> dim a = S n -> dim b = S n -> (~ perp a b) -> a = b) ->
  (forall a b  , In A a -> In B b -> dim a = 0 -> dim b = 0 -> a = b) ->
  well_formed (Union A B).
 Proof with intuition.
   intros.
   unfold well_formed in H.
   unfold well_formed in H0.
   unfold well_formed; intuition; repeat (basic; intuition).
   symmetry. apply H2...
   refine (H4 _ _ _ n _ _ _)...
   symmetry. apply (H1 _ _ n)... apply perp_sym in H6... 
   apply (H1 _ _ n)...
   refine (H5 _ _ _ n _ _ _)...
 Qed. 
 
  Notation "'<<' x '>>'" := ((mu x), (pi x)) (at level 85).

  Lemma atom_dim : forall x, celldim (<< x >>) (dim x).
  Proof with intuition.
    intros.
    unfold celldim, setdim...
    apply In_Union in H.
    inversion H; clear H. 
    + unfold mu, In at 1 in H0.
      inversion H0; clear H0.
      assert (x0 ∈ mu' x x1)...
      rewrite <- sub_mu in H0.
      unfold sub, In at 1 in H0...
      rewrite mu'_equation in H.
      remember (leb x1 (dim x)) as Q.
      destruct Q...
      symmetry in HeqQ. apply leb_complete in HeqQ. 
      assert (dim x0 = x1)...
      rewrite H0...
      inversion H. 
    + unfold pi, In at 1 in H0.
      inversion H0; clear H0.
      assert (x0 ∈ pi' x x1)...
      rewrite <- sub_pi in H0.
      unfold sub, In at 1 in H0...
      rewrite pi'_equation in H.
      remember (leb x1 (dim x)) as Q.
      destruct Q...
      symmetry in HeqQ. apply leb_complete in HeqQ. 
      assert (dim x0 = x1)...
      rewrite H0...
      inversion H. 
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 4                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Axiom mu_is_tight : forall x n, tight (sub (mu x) n).
  Axiom pi_is_tight : forall x n, tight (sub (pi x) n).

  Lemma Same_pair_dec : forall A B C D, Finite A ->
                                      Finite B ->
                                      Finite C ->
                                      Finite D ->
                                      (((A, B) === (C, D)) \/ ~((A, B) === (C, D))).
  Proof with intuition.
    intros.
    assert ((A == C) \/ ~(A == C))... apply Finite_eq_decidable...
    assert ((B == D) \/ ~(B == D))... apply Finite_eq_decidable...
      right; unfold Same_pair...
      right; unfold Same_pair...
  Qed.

  Lemma Same_pair_by_dim' : forall A B C D, (forall k, (sub A (S k), sub B (S k)) === (sub C (S k), sub D (S k)))
                               -> ((A, B) === (C, D)).
  Proof with intuition.
    unfold Same_pair...
    apply Same_set_by_dimension... apply H...
    apply Same_set_by_dimension... apply H...
  Qed.

  Lemma notatomic_lemma : 
    forall M P n, is_a_cell (M, P) -> celldim (M, P) n -> (0 < n) ->
    forall u, u ∈ (sub M (S n)) -> ~((M, P) === << u >>) ->
      (exists k, k < n /\ 
        ~((sub M (S (S k)), sub P (S (S k))) === (sub (mu u) (S (S k)), sub (pi u) (S (S k))))).
  Proof with intuition.
    intros.
    set (Z := (fun k => k < n /\
       ¬((sub M (S (S k)), sub P (S (S k))) === (sub (mu u) (S (S k)), sub (pi u) (S (S k)))))).
    assert (Finite Z).
      apply (Finite_Included'' (fun k => k < n))...
        apply lt_n_is_Finite. 
        unfold Z, Same_set, Included...
          unfold In at 1 in H4. unfold In at 1... 
        unfold In at 1 in H4... 
        rename x into k.
        assert ((((sub M (S (S k)), sub P (S (S k))) ===
        (sub (mu u) (S (S k)), sub (pi u) (S (S k)))) \/ ~(((sub M (S (S k)), sub P (S (S k))) ===
        (sub (mu u) (S (S k)), sub (pi u) (S (S k))))))).
          apply Same_pair_dec. 
            apply Finite_sub; apply H. 
            apply Finite_sub; apply H. 
            rewrite sub_mu. apply mu'_Finite. 
            rewrite sub_pi. apply pi'_Finite.
        intuition.
        right; unfold Z, In at 1...
        left; unfold Z, In at 1...
    apply (Finite_Empty_or_Inhabited) in H4...
    exfalso.
    apply H3.
    assert (forall j, j < n -> 
        ((sub M (S (S j)), sub P (S (S j))) ===
        (sub (mu u) (S (S j)), sub (pi u) (S (S j))))).
      intros.
      assert (((sub M (S (S j)), sub P (S (S j))) ===
      (sub (mu u) (S (S j)), sub (pi u) (S (S j)))) \/ ~((sub M (S (S j)), sub P (S (S j))) ===
      (sub (mu u) (S (S j)), sub (pi u) (S (S j)))))...
        apply Same_pair_dec. 
            apply Finite_sub; apply H. 
            apply Finite_sub; apply H. 
            rewrite sub_mu. apply mu'_Finite. 
            rewrite sub_pi. apply pi'_Finite.
      exfalso.
      assert (In Z j). 
        unfold Z, In at 1...
      rewrite H5 in H6...
    assert (forall j, n <= j -> 
        ((sub M (S (S j)), sub P (S (S j))) ===
        (sub (mu u) (S (S j)), sub (pi u) (S (S j))))).
      intros.
      assert (sub M (S (S j)) == Empty_set) as AA.
        unfold Same_set, Included...
        exfalso. unfold sub, In at 1 in H7...
        unfold celldim, setdim in H0...
        assert (dim x <= n). apply H0...
        assert (dim x = S j)...
        rewrite H10 in H7...
        assert (S j <= j)... apply le_trans with n...
        inversion H7...
      assert (sub P (S (S j)) == Empty_set) as BB.
        unfold Same_set, Included...
        exfalso. unfold sub, In at 1 in H7...
        unfold celldim, setdim in H0...
        assert (dim x <= n). apply H0...
        assert (dim x = S j)...
        rewrite H10 in H7...
        assert (S j <= j)... apply le_trans with n...
        inversion H7...
      assert (dim u = n) as CC...
      unfold Same_pair; rewrite AA, BB...
      clear AA BB.
      rewrite sub_mu, mu'_equation.
      remember (leb (S j) (dim u)) as Q.
      destruct Q; [exfalso | intuition].
        symmetry in HeqQ. apply leb_complete in HeqQ.
        rewrite CC in HeqQ. assert (S j <= j)... apply le_trans with n...
      rewrite sub_pi, pi'_equation.
      remember (leb (S j) (dim u)) as Q.
      destruct Q; [exfalso | intuition].
        symmetry in HeqQ. apply leb_complete in HeqQ.
        rewrite CC in HeqQ. assert (S j <= j)... apply le_trans with n...

      assert ((sub M 1, sub P 1) === (sub (mu u) 1, sub (pi u) 1)).
        unfold Same_pair...
        assert (∃ z : carrier, sub M 1 == Singleton z).
          apply (M_0_Inhabited M P)...
        inversion H7; clear H7.       
        assert (Included (sub (mu u) 1) (sub M 1)).
          rewrite sub_mu. 
          rewrite mu'_MinusPlus.
          rewrite <- sub_mu.
          assert (sub (mu u) 2 == sub M 2).
            unfold Same_pair in H4.
            symmetry. 
            apply H4...
          rewrite H7.
          rewrite <- sub_MinusPlus.
          apply sub_Included'. 
          apply Prop_2_1. apply H. exists P; apply H... 
          assert (dim u = n)... rewrite H7. inversion H1...
        rewrite H8.
        symmetry.
        apply Included_Singleton...
        rewrite sub_mu. apply mu'_Inhabited. apply le_0_n.
        rewrite H8 in H7...
        assert (∃ z : carrier, sub P 1 == Singleton z).
          apply (P_0_Inhabited M P)...
        inversion H7; clear H7.       
        assert (Included (sub (pi u) 1) (sub P 1)).
          rewrite sub_pi. 
          rewrite pi'_PlusMinus.
          rewrite <- sub_pi.
          assert (sub (pi u) 2 == sub P 2).
            unfold Same_pair in H4.
            symmetry. 
            apply H4...
          rewrite H7.
          rewrite <- sub_PlusMinus.
          apply sub_Included'. 
          apply Prop_2_1_dual. apply H. exists M; apply H... 
          assert (dim u = n)... rewrite H7. inversion H1...
        rewrite H8.
        symmetry.
        apply Included_Singleton...
        rewrite sub_pi. apply pi'_Inhabited. apply le_0_n.
        rewrite H8 in H7...
        
      unfold Same_pair. 
      split; apply Same_set_by_dimension...
      destruct k. apply H7.
      assert ({k < n} + {n <= k})...
        apply H4... apply H6...
      destruct k. apply H7.
      assert ({k < n} + {n <= k})...
        apply H4... apply H6...
    inversion H5; clear H5... 
    exists x... 
  Qed.

Lemma Lemma_3_2_b'_corr : forall x, forall M P n,
                          is_a_cell (M, P) /\ celldim (M, P) n ->
                          dim x = (S n) /\ minus x ⊆ sub P (S n) ->
                          well_formed ((sub M (S n) ∪ plus x) ∩ √minus x).
Proof with intuition.
  intros...
  pose (Lemma_3_2_b' n 1 (Singleton x)).
  assert (is_a_cell
            (sup M n
             ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)),
            sup P n
            ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
          ∧ Plus (Singleton x) ∩ sub P (S n) == Empty_set).
  apply a...
  apply Cardinality_Singleton_is_one... 
  unfold Included; repeat (basic; intuition)... 
    inversion H0. rewrite <- H4. unfold sub, In at 1...
  rewrite MinusPlus_Singleton...
  clear a.
  unfold is_a_cell in H0...
  assert ((∀ n0 : nat,
          well_formed
            (sub
               (sup P n
                ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
               (S n0)))).
               apply well_formed_by_dimension...
  specialize H11 with n.
  rewrite sub_Union in H11.
  rewrite sub_sup_Empty_set in H11...
  rewrite Empty_set_ident_left in H11...
  rewrite <- Setminus_is_Intersection_Complement in H11.
  rewrite sub_Setminus in H11.
  rewrite sub_Minus in H11.
  rewrite sub_Union in H11.
  rewrite sub_Plus in H11.
  rewrite sub_idemp in H11.
  rewrite sub_Singleton in H11...
  rewrite Minus_Singleton in H11.
  rewrite Plus_Singleton in H11.
  rewrite Setminus_is_Intersection_Complement in H11.
  rewrite (cell_dim_n_property M P)...
Qed.
  

Lemma Lemma_3_2_b_corr : forall x, forall M P n,
                          is_a_cell (M, P) /\ celldim (M, P) n ->
                          dim x = (S n) /\ plus x ⊆ sub M (S n) ->
                          well_formed ((sub P (S n) ∪ minus x) ∩ √plus x).
Proof with intuition.
  intros...
  pose (Lemma_3_2_b n 1 (Singleton x)).
  assert (is_a_cell
            (sup M n
             ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
            sup P n
            ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
          ∧ Minus (Singleton x) ∩ sub M (S n) == Empty_set).
  apply a...
  apply Cardinality_Singleton_is_one... 
  unfold Included; repeat (basic; intuition)... 
    inversion H0. rewrite <- H4. unfold sub, In at 1...
  rewrite PlusMinus_Singleton...
  clear a.
  unfold is_a_cell in H0...
  assert ((∀ n0 : nat,
          well_formed (sub (sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))) (S n0)))).
               apply well_formed_by_dimension...
  specialize H11 with n.
  rewrite sub_Union in H11.
  rewrite sub_sup_Empty_set in H11...
  rewrite Empty_set_ident_left in H11...
  rewrite <- Setminus_is_Intersection_Complement in H11.
  rewrite sub_Setminus in H11.
  rewrite sub_Plus in H11.
  rewrite sub_Union in H11.
  rewrite sub_Minus in H11.
  rewrite sub_idemp in H11.
  rewrite sub_Singleton in H11...
  rewrite Minus_Singleton in H11.
  rewrite Plus_Singleton in H11.
  rewrite Setminus_is_Intersection_Complement in H11.
  rewrite <- (cell_dim_n_property M P)...
Qed.

  Lemma Theorem_4_1 :
    forall M P n, is_a_cell (M, P) -> celldim (M, P) n -> (0 < n) ->
    forall u, u ∈ (sub M (S n)) -> ~((M, P) === << u >>) ->
    exists N Q L R m,
      is_a_cell (N, Q) /\
      is_a_cell (L, R) /\
      (m < n) /\
      (* ~(celldim (N, Q) m) /\      (* CONDITION GUARUNTEEING TERMINATION *)
      ~(celldim (L, R) m) /\   *)
      ((M, P) === composite m (N, Q) (L, R)).
  Proof with intuition.
    intros M P n cellcond dimcond nsize u udim notatomic. 

    set (Z := (fun m => (m < n) /\ ~((sub M (S (S m)), sub P (S (S m))) === (sub (mu u) (S (S m)), sub (pi u) (S (S m)))))).
    assert (Finite Z) as FinZ.
      apply (Finite_Included'' (fun m => (m < n)))...
      apply lt_n_is_Finite...
      unfold Z, Included, In...
      assert ({x < n} + {n <= x})...
        assert (((sub M (S (S x)), sub P (S (S x))) ===
             (sub (mu u) (S (S x)), sub (pi u) (S (S x))))
            ∨ ¬((sub M (S (S x)), sub P (S (S x))) ===
                (sub (mu u) (S (S x)), sub (pi u) (S (S x)))))...
        apply Same_pair_dec.
        apply Finite_sub; apply cellcond.
        apply Finite_sub; apply cellcond.
        rewrite sub_mu; apply mu'_Finite...
        rewrite sub_pi; apply pi'_Finite...
        right; unfold Z, In at 1...
        left; unfold Z, In at 1...
        right; unfold Z, In at 1...
        apply le_not_gt in b...

    assert (Inhabited Z) as Zinhab.
      apply Finite_Empty_or_Inhabited in FinZ...
      apply (notatomic_lemma _ _ n) in notatomic...
      inversion notatomic. exists x...
      unfold Z, In at 1...

    assert (exists m, (In Z m /\ forall r, In Z r -> r <= m)) as max_exists.
      apply Finite_nat_have_maximum_le_element...
    inversion max_exists as [m H]; clear max_exists; inversion H as [minZ mmax]; clear H.
   
    assert (m < n) as mltn.
      unfold Z, In at 1 in minZ...
    assert (~((sub M (S (S m)), sub P (S (S m))) === (sub (mu u) (S (S m)), sub (pi u) (S (S m))))) as maxprop1.
      unfold Z, In at 1 in minZ...
    assert (forall r, S m < r ->  ((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)))) as maxprop2.
      intros.
      assert (((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)))
            ∨ ((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)) → False))...
        apply Same_pair_dec...
     apply Finite_sub; apply cellcond.
     apply Finite_sub; apply cellcond.
     rewrite sub_mu; apply mu'_Finite.
     rewrite sub_pi; apply pi'_Finite.
     destruct r. inversion H.
     assert ({r < n} + {n <= r})...
     assert (In Z r).
     unfold Z, In at 1...
     assert (r <= m). apply mmax...
     exfalso... assert (m < r)... apply lt_not_le in H3...
     assert (dim u = n)...
     unfold Same_pair.
      rewrite sub_mu. rewrite mu'_Empty_set.
      rewrite sub_pi. rewrite pi'_Empty_set.
      assert (M == sup M (S n)).
        unfold Same_set, Included... unfold sup, In at 1...
      rewrite H2; rewrite sub_sup_Empty_set.
      assert (P == sup P (S n)).
        unfold Same_set, Included... unfold sup, In at 1...
      rewrite H3; rewrite sub_sup_Empty_set.
      idtac... idtac... intuition. rewrite H0... rewrite H0...

    assert ((sub M (S (S m))) == (sub (mu u) (S (S m))) ∪ ((sub M (S (S m))) ∩ (sub P (S (S m))))) as Mcond.
      inversion mltn...
      rewrite H.
      assert (dim u = n)...
      rewrite <- H0.
      rewrite sub_mu. rewrite mu'_Singleton.
      rewrite <- (cell_dim_n_property M P)...
      rewrite Intersection_idemp.
      symmetry.
      apply Union_Included_left. unfold Included...
      inversion H1... rewrite <- H2, H0... rewrite H0...
      rewrite <- (Full_set_ident_right M) at 1.
      rewrite <- (Full_set_property P).
      rewrite Union_sym at 1.
      rewrite I_U_dist_l at 1.
      rewrite sub_Union at 1.
      rewrite Union_sym at 1.
      rewrite (sub_Intersection M P).
      apply Union_Same_set_compat...
      unfold is_a_cell in cellcond...
      unfold moves_def in H7...
      rewrite H10.
      repeat (rewrite I_U_dist_r).
      rewrite (Intersection_sym _ (√P)).
      rewrite <- (Intersection_trans).
      rewrite (Intersection_sym _ P).
      rewrite Empty_set_property.
      rewrite Empty_set_zero_left.
      rewrite Empty_set_ident_left.
      fold (MinusPlus M).
      assert (sub (mu u) (S (S m)) == sub (MinusPlus M) (S (S m))).
        rewrite sub_mu.
        rewrite mu'_MinusPlus.
        rewrite <- sub_mu.
        rewrite sub_MinusPlus.
        assert (sub M (S (S (S m))) == sub (mu u) (S (S (S m)))).
          apply maxprop2...
        rewrite H7... assert (dim u = n)... rewrite H7, <- H0...
      rewrite H7.
      apply sub_Same_set...
      symmetry.
      apply Disjoint_result.
      apply Disjoint_Intersection_condition.
      assert (Disjoint P (Minus M))...
      apply Prop_2_1_dual... exists M...
      unfold MinusPlus; inversion H11; constructor...
      apply (H12 x)... apply (In_Intersection); repeat basic...
      apply all_decidable... apply cellcond.

    assert ((sub P (S (S m))) == (sub (pi u) (S (S m))) ∪ ((sub M (S (S m))) ∩ (sub P (S (S m))))) as Pcond.
      inversion mltn...
      rewrite H.
      assert (dim u = n)...
      rewrite <- H0.
      rewrite sub_pi. rewrite pi'_Singleton.
      rewrite <- (cell_dim_n_property M P)...
      rewrite Intersection_idemp.
      symmetry.
      apply Union_Included_left. unfold Included...
      inversion H1... rewrite <- H2, H0... rewrite H0...
      rewrite <- (Full_set_ident_right P) at 1.
      rewrite <- (Full_set_property M).
      rewrite Union_sym at 1.
      rewrite I_U_dist_l at 1.
      rewrite sub_Union at 1.
      rewrite Union_sym at 1.
      rewrite (Intersection_sym P M).
      rewrite (sub_Intersection M P).
      apply Union_Same_set_compat...
      unfold is_a_cell in cellcond...
      unfold moves_def in H9...
      rewrite H8.
      repeat (rewrite I_U_dist_r).
      rewrite (Intersection_sym _ (√M)).
      rewrite <- (Intersection_trans).
      rewrite (Intersection_sym _ M).
      rewrite Empty_set_property.
      rewrite Empty_set_zero_left.
      rewrite Empty_set_ident_left.
      fold (PlusMinus P).
      assert (sub (pi u) (S (S m)) == sub (PlusMinus P) (S (S m))).
        rewrite sub_pi.
        rewrite pi'_PlusMinus.
        rewrite <- sub_pi.
        rewrite sub_PlusMinus.
        assert (sub P (S (S (S m))) == sub (pi u) (S (S (S m)))).
          apply maxprop2...
        rewrite H9...
        assert (dim u = n)... rewrite H9, <- H0...
      rewrite H9.
      apply sub_Same_set...
      symmetry.
      apply Disjoint_result.
      apply Disjoint_Intersection_condition.
      assert (Disjoint M (Plus P))...
      apply Prop_2_1... exists P...
      unfold PlusMinus; constructor; inversion H11...
      apply (H12 x); repeat (basic; constructor)...
      repeat basic...
      repeat basic...
      apply all_decidable... apply cellcond.

    assert (Inhabited ((sub M (S (S m))) ∩ (sub P (S (S m))))) as MPInhab.
      assert (((sub M (S (S m))) ∩ (sub P (S (S m)))) == Empty_set \/ Inhabited ((sub M (S (S m))) ∩ (sub P (S (S m)))))...
        apply Finite_Empty_or_Inhabited.
        apply Finite_Intersection... apply Finite_sub... apply cellcond...
        apply all_decidable. apply Finite_sub... apply cellcond...
      exfalso.
      apply maxprop1...
      unfold Same_pair... rewrite Mcond, H0... rewrite Pcond, H0...
    inversion MPInhab as [w winMP]; clear MPInhab.
   
    set (X := fun k => triangle_rest (sub M (S (S m))) k w).
    assert (exists x, (In X x /\ forall r, In X r -> (triangle_rest X r x) -> x = r)) as Xhasmin.
      refine (minimal_exists' _ _ (S m) _ )...
      apply (Finite_Included'' (sub M (S (S m)))). apply Finite_sub. apply cellcond.
      unfold X. unfold Included... unfold In at 1 in H... inversion H...
      idtac... unfold X, In. apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold X, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S (S m))))...
      unfold X, Included... unfold In in H. inversion H...
    inversion Xhasmin as [x xismin]; clear Xhasmin.

    set (Y := fun k => triangle_rest (sub M (S (S m))) w k).
    assert (exists x, (In Y x /\ forall r, In Y r -> (triangle_rest Y x r) -> x = r)) as Yhasmax.
      refine (maximal_exists' _ _ (S m) _ )...
      apply (Finite_Included'' (sub M (S (S m)))). apply Finite_sub. apply cellcond.
      unfold Y. unfold Included... unfold In at 1 in H1... apply triangle_rest_in_set in H1...
      idtac... unfold Y, In. apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold Y, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S (S m))))...
      unfold Y, Included... unfold In in H1. apply triangle_rest_in_set in H1...
    inversion Yhasmax as [y yismax]; clear Yhasmax.

    assert ((minus x ⊆ sub M (S m)) /\ (plus y ⊆ sub P (S m))) as specialcond.
    split.
      apply (Included_trans _ (sub (MinusPlus M) (S m)))...
        unfold Included...
        assert (dim x = S m) as AA.
          unfold X, In at 1 in H...  inversion H...
        assert (S (dim x0) = dim x)...
        unfold sub, In at 1...
        unfold MinusPlus; apply In_Intersection...
          exists x... unfold X, In at 1 in H... inversion H...
          apply In_Complement... inversion H5; clear H5...
          assert (less x1 x). exists x0...
          assert (In X x1)... unfold X, In...
          right with x... unfold sub, In at 1...
          assert (S (dim x0) = dim x1)...
          rewrite <- H8, H4, AA...
          assert (x = x1). apply H0...
          right with x... left...
        subst...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1 M M)...
      apply cellcond. exists P. apply cellcond.
      apply (Included_trans _ (sub (PlusMinus M) (S m)))...
        unfold Included...
        assert (dim y = S m) as AA.
          unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...
        assert (S (dim x0) = dim y)...
        unfold sub, In at 1...
        unfold PlusMinus; apply In_Intersection...
          exists y... unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...
          apply In_Complement...
          inversion H5; clear H5...
          assert (less y x1). exists x0...
          assert (In Y x1)... unfold Y, In...
          apply triangle_rest_equiv.
          right with y... unfold sub, In at 1...
          assert (S (dim x0) = dim x1)...
          rewrite <- H8, H4, AA...
          apply triangle_rest_equiv...
          assert (y = x1). apply H2...
          right with x1... left...
          subst...
          rewrite AA in H4...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1_dual M P)...
      apply cellcond. exists M. apply cellcond.

    assert ((x ∈ ((sub M (S (S m))) ∩ (sub P (S (S m))))) \/ (y ∈ ((sub M (S (S m))) ∩ (sub P (S (S m)))))) as xory.
      inversion mltn. 
        left. rewrite H. rewrite <- (cell_dim_n_property M P)...
        rewrite Intersection_idemp. unfold X, In at 1 in H0... apply triangle_rest_in_set in H0... rewrite H in H6...

      assert (S (S m) <= n) as Smltn.
        rewrite <- H0.
        apply le_n_S...
      clear H0 H m0.
      assert (Disjoint (sub (mu u) (S (S m))) (sub M (S (S m)) ∩ sub P (S (S m)))) as JJ.
        rewrite sub_mu.
        rewrite mu'_MinusPlus.
        rewrite <- sub_mu.
        assert ((sub M (S (S (S m))), sub P (S (S (S m)))) === (sub (mu u) (S (S (S m))), sub (pi u) (S (S (S m))))).
          apply (maxprop2 (S (S m)))...
        unfold Same_pair in H...
        rewrite <- H6.
        assert (Disjoint P (Minus M))...
          apply Prop_2_1_dual.
          apply cellcond. exists M; apply cellcond.
        constructor...
        inversion H; clear H. apply (H9 x0)... 
        unfold MinusPlus in H8.
        repeat (basic; intuition). 
        inversion H10; exists x1...
        assert (dim u = n)...
        rewrite H...
      assert (~(x ∈ (sub (mu u) (S (S m)))) \/ ~(y ∈ (sub (mu u) (S (S m))))) as ASD.
        assert (~((x ∈ (sub (mu u) (S (S m)))) /\ (y ∈ (sub (mu u) (S (S m)))))) as Q.
          unfold not...
          assert (is_a_segment (sub (mu u) (S (S m))) (sub M (S (S m)))).
            apply Prop_1_3...
            rewrite sub_mu. apply mu'_Finite.
            apply mu_is_tight.
            apply well_formed_sub... apply cellcond.
            rewrite Mcond... 
          assert (In (sub (mu u) (S (S m))) w).
            apply weird_lemma_4 in H...
          apply (H9 x y)...
          inversion JJ; clear JJ.
        apply (H9 w)... 
      assert ((x ∈ sub (mu u) (S (S m))) \/ ~(x ∈ sub (mu u) (S (S m)))) as DD.
        apply Finite_are_decidable...
        rewrite sub_mu.
        apply mu'_Finite.
      inversion DD; clear DD; [right |left]...

      inversion ASD as [WER | WER]; clear ASD.
      inversion xismin as [QQQ WWW]; clear xismin.
      assert (In (sub M (S (S m))) x) as OOO. unfold In, X in QQQ. inversion QQQ...
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
      inversion yismax as [QQQ WWW]; clear yismax.
      assert (In (sub M (S (S m))) y) as OOO. unfold In, Y in QQQ.
        apply triangle_rest_in_set in QQQ...
      rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...

    inversion xory; clear xory.

    - (* x case *)
    assert (dim x = S m) as dimx.
      unfold X, In at 1 in xismin... apply triangle_rest_in_set in H0...
    assert (P moves Setminus M (Singleton x) to Setminus P (Singleton x)) as LLKK'.
      apply P_moves_Mx_to_Px...
      repeat basic; intuition.
    assert (M moves Setminus M (Singleton x) to Setminus P (Singleton x)) as LLKK.
      apply M_moves_Mx_to_Px...
      repeat basic; intuition.
    assert (Setminus M (Singleton x) moves Setminus (M ∪ plus x) (minus x) to P) as HHJJ.
      assert (Singleton x ∪ (M ∩ √Singleton x) == M).
        rewrite Union_sym, <- Setminus_is_Intersection_Complement.
        apply add_subtract'.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (M ∩ √Singleton x
                 moves (P ∪ Minus (M ∩ √Singleton x))
                       ∩ √Plus (M ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (M ∩ √Singleton x)) ∩ √Plus (M ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.    
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite <- H10...
    assert (Setminus P (Singleton x) moves Setminus (M ∪ plus x) (minus x) to P) as HHJJ'.
      assert (Singleton x ∪ (P ∩ √Singleton x) == P).
        rewrite Union_sym, <- Setminus_is_Intersection_Complement.
        apply add_subtract'.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (P ∩ √Singleton x
                 moves (P ∪ Minus (P ∩ √Singleton x))
                       ∩ √Plus (P ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (P ∩ √Singleton x)) ∩ √Plus (P ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.    
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite <- H10...
    assert ((Singleton x) moves M to Setminus (M ∪ plus x) (minus x)) as DDFF.
      assert (Singleton x ∪ (P ∩ √Singleton x) == P).
        rewrite Union_sym, <- Setminus_is_Intersection_Complement.
        apply add_subtract'.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (P ∩ √Singleton x
                 moves (P ∪ Minus (P ∩ √Singleton x))
                       ∩ √Plus (P ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (P ∩ √Singleton x)) ∩ √Plus (P ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.    
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
    assert (sub (Setminus (M ∪ plus x) (minus x)) (S m) moves sub M m to sub P m) as FFGG.
      pose (Lemma_3_2_b' m 1).
      unfold Lemma_3_2_b'_st in l.
      assert (is_a_cell 
            (sup (sup M (S m)) m ∪ ((sub ((sub M (S m)) ∪ (sup P m)) (S m) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)),
            sup ((sub M (S m)) ∪ (sup P m)) m ∪ ((sub ((sub M (S m)) ∪ (sup P m)) (S m) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
          ∧ Plus (Singleton x) ∩ sub ((sub M (S m)) ∪ (sup P m)) (S m) == Empty_set).
      apply l...
      apply Cardinality_Singleton_is_one.
      apply (source_is_a_cell (n-1))...
      destruct n. inversion mltn... simpl. rewrite <- minus_n_O.
        apply dimcond.
      destruct n. inversion mltn... simpl. rewrite <- minus_n_O.
        apply lt_n_Sm_le in mltn...
      unfold celldim, setdim... repeat (basic; intuition)...
        assert (dim x0 = m)... rewrite H10...
        assert (S (dim x0) <= m)...
      unfold Included, sub... unfold In at 1... inversion H6; clear H6; subst...
      rewrite MinusPlus_Singleton.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite sub_idemp.
        rewrite Empty_set_ident_right...
      unfold is_a_cell in H0...
      assert (sub (sup (sup M (S m)) m
      ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
         ∩ √Minus (Singleton x))) (S m) moves sub (sup (sup M (S m)) m
            ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
               ∩ √Minus (Singleton x))) m to sub (sup (sub M (S m) ∪ sup P m) m
         ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
            ∩ √Minus (Singleton x))) m).
      apply moves_by_dim...
      clear H15 H13.
      repeat (rewrite <- Setminus_is_Intersection_Complement in H14 ||
              rewrite sub_Union in H14 ||
              rewrite sub_Setminus in H14 ||
              rewrite sub_Plus in H14 ||
              rewrite sub_Minus in H14 ||
              rewrite sup_Union in H14 ||
              rewrite sup_idemp in H14 ||
              rewrite sub_idemp in H14).
      rewrite (sup_sup_min _ (S m) m) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sub_Empty_set (S m) m) in H14...
      rewrite (sub_Singleton_Empty_set _ (S m)) in H14...
      repeat (rewrite Plus_Empty_set in H14 ||
              rewrite Minus_Empty_set in H14 ||
              rewrite Empty_set_ident_left in H14 ||
              rewrite Empty_set_ident_right in H14 ||
              rewrite Setminus_Empty_set in H14).
      repeat (rewrite <- sub_Union in H14 ||
              rewrite <- sub_Setminus in H14 ||
              rewrite <- sub_Plus in H14 ||
              rewrite <- sub_Minus in H14).
      repeat (rewrite Minus_Singleton in H14 ||
              rewrite Plus_Singleton in H14||
              rewrite Empty_set_ident_right in H14 ).
      assumption.
      rewrite dimx in H13...

      set (R := (P ∩ (√(Singleton x)))).
      set (L := ((M ∩ √(Singleton x)) ∪ plus x) ∩ √minus x).
      set (Q := ((((sub M (S m)) ∪ (plus x)) ∩ √(minus x))) ∪ (sup P m) ∪ (Singleton x)).
      set (N := ((sup M (S m)) ∪ ((Singleton x)))).
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      + unfold N, Q.
        unfold is_a_cell...
        * exists x...
        * exists x...
        * apply well_formed_Union...
          apply well_formed_sup...
          apply cellcond. inversion H9; clear H9; subst. assert ( (dim x0) <= m)...
          rewrite H7, dimx in H6...
        * rewrite <- Setminus_is_Intersection_Complement.
          apply well_formed_Union...
          apply well_formed_Union...
          rewrite Setminus_is_Intersection_Complement.
          assert (well_formed ((sub (sup M (S m)) (S m) ∪ plus x) ∩ √minus x)).
          apply (Lemma_3_2_b'_corr x (sup M (S m)) (sub M (S m) ∪ sup P m) m)... 
          apply (source_is_a_cell (n-1) M P)... 
            assert (S (n - 1) = n)... 
              destruct n... simpl. rewrite <- minus_n_O...
            rewrite H6...
            destruct n... simpl. rewrite <- minus_n_O. apply lt_n_Sm_le...
          apply source_dim...
          rewrite sub_Union. rewrite sub_idemp.
          rewrite sub_sup_Empty_set...
          rewrite sub_sup_cancel in H6...
          apply well_formed_sup... apply cellcond.
          assert (dim x0 = m). 
            repeat (basic; intuition)... 
            assert (S (dim x0) = dim x)... rewrite dimx in H12... 
          assert (S (dim y0) <= m). 
            repeat (basic; intuition)...             
          rewrite <- H7, H6 in H10...
          assert ((dim x0) <= m). 
            repeat (basic; intuition)...
            assert (dim x0 = m)... rewrite H8...
            assert (S (dim x0) = dim x)... assert (dim x0 = m)... 
            rewrite dimx in H8... rewrite H14...
            apply le_trans with (S (dim x0))...
          assert ((dim y0) = S m). 
            inversion H9... rewrite <- H10...
          rewrite <- H7 in H10. rewrite H10 in H6... 
        * rewrite Union_sym.
          apply Finite_Union...
          apply Finite_sup... apply cellcond...
        * rewrite <- Setminus_is_Intersection_Complement.
          rewrite Union_sym. rewrite (Union_sym _ (sup P m)). rewrite (Union_sym _ (plus x)).
          repeat (apply Finite_Union)... apply all_decidable... apply Finite_sup...
          apply cellcond.
          apply Setminus_Finite'... apply Finite_Union...  apply Finite_sub...
          apply cellcond.
          apply Finite_sup... apply cellcond.
        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite <- H6 in a...
            assert (S m = k)... rewrite <- H7 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite sub_idemp ||
                    rewrite (sub_sup_cancel (S m) (S m)) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ). (**)
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (sub_sub_Empty_set)
                    ); try (rewrite dimx in *)...
            apply Empty_set_moves.

        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite <- H6 in a...
            assert (S m = k)... rewrite <- H7 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (sub_sup_cancel m) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- sub_Plus || rewrite <- sub_Minus ||
                    rewrite <- sub_Union || rewrite <- sub_Setminus). (**)
            repeat (rewrite Plus_Singleton || rewrite Minus_Singleton).
            assumption. 
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite sub_idemp || rewrite sub_sub_Empty_set ||
                    rewrite (sub_sup_cancel (S m) (S m)) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- sub_Plus || rewrite <- sub_Minus ||
                    rewrite <- sub_Union || rewrite <- sub_Setminus ||
                    rewrite Minus_Singleton || rewrite Plus_Singleton).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S k))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (sub_sub_Empty_set)
                    ); try (rewrite dimx in *)...
            apply Empty_set_moves.

      + unfold L, R.
        unfold is_a_cell...
        * assert (Inhabited (plus x))... apply plus_Inhabited...
          assert (dim x = S m).
            rewrite <- sub_Intersection in H...
          rewrite H6...
          inversion H6; clear H6... exists x0...
        * assert (Inhabited (sub P 1)).
            apply (P_0_Inhabited' M P)...
          inversion H6; clear H6...
          unfold sub, In at 1 in H7...
          inversion H8...
          exists x0...
          apply In_Intersection...
          apply In_Complement... inversion H7; clear H7; subst...
        * apply (well_formed_Included ((M ∪ plus x) ∩ √minus x)).
          apply well_formed_by_dimension. intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Setminus || rewrite sub_Union ||
                  rewrite <- Minus_Singleton || rewrite <- Plus_Singleton ||
                  rewrite sub_Minus || rewrite sub_Plus).
          assert ({k = m} + {~(k = m)})... apply eq_nat_dec.
            rename a into H7.
            rewrite H7...
          repeat (rewrite sub_Singleton || rewrite Minus_Singleton ||
                  rewrite Plus_Singleton). 
                  rewrite Setminus_is_Intersection_Complement.
                  assert (well_formed ((sub (sup M (S m)) (S m) ∪ plus x) ∩ √minus x)).
                  apply (Lemma_3_2_b'_corr x (sup M (S m)) (sub M (S m) ∪ sup P m) m)...
                  apply (source_is_a_cell (n-1))... 
                    assert (S (n-1) = n)... 
                      destruct n... simpl. rewrite <- minus_n_O...
                    rewrite H6...
                    apply lt_le_S in mltn. 
                      destruct n... simpl. rewrite <- minus_n_O...
                  apply source_dim...
                  repeat (rewrite sub_Union || rewrite sub_idemp || 
                          rewrite sub_sup_Empty_set || rewrite Empty_set_ident_right)...
                  rewrite sub_sup_cancel in H6... assumption.
            repeat (rewrite sub_Singleton_Empty_set ||
                    rewrite Minus_Empty_set || 
                    rewrite Plus_Empty_set || 
                    rewrite Setminus_Empty_set); try rewrite dimx...
                    rewrite Empty_set_ident_right.
                    apply well_formed_sub. apply cellcond. 
          repeat (rewrite <- Setminus_is_Intersection_Complement). 
          unfold Included; repeat (basic; intuition). 
        * apply (well_formed_Included P)... apply cellcond.
          apply Intersection_Included_cancel_right...
        * repeat (rewrite <- Setminus_is_Intersection_Complement).
          rewrite Union_sym.
          apply Setminus_Finite'... apply Finite_Union... apply Setminus_Finite'... apply cellcond.
        * rewrite <- Setminus_is_Intersection_Complement.
          apply Setminus_Finite'... apply cellcond.
        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            apply eq_add_S in H6. rewrite <- H6 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ).
            assumption. 
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton 
                    ).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S k))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            inversion b; clear b.
            repeat (rewrite <- (sub_Setminus)).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Setminus_Empty_set))...
            apply moves_by_dim... apply cellcond.
            rewrite dimx in H8. rewrite H8 in H6...
           
        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k (S m)); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ).
            apply moves_by_dim...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim, cellcond.

      + split.
     
        * unfold N, L...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (Setminus_Empty_set)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set ) ||
                  rewrite (sub_minus_Empty_set ) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite dimx in *)...
          assert (S m = k)... rewrite <- H7 in a...
          rewrite b in *.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_Singleton_Empty_set x (S m)) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_right...
          rewrite dimx in H6...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite sub_sub_Empty_set ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set x ) ||
                  rewrite (sub_minus_Empty_set x ) ||
                  rewrite sub_Singleton ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          rewrite Union_sym.
          apply Add_Setminus_Singleton... apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite dimx in H6...
          rewrite dimx in H6...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set) ||
                  rewrite (sub_minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite dimx in * )...
          rewrite dimx in H6...

        * unfold Q, R...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (sub_idemp).
          rewrite (sub_sup_Empty_set m (S m))...
          rewrite (Empty_set_ident_right)...
          rewrite (Empty_set_ident_right)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set ) ||
                  rewrite (sub_minus_Empty_set ) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite dimx in *)...
          assert (S m = k)... rewrite <- H7 in a...
          rewrite b in *.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_Singleton_Empty_set x (S m)) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left...
          rewrite dimx in H6...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite sub_sub_Empty_set ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set x ) ||
                  rewrite (sub_minus_Empty_set x ) ||
                  rewrite sub_Singleton ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          rewrite Union_sym.
          apply Add_Setminus_Singleton...
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite dimx in H6...
          rewrite dimx in H6...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set) ||
                  rewrite (sub_minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite dimx in * )...
                    rewrite dimx in H6...

      (* y case *)
    -
    assert (dim y = S m) as ydim.
      unfold Y, In at 1 in yismax... apply triangle_rest_in_set in H2...
    assert (P moves Setminus M (Singleton y) to Setminus P (Singleton y)) as LLKK'.
      apply P_moves_Mx_to_Px... repeat (basic; intuition)...
    assert (M moves Setminus M (Singleton y) to Setminus P (Singleton y)) as LLKK.
      apply M_moves_Mx_to_Px... repeat (basic; intuition)...
    assert (Setminus M (Singleton y) moves M to Setminus (P ∪ minus y) (plus y)) as HHJJ.
      assert (Setminus M (Singleton y) ∪ Singleton y == M).
        apply add_subtract'.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Setminus M (Singleton y) moves M
               to (M ∪ Plus (Setminus M (Singleton y)))
                  ∩ √Minus (Setminus M (Singleton y)))
              ∧ (Singleton y
                 moves (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) to P)
                ∧ (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) ==
                  (M ∪ Plus (Setminus M (Singleton y)))
                  ∩ √Minus (Setminus M (Singleton y))).
      apply Prop_2_4_exact.    
      apply Finite_Singleton.
      rewrite Setminus_is_Intersection_Complement.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite PlusMinus_Singleton. apply Included_trans with (sub P (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite H10...
      rewrite <- Setminus_is_Intersection_Complement...
    assert (Setminus P (Singleton y) moves M to Setminus (P ∪ minus y) (plus y)) as HHJJ'.
      assert (Setminus P (Singleton y) ∪ Singleton y == P).
        apply add_subtract'.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Setminus P (Singleton y) moves M
               to (M ∪ Plus (Setminus P (Singleton y)))
                  ∩ √Minus (Setminus P (Singleton y)))
              ∧ (Singleton y
                 moves (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) to P)
                ∧ (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) ==
                  (M ∪ Plus (Setminus P (Singleton y)))
                  ∩ √Minus (Setminus P (Singleton y))).
      apply Prop_2_4_exact.    
      apply Finite_Singleton.
      rewrite Setminus_is_Intersection_Complement.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite PlusMinus_Singleton. apply Included_trans with (sub P (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite H10...
      rewrite <- Setminus_is_Intersection_Complement...
    assert (sub (Setminus (P ∪ minus y) (plus y)) (S m) moves sub M m to sub P m) as FFGG.
      pose (Lemma_3_2_b m 1).
      unfold Lemma_3_2_b_st in l.
      assert (is_a_cell
          (sup (sub P (S m) ∪ sup M m) m ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y)),
            sup (sup P (S m)) m ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y)))
          ∧ Minus (Singleton y) ∩ sub (sub P (S m) ∪ sup M m) (S m) == Empty_set).
      apply l...
      apply Cardinality_Singleton_is_one.
      apply (target_is_a_cell (n-1))...
      destruct n. inversion mltn... simpl. rewrite <- minus_n_O.
        apply dimcond.
      destruct n. inversion mltn... simpl. rewrite <- minus_n_O.
        apply lt_n_Sm_le in mltn...
      unfold celldim, setdim... repeat (basic; intuition)...
        assert (dim x0 = m)... rewrite H10...
        assert (S (dim x0) <= m)...
      unfold Included, sub... unfold In at 1... inversion H6; clear H6; subst...
      rewrite PlusMinus_Singleton.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite sub_idemp.
        rewrite Empty_set_ident_right...
      unfold is_a_cell in H0...
      assert (sub (sup (sup P (S m)) m
      ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
         ∩ √Plus (Singleton y))) (S m)
      moves sub (sup (sub P (S m) ∪ sup M m) m
            ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
               ∩ √Plus (Singleton y))) m
      to sub (sup (sup P (S m)) m
         ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
            ∩ √Plus (Singleton y))) m).
      apply moves_by_dim...
      clear H15 H13.
      repeat (rewrite <- Setminus_is_Intersection_Complement in H14 ||
              rewrite sub_Union in H14 ||
              rewrite sub_Setminus in H14 ||
              rewrite sub_Plus in H14 ||
              rewrite sub_Minus in H14 ||
              rewrite sup_Union in H14 ||
              rewrite sup_idemp in H14 ||
              rewrite sub_idemp in H14).
      rewrite (sup_sup_min _ (S m) m) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sub_Empty_set (S m) m) in H14...
      rewrite (sub_Singleton_Empty_set _ (S m)) in H14...
      repeat (rewrite Plus_Empty_set in H14 ||
              rewrite Minus_Empty_set in H14 ||
              rewrite Empty_set_ident_left in H14 ||
              rewrite Empty_set_ident_right in H14 ||
              rewrite Setminus_Empty_set in H14).
      repeat (rewrite <- sub_Union in H14 ||
              rewrite <- sub_Setminus in H14 ||
              rewrite <- sub_Plus in H14 ||
              rewrite <- sub_Minus in H14).
      repeat (rewrite Minus_Singleton in H14 ||
              rewrite Plus_Singleton in H14||
              rewrite Empty_set_ident_right in H14 ).
      assumption.
      rewrite ydim in H13...

      set (N := (M ∩ (√(Singleton y)))).
      set (Q := ((P ∩ √(Singleton y)) ∪ minus y) ∩ √plus y).
      set (L := ((sup M m ∪ (((sub P (S m)) ∪ (minus y)) ∩ √(plus y))) ∪ (Singleton y))).
      set (R := ((sup P (S m)) ∪ ((Singleton y)))).
      assert (sup (sup M m ∪ sub P (S m)) m == sup M m).
        crush. exfalso. rewrite H7 in H8... left...
      assert ((sub (sup M m ∪ sub P (S m)) (S m)) == sub P (S m)).
        crush. exfalso. rewrite H9 in H8... right...
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      (* N and Q case *)
      + unfold N, Q.
        unfold is_a_cell...
        * pose (M_0_Inhabited' _ _ cellcond). inversion i; clear i. exists x0.
          split. apply H8. apply In_Complement...
          inversion H9; clear H9; subst.
          assert (dim x0 = 0)...
        * assert (Inhabited (MinusPlus (Singleton y))). apply (MinusPlus_Inhabited _ m)...
            apply In_Intersection in H... unfold Included... inversion H...
            rewrite <- H10... exists y...
          inversion H8. exists x0. rewrite I_U_dist_r. right.
          unfold MinusPlus in H9. rewrite Plus_Singleton, Minus_Singleton in H9... 
        * apply (well_formed_Included M). apply cellcond.
          apply Intersection_Included_cancel_right...
        * apply (well_formed_Included ((P ∪ minus y) ∩ √plus y)).
          apply well_formed_by_dimension. intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Setminus || rewrite sub_Union ||
                  rewrite <- Minus_Singleton || rewrite <- Plus_Singleton ||
                  rewrite sub_Minus || rewrite sub_Plus).
          assert ({k = m} + {k = m -> False})... apply eq_nat_dec.
            rename a into H9.
            rewrite H9...
          repeat (rewrite sub_Singleton || rewrite Minus_Singleton ||
                  rewrite Plus_Singleton). 
                  rewrite Setminus_is_Intersection_Complement.
                  assert (well_formed ((sub (sup P (S m)) (S m) ∪ minus y) ∩ √plus y)).
                  apply (Lemma_3_2_b_corr y (sub P (S m) ∪ sup M m) (sup P (S m)) m)...
                  apply (target_is_a_cell (n-1))... 
                    assert (S (n-1) = n)... 
                      destruct n... simpl. rewrite <- minus_n_O...
                    rewrite H8...
                    apply lt_le_S in mltn. 
                      destruct n... simpl. rewrite <- minus_n_O...
                  apply target_dim...
                  repeat (rewrite sub_Union || rewrite sub_idemp || 
                          rewrite sub_sup_Empty_set || rewrite Empty_set_ident_right)...
                  rewrite sub_sup_cancel in H8... assumption.
            repeat (rewrite sub_Singleton_Empty_set ||
                    rewrite Minus_Empty_set || 
                    rewrite Plus_Empty_set || 
                    rewrite Setminus_Empty_set); try rewrite ydim...
                    rewrite Empty_set_ident_right.
                    apply well_formed_sub. apply cellcond. 
          repeat (rewrite <- Setminus_is_Intersection_Complement). 
          unfold Included; repeat (basic; intuition). 
        * rewrite <- Setminus_is_Intersection_Complement...
          apply Setminus_Finite'... apply cellcond.
        * apply Setminus_Finite... rewrite Union_sym.
          apply Finite_Union...
          apply Setminus_Finite... apply cellcond.
        * apply moves_by_dim'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite <- Plus_Singleton || rewrite <- Minus_Singleton).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          repeat (rewrite sub_Plus || rewrite sub_Minus).
          assert ({k < S m} + {k = S m} + {k = S (S m)} + {S (S m) < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
          rewrite <- H8 in a...
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          rewrite Minus_Singleton, Plus_Singleton.
          apply moves_by_dim...
          rewrite b.
          rewrite (sub_Singleton_Empty_set _ (S (S (S m))))...
          rewrite Plus_Empty_set, Minus_Empty_set...
          rewrite Empty_set_ident_right.
          repeat (rewrite Setminus_Empty_set).
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          apply moves_by_dim...
          rewrite ydim in H8...
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
        * apply moves_by_dim'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite <- Plus_Singleton || rewrite <- Minus_Singleton).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          repeat (rewrite sub_Plus || rewrite sub_Minus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
          rewrite <- H8 in a...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y m) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...         
          rewrite Minus_Singleton, Plus_Singleton.
          assumption.
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          rewrite Minus_Singleton, Plus_Singleton.
          apply moves_by_dim...
          inversion b; clear b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                  rewrite (sub_Singleton_Empty_set _ (S (S (S (S m))))) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          apply moves_by_dim...
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim, cellcond.
          rewrite H10 in H8...
          rewrite H10 in H8...
          rewrite H10 in H8...

      (* L and R case *)
      + unfold L, R. 
        apply (Same_set_is_a_cell ((sup M m ∪ ((sub P (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P (S m) ∪ Singleton y))...
        apply (Same_set_is_a_cell ((sup (sup M m ∪ sub P (S m)) m
        ∪ ((sub (sup M m ∪ sub P (S m)) (S m) ∪ Minus (Singleton y))
        ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P (S m) ∪ Singleton y))...
        apply (Lemma_3_2_c _ 1).
        apply Cardinality_Singleton_is_one.
        split.
        assert (is_a_cell (target m (M, P))) as QRQR.
          apply (target_is_a_cell n)...
          unfold celldim, setdim in *...
        unfold target in QRQR. eapply (Same_set_is_a_cell). exact QRQR.
          rewrite Union_sym... reflexivity.
        unfold celldim, setdim...
          inversion H8; clear H8; subst.
          inversion H9; clear H9; subst.
          apply (le_trans _ (S (dim x0)))...
          unfold sub, In at 1 in H8...
          apply eq_add_S in H10.
          rewrite H10; left.
          unfold sup, In at 1 in H9...
        split.
        unfold Included...
          inversion H8; clear H8; subst.
          unfold In, sub...
          constructor.
        apply well_formed_Singleton.
        rewrite sub_Union.
        rewrite sub_idemp.
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        unfold Included...
          apply H7...
          unfold PlusMinus in H8. rewrite Plus_Singleton in H8...
          apply In_Intersection in H8... idtac...
        rewrite H0, H1...
        rewrite (Minus_Singleton y), (Plus_Singleton y)...
     
      + split.

        * unfold L, N...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (sub_idemp).
          rewrite (sub_sup_Empty_set m (S m))...
          rewrite (Empty_set_ident_left)...
          rewrite (Empty_set_ident_right)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = (S m)} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y (S m)) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_right...
          rewrite ydim in H8...
          rewrite b.
          repeat (rewrite (sub_sub_Empty_set (S m) (S (S m))) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set y (S m)) ||
                  rewrite (sub_minus_Empty_set y (S m)) ||
                  rewrite (sub_Singleton y (S m)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          apply Add_Setminus_Singleton...
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite ydim in H8...
          rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in * )...
          rewrite ydim in H8...

        * unfold Q, R.
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite <- b.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y k) ||
                  rewrite (sub_minus y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left...
          rewrite ydim in H8... rewrite b... rewrite b...
          repeat (rewrite (sub_sub_Empty_set (S m) (S k)) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton y k) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          apply Add_Setminus_Singleton.
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite ydim in H8...
          rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in * )...
 Qed.

End ParityComplexTheory.                                   





