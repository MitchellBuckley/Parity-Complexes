
(* Written by Mitchell Buckley 13/06/2014 *)

Require Import Ensembles.
Require Import myFiniteDefs.
Require Import Relations.
Require Import mySetoids.
Require Import Utf8_core.
Require Import Max Le.
Require Import Arith.
Require Import Setoid.
Require Import Recdef.
Require Import PreparityComplexes.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Parity Complex Definitions                           *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Module Type ParityComplex.

  Declare Module C : PreParity.
  Import C.
  Module PPT := PreParityTheory C.
  Import PPT.

  Axiom axiom1 :
    forall (x : carrier),
      Union (Plus (plus x)) (Minus (minus x)) == Union (Plus (minus x)) (Minus (plus x)).

  Axiom axiom2a :
    forall x, well_formed (plus x).

  Axiom axiom2b :
    forall x, well_formed (minus x).

  Axiom axiom3a:
    forall x y : carrier,
      triangle x y -> triangle y x -> x = y.

  Axiom axiom3b:
    forall x y z : carrier,
    triangle x y ->
    (~ (In (plus z) x /\ In (minus z) y) /\ ~ (In (plus z) y /\ In (minus z) x)).

  Hint Resolve axiom2a axiom2b.

End ParityComplex.

Module ParityComplexTheory (M : ParityComplex).

  Import M.
  Import C.
  Import PPT.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma triangle_rest_dec :
    forall T,
      Finite T ->
      forall x z, (triangle_rest T z x \/ ~(triangle_rest T z x)).
  Proof with intuition.
   intros T TFin.
   assert (exists n, Cardinal T n) as K.
   apply Cardinality_exists...
   inversion K as [n TCard]; clear K.
   revert n T TFin TCard.
   refine (strong_induction _ _ _)...
     - right...
       apply Cardinality_zero_Empty_set in TCard.
       rewrite TCard in H...
       apply triangle_rest_in_set in H...
     - set (R := fun r => less z r /\ r ∈ T).
       assert (Finite R) as RFin.
         apply (Finite_Included T)...
         unfold R, Included... unfold In at 1 in H0...
         assert ((less z x0) \/ ~(less z x0))...
         apply less_decidable.
         left... unfold R, In at 1...
         right... unfold R, In at 1 in H1...
       assert (exists n, Cardinal R n) as J.
       apply Cardinality_exists...
       inversion J as [k RCard]; clear J...
       assert (decidable T) as Tdec.
         apply Finite_are_decidable...
       assert ((x ∈ T) \/ ~(x ∈ T))...
         apply Tdec.
       assert ((z ∈ T) \/ ~(z ∈ T))...
         apply Tdec.
       assert ((z = x) \/ ~(z = x))...
         apply carrier_decidable_eq.
       left.
       rewrite H3; left...

       destruct k.
       + right...
         inversion H0...
         assert (y ∈ R).
           unfold R, In at 1...
           apply triangle_rest_in_set in H6...
         apply Cardinality_zero_Empty_set in RCard.
         rewrite RCard in H9...
       + set (T' := Setminus T (Singleton z)).
         assert (Finite T') as T'Fin.
           unfold T'...
           rewrite Setminus_is_Intersection_Complement.
           apply Setminus_Finite...
         set (Q := fun w => triangle_rest T' w x).
         assert (Finite Q) as QFin.
           apply (Finite_Included T)...
           unfold Q, Included, In at 1...
           apply triangle_rest_in_set in H0...
           unfold T', In at 1 in H4... inversion H4...
           assert ((x0 = z) \/ ~(x0 = z)).
             apply carrier_decidable_eq...
           idtac...
           right...
           rewrite H5 in H4.
           assert (In T' z).
             unfold Q, In at 1 in H4...
             apply triangle_rest_in_set in H4...
           unfold T', In at 1 in H6...
           inversion H6...
           assert (triangle_rest T' x0 x ∨ (triangle_rest T' x0 x → False)).
             apply (H n)...
             unfold T'. apply (Cardinal_Setminus carrier_decidable_eq (S n))...
           idtac...
         assert (Finite (Intersection R Q)).
           apply Finite_Intersection...
         apply (Finite_Empty_or_Inhabited) in H0...
         * right...
           inversion H0...
            subst.
           assert (In Empty_set y)...
             rewrite <- H4.
             apply In_Intersection...
             unfold R, In at 1...
             apply triangle_rest_in_set in H7...
             unfold Q, In at 1...
             assert (triangle z y)...
             right with y... left...

             assert (~(z = y)).
               intuition. rewrite H9 in H6; apply less_irrefl in H6...
             clear H6.
             induction H7...
               left...
               unfold T', Setminus...
               right with y...
               unfold T', Setminus, In...
               apply H11...
               apply clos_rt_rt1n_iff.
               apply clos_rt_rtn1_iff. right with x...
               apply clos_rt_rtn1_iff.
               apply clos_rt_rt1n_iff. apply H8.
               rewrite H12 in *; clear H12.
               apply H9; apply axiom3a... right with y... left...

         * left...
           inversion H4; clear H4.
           apply In_Intersection in H0...
           unfold R, In at 1 in H4.
           unfold Q, In at 1 in H5.
           right with x0...
           apply (triangle_rest_Included T')...
           unfold T'...
           apply Setminus_Included.

       + right... apply H2... apply triangle_rest_in_set in H0...
       + right... apply H1... apply triangle_rest_in_set in H0...
  Qed.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma well_formed_sup : forall R n, well_formed R -> well_formed (sup R n).
  Proof with intuition.
    intros.
    apply (well_formed_Included R)...
  Qed.

  Lemma well_formed_sub : forall R n, well_formed R -> well_formed (sub R n).
  Proof with intuition.
    intros.
    apply (well_formed_Included R)...
  Qed.

  Lemma minimal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set (S n))
      -> exists m, m ∈ X /\ (forall y, y ∈ X -> (triangle_rest X y m) -> m = y).
  Proof with intuition.
    refine (strong_induction _ _ _)...

    - apply Cardinality_one_Singleton in H.
      inversion H; clear H.
      exists x... rewrite H1...

    - assert (Inhabited X).
        apply Cardinal_Sn in H0...
      inversion H2; clear H2.

      set (Z := (fun y => triangle_rest X y x)).

      assert (Z ⊆ X) as SS.
        unfold Z, Included, In at 1... inversion H2...

      assert (Finite Z /\ Inhabited Z).
        split. apply (Finite_Included X)... apply Cardinal_are_Finite in H0...
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0...
        exists x... unfold Z, In at 1... left...

      assert (exists k, Cardinal Z (S k)) as K.
        apply Finite_Inhabited_Cardinal_Sn...
        inversion K as [k L]; clear K...

      destruct k...

      + exists x...
        assert (y ∈ Z)...
        assert (x ∈ Z)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L...
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n).
          assert (S (S k) <= S (S n))...
            refine (Cardinal_le carrier_decidable_eq Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n...

        inversion H2; clear H2.

        * assert (X == Z).
            apply (Cardinal_eq_Included_Same_set carrier_decidable_eq (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧
             (∀ y : carrier, y ∈ W → triangle_rest W y m → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply (Cardinal_Setminus carrier_decidable_eq (S (S k)))... rewrite H6...
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...

          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ).
            apply axiom3a. apply (rest_implies_full X). rewrite H12...
            apply (rest_implies_full X). assert (maxZ ∈ X)... apply H7. rewrite H2 in H11...
          rewrite <- H11 in H7...
          unfold W, In at 1, Setminus in H7...
          induction H10...
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear x0 H15.
            assert (z = x).
            apply axiom3a. apply (rest_implies_full X). assert (z ∈ Z)...
            rewrite <- H2... apply triangle_rest_in_set in H12...
            apply (rest_implies_full X). apply (tr_trans _ _ y)...
            rewrite H13 in H7.
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...

          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z y m → m = y)) as M.
          refine (H (S k) _ _ _ n0 _ )... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (y ∈ Z)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          induction H10.
            left...
            assert (y ∈ Z).
            unfold Z, In at 1... apply (triangle_rest_trans X _ z)...
            apply (tr_trans _ _ y)...
  Qed.

  Lemma maximal_exists :
    forall t, forall X, Cardinal X (S t) -> forall n, Included X (sub Full_set (S n))
      -> exists m, m ∈ X /\ (forall y, y ∈ X -> (triangle_rest X m y) -> m = y).
  Proof with intuition.
    refine (strong_induction _ _ _)...

    - apply Cardinality_one_Singleton in H.
      inversion H; clear H.
      exists x... rewrite H1...

    - assert (Inhabited X).
        apply Cardinal_Sn in H0...
      inversion H2; clear H2.

      set (Z := (fun y => triangle_rest X x y)).

      assert (Z ⊆ X) as SS.
        unfold Z, Included, In at 1...
        apply triangle_rest_in_set in H2...

      assert (Finite Z /\ Inhabited Z).
        split. apply (Finite_Included X)... apply Cardinal_are_Finite in H0...
        unfold Z, In. apply triangle_rest_dec... apply Cardinal_are_Finite in H0...
        exists x... unfold Z, In at 1... left...

      assert (exists k, Cardinal Z (S k)) as K.
        apply Finite_Inhabited_Cardinal_Sn...
        inversion K as [k L]; clear K...

      destruct k...

      + exists x...
        assert (y ∈ Z)...
        assert (x ∈ Z)... unfold Z, In at 1... left...
        apply Cardinality_one_Singleton in L...
        inversion L as [p P]...
        rewrite P in H7. rewrite P in H8.
        inversion H7. inversion H8... rewrite <- H10...

      + assert (k <= n).
          assert (S (S k) <= S (S n))...
            refine (Cardinal_le carrier_decidable_eq Z _ _ X _ _ _)...
          apply le_S_n. apply le_S_n...

        inversion H2; clear H2.

        * assert (X == Z).
            apply (Cardinal_eq_Included_Same_set carrier_decidable_eq (S (S n)))... rewrite <- H6...
          set (W := Setminus X (Singleton x)).
          assert (
            ∃ m : carrier, m ∈ W ∧
             (∀ y : carrier, y ∈ W → triangle_rest W m y → m = y)) as M.
            refine (H k _ _ _ n0 _). rewrite H6; left... unfold W; apply (Cardinal_Setminus carrier_decidable_eq (S (S k)))... rewrite H6...
            unfold W. apply (Included_trans _ X)... unfold Setminus...
            unfold Included, In...
          inversion M as [maxZ K]; clear M...
          exists maxZ...

          unfold W, Setminus, In in H7...

          apply (H8 y)... unfold W, Setminus, In at 1...
          inversion H11; clear H11.
          assert (x = maxZ).
            apply axiom3a.
            apply (rest_implies_full X). assert (maxZ ∈ X)... apply H7.
            rewrite H2 in H11...
            apply (rest_implies_full X). rewrite H12...
          rewrite <- H11 in H7...
          unfold W, In at 1, Setminus in H7...
          apply triangle_rest_equiv in H10...
          apply triangle_rest_equiv.
          induction H10...
            left...
            right with y...
            unfold W, In at 1, Setminus... inversion H13; clear H13...
            rewrite <- H15 in *. clear z H15.
            assert (x0 = x).
            apply axiom3a. apply (rest_implies_full X). assert (x0 ∈ Z)...
            rewrite <- H2...
            apply triangle_rest_equiv in H12.
            apply triangle_rest_in_set in H12...
            apply triangle_rest_equiv.
            right with y...
            apply (rest_implies_full X).
            assert (x0 ∈ Z)... rewrite <- H2.
            apply triangle_rest_equiv in H12. apply triangle_rest_in_set in H12...
            rewrite H13 in H7.
            unfold W, In at 1, Setminus in H7...
            apply H14... inversion H12...

          (* S k <= n *)
        * assert (
           ∃ m : carrier, m ∈ Z ∧ (∀ y : carrier,
              y ∈ Z → triangle_rest Z m y → m = y)) as M.
          refine (H (S k) _ _ _ n0 _)... rewrite <- H7...
          inversion M as [maxZ K]; clear M...
          exists maxZ...
          assert (y ∈ Z)...
            unfold Z, In at 1...
            apply (triangle_rest_trans X _ maxZ)...
          apply (H8 y)...

          apply triangle_rest_equiv in H10.
          apply triangle_rest_equiv.
          induction H10.
            left...
            assert (y ∈ Z).
            unfold Z, In at 1... apply (triangle_rest_trans X _ x0)...
            apply triangle_rest_equiv...
            right with y...
  Qed.

  Lemma minimal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X ->
         ∀ n : nat,
         X ⊆ sub Full_set (S n) ->
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X y m → m = y).
  Proof with intuition.
    intros X H1.
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn...
    inversion H; clear H.
    apply (minimal_exists x)...
  Qed.

  Lemma maximal_exists' : forall (X : Ensemble carrier),
       Finite X /\ Inhabited X ->
         ∀ n : nat,
         X ⊆ sub Full_set (S n) ->
         ∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → triangle_rest X m y → m = y).
  Proof with intuition.
    intros X H1.
    assert (exists t, Cardinal X (S t)). apply Finite_Inhabited_Cardinal_Sn...
    inversion H; clear H.
    apply (maximal_exists x)...
  Qed.

  Lemma wf_minimal_exists :
    forall X n, Finite X /\ Inhabited X /\ (X ⊆ sub Full_set (S (S n))) ->
      well_formed X ->
        exists x, x ∈ X /\ Disjoint (minus x) (Plus X).
  Proof with intuition.
    idtac...
        unfold well_formed in H0...
        inversion H; clear H...
        set (Z := fun s => triangle_rest X s x).
        assert (Finite Z /\ Inhabited Z)...
          apply (Finite_Included X)...
          unfold Z, Included, In at 1... apply triangle_rest_in_set in H...
          assert ((triangle_rest X x0 x) \/ ~(triangle_rest X x0 x))...
            apply triangle_rest_dec...
          exists x... unfold Z, In at 1... left...
        assert (∃ m : carrier, m ∈ Z ∧ (∀ y : carrier, y ∈ Z → triangle_rest Z y m → m = y)).
          refine (minimal_exists' _ _ (S n) _ )...
          apply (Included_trans _ X)... unfold Z. crush. apply triangle_rest_in_set in H...
        inversion H as [m K]; clear H.
        exists m...
        unfold Z, In at 1 in H...
        apply triangle_rest_in_set in H...
        constructor...
        apply In_Intersection in H8...
        inversion H10; clear H10...
        assert (less x1 m).
          exists x0...
        assert (m = x1).
          apply H7...
          unfold Z, In at 1...
          right with m...
          right with m...
          unfold Z, In at 1...
          right with m...
          left...
          rewrite H12 in H8.
          inversion H8... apply In_Intersection in H13...
  Qed.

  Lemma wf_maximal_exists :
    forall X n, Finite X /\ Inhabited X /\ (X ⊆ sub Full_set (S (S n))) ->
      well_formed X ->
        exists x, x ∈ X /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    idtac...
        unfold well_formed in H0...
        inversion H; clear H...
        set (Z := fun s => triangle_rest X x s).
        assert (Finite Z /\ Inhabited Z)...
          apply (Finite_Included X)...
          unfold Z, Included, In at 1... apply triangle_rest_in_set in H...
          assert ((triangle_rest X x x0) \/ ~(triangle_rest X x x0))...
            apply triangle_rest_dec...
          exists x... unfold Z, In at 1... left...
        assert (∃ m : carrier, m ∈ Z ∧ (∀ y : carrier, y ∈ Z → triangle_rest Z m y → m = y)).
          refine (maximal_exists' _ _ (S n) _ )...
          apply (Included_trans _ X)... unfold Z. crush. apply triangle_rest_in_set in H...
          unfold Z, Included...
        inversion H as [m K]; clear H.
        exists m...
        unfold Z, In at 1 in H...
        apply triangle_rest_in_set in H...
        constructor...
        apply In_Intersection in H8...
        inversion H10; clear H10...
        assert (less m x1).
          exists x0...
        assert (m = x1).
          apply H7...
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          right with x1... left...
          unfold Z, In at 1...
          unfold Z, In at 1 in H...
          apply triangle_rest_equiv.
          right with m...
          apply triangle_rest_equiv...
          rewrite H12 in H8.
          inversion H8... apply In_Intersection in H13...
  Qed.

  Lemma PlusMinus_Inhabited :
    forall X n,
      Included X (sub Full_set (S (S n))) ->
      Finite X ->
      Inhabited X ->
      Inhabited (PlusMinus X).
  Proof with intuition.
    intros...
    assert (Finite (PlusMinus X))...
    apply Finite_Empty_or_Inhabited in H2...
    exfalso. rename H3 into H2.
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X m y) -> m = y)).
      refine (maximal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (plus max)).
      apply plus_Inhabited. apply H in H2. subsuptac... apply eq_add_S in H6... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d).
    apply H3.
    unfold PlusMinus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Plus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less max r). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ r)... left...
    rewrite H9 in H7; unfold less in H7...
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)...
    idtac...
  Qed.

  Lemma MinusPlus_Inhabited :
    forall X n,
      Included X (sub Full_set (S (S n))) ->
      Finite X ->
      Inhabited X ->
      Inhabited (MinusPlus X).
  Proof with intuition.
    intros...
    assert (Finite (MinusPlus X))...
    apply Finite_Empty_or_Inhabited in H2...
    exfalso. rename H3 into H2.
    unfold Same_set, Included in H2... clear H4.
    assert (∃ m : carrier, m ∈ X ∧ (∀ y : carrier, y ∈ X → (triangle_rest X y m) -> m = y)).
      refine (minimal_exists' _ _ (S n) _)...
    inversion H2 as [max]; clear H2...
    assert (Inhabited (minus max)).
      apply minus_Inhabited. apply H in H2. subsuptac... apply eq_add_S in H6... rewrite H6...
    inversion H4 as [d]; clear H4...
    assert (In (Empty_set) d).
    apply H3.
    unfold MinusPlus; apply In_Intersection...
    exists max...
    apply In_Complement...
    unfold Minus, In at 1 in H4.
    inversion H4 as [r]; clear H4...
    assert (less r max). exists d...
    assert ( max = r ). apply H5... apply (tr_trans _ _ max)... left...
    rewrite H9 in H7; unfold less in H7...
    pose (plus_minus_Disjoint r) as Y. inversion Y. inversion H7 as [e E]. apply (H10 e)...
    idtac...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 1                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_1_1 :
    forall x,
    (Plus (plus x)) ∩ (Minus (minus x)) == (Empty_set) == (Plus (minus x)) ∩ (Minus (plus x))
    /\
    (MinusPlus (minus x)) == Intersection (Minus (minus x)) (Minus (plus x)) == (MinusPlus (plus x))
    /\
    (PlusMinus (minus x)) == Intersection (Plus (minus x)) (Plus (plus x))   == (PlusMinus (plus x)).
  Proof with repeat basic; auto.
    remember axiom3b as axiom3b. clear Heqaxiom3b.
    assert (H: forall x y, (In (Plus (plus x)) y /\ In (Minus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus, In in H0.
      unfold Minus, In in H1...
      rename x0 into v. rename x1 into w.
      assert (less w v).
        unfold less. refine (Inhabited_intro  _ _ u _)...
      assert (triangle w v).
        right with v...  left...
      apply (axiom3b _ _ x) in H4...

    assert (K: forall x y, (In (Minus (plus x)) y /\ In (Plus (minus x)) y) -> False).
      intros... rename y into u.
      unfold Plus in H2. unfold In in H2.
      unfold Minus in H1. unfold In in H1...
      rename x0 into v. rename x1 into w.
      assert (less v w).
        unfold less. refine (Inhabited_intro _ _ u _)...
      assert (triangle v w).
        right with w...
        left...
      apply (axiom3b _ _ x) in H5...

    intros; split; split.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (H x x0)...
    symmetry.
    apply Disjoint_Intersection_condition.
    constructor. unfold not. intros... apply (K x x0)...

    split; unfold MinusPlus, Same_set, Included... rename x0 into y.
    assert (In (Union (Plus (minus x)) (Minus (plus x))) y).
      rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (K x x0)...

    unfold Same_set, Included...
    apply In_Complement... apply (H x x0)...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...

    split; unfold PlusMinus, Same_set, Included...
    pose (axiom1 x).
    assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
    symmetry in s.
    rewrite <- s... apply In_Union in H0... inversion H0...
    apply In_Complement... apply (H x x0)...

    unfold Same_set; unfold Included...
    apply In_Complement... apply (K x x0)...
    assert (In (Union (Plus (minus x)) (Minus (plus x))) x0).
    rewrite <- (axiom1 x)... apply In_Union in H0... inversion H0...
  Qed.

  Lemma Prop_1_2 :
    forall u v x,
    triangle u v ->
    In (plus x) v ->
    (minus u) ∩ (Plus (minus x)) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Plus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less w u).
         exists x0...
       assert (triangle w v).
         right with u...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_2' :
    forall u v x,
    triangle u v ->
    In (minus x) v ->
    (minus u) ∩ (Plus (plus x)) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Plus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less w u).
         exists x0...
       assert (triangle w v).
         right with u...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_2_dual :
       forall u v x : carrier,
       triangle v u -> v ∈ minus x -> plus u ∩ Minus (plus x) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Minus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less u w).
         exists x0...
       assert (triangle v w).
         unfold triangle.
         apply clos_rt_rt1n_iff.
         apply clos_rt_rtn1_iff.
         refine (Relation_Operators.rtn1_trans _ _ v u w _ _)...
         apply clos_rt_rtn1_iff.
         apply clos_rt_rt1n_iff...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_2_dual' :
       forall u v x : carrier,
       triangle v u -> v ∈ plus x -> plus u ∩ Minus (minus x) == Empty_set.
  Proof with repeat basic; auto.
    intros.
    unfold Same_set; unfold Included...
     - unfold Minus in H3.
       unfold In at 1 in H3...
       rename x1 into w.
       assert (less u w).
         exists x0...
       assert (triangle v w).
         unfold triangle.
         apply clos_rt_rt1n_iff.
         apply clos_rt_rtn1_iff.
         refine (Relation_Operators.rtn1_trans _ _ v u w _ _)...
         apply clos_rt_rtn1_iff.
         apply clos_rt_rt1n_iff...
       exfalso.
       apply (axiom3b _ _ x) in H5...
     - inversion H1.
     - inversion H1.
  Qed.

  Lemma Prop_1_3 :
    forall R S', Finite R ->
      tight R -> well_formed S' -> R ⊆ S' -> is_a_segment R S'.
  Proof with repeat basic; auto.
    unfold is_a_segment.
    unfold tight.
    unfold well_formed.
    unfold triangle.
    intros R S' RFin...
    assert (exists m, (dim x = S m)) as K.
      inversion H4... apply plus_dim in H8. exists (dim x0). auto.
    rename x into w. rename y into u. rename z into v.
    assert (dim w = dim u) as J. apply equal_dim. unfold triangle.
      right with u... left...
    inversion H4 as [y]...
    assert (minus u ∩ PlusMinus R == Empty_set) as L.
      apply (H u v).
      apply (rest_implies_full S')...
      assumption.
    assert (~(In (PlusMinus R) y)) as M.
      unfold not; intros... assert (In (Empty_set) y).
      rewrite <- L... inversion H11. unfold not in M.
    assert (In (Plus R) y) as N.
      unfold Plus. unfold In. exists w...
    assert (In (Minus R) y) as P.
      assert (y ∈ Minus R \/ ~(y ∈ Minus R)).
        apply all_decidable...
      inversion H0. assumption. exfalso. apply M.
      unfold PlusMinus...
    inversion P as [z]...
    assert (u = z).
      refine (H3 _ _ _ x _ _ _)...
      assert (forall T u' v', v' ∈ T -> triangle_rest T u' v' -> u' ∈ T) as Q...
        inversion H13...
      apply (Q _ u v)...
      rewrite <- J. apply H8.
      apply minus_dim in H12. rewrite <- H12. rewrite <- H8.
      apply plus_dim in H9...
      unfold perp in H0...
      apply Disjoint_Intersection_condition in H14.
      inversion H14. apply (H0 y)...
      rewrite H0...
  Qed.

  Lemma xplus_is_tight :
    forall x, tight (plus x).
  Proof with repeat basic; auto.
    unfold tight; intros.
    assert (Intersection (minus u) (Plus (minus x)) == Empty_set) as A.
      apply (Prop_1_2 u v)...
    assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as B.
      apply (Prop_1_1 x).
    rewrite <- B.
    rewrite <- Intersection_trans.
    rewrite A.
    apply Empty_set_zero_left.
  Qed.

  Lemma xminus_is_tight :
    forall x, tight (minus x).
  Proof with repeat basic; auto.
    unfold tight; intros.
    assert (Intersection (minus u) (Plus (plus x)) == Empty_set) as A.
      apply (Prop_1_2' u v)...
    assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (minus x)) as B.
      symmetry. apply (Prop_1_1 x).
    rewrite <- B.
    rewrite <- Intersection_trans.
    rewrite (Intersection_comm (minus u)). 
    rewrite Intersection_trans.
    rewrite A.
    apply Empty_set_zero_right.
  Qed.

  (* Section 2 *)

  Lemma Observation_p322 :
    forall (T Z : Ensemble carrier),
    well_formed (T ∪ Z) ->
    Disjoint T Z ->
    Perp T Z.
  Proof with repeat basic; auto.
    intros T Z WF Disj. remember (T ∪ Z) as S'.
    unfold well_formed in WF...
    rename H into WF0.
    rename H0 into WFSn.
    rename H1 into Disj.
    unfold Perp...

    apply Disjoint_Intersection_condition. constructor. unfold not in *.
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Plus in PT. unfold In in PT.
    unfold Plus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply plus_dim. unfold In...
    assert (x0 = x1).
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left...
    apply H. assumption.
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H6.
    inversion H6 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...

    apply Disjoint_Intersection_condition. constructor. unfold not in *.
    intros... rename H0 into PT. rename H1 into PZ.
    unfold Minus in PT. unfold In in PT.
    unfold Minus in PZ. unfold In in PZ...
    assert (dim x0 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (dim x1 = S (dim x)). symmetry. apply minus_dim. unfold In...
    assert (x0 = x1).
    refine (WFSn _ _ _ (dim x) _ _ _). split; rewrite HeqS'. right... left...
    apply H. assumption.
    unfold perp. intros...
    apply Disjoint_Intersection_condition in H7.
    inversion H7 as [J]; clear H6; unfold not in J; apply (J x)...
    subst.
    apply (Disj x1)...
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Cells                                                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

    Definition Same_pair (A B: Ensemble carrier * Ensemble carrier) : Prop.
  inversion A as [M  P ].
  inversion B as [M' P'].
  exact (M == M' /\ P == P').
  Defined.

  Hint Unfold Same_pair.

  Notation " F === G" := (Same_pair F G) (at level 89).

  Definition is_a_cell (G : Ensemble carrier * Ensemble carrier) : Prop.
  inversion G as [M P].
  exact ( Inhabited M  /\ Inhabited P /\
    well_formed M /\ well_formed P /\
    Finite M /\ Finite P /\
    (M moves M to P) /\ (P moves M to P)).
  Defined.

  Definition celldim (G : Ensemble carrier * Ensemble carrier) (n : nat) : Prop.
    inversion G as [M P].
    exact (setdim (M ∪ P) n).
  Defined.

  Definition source (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sup M (S n) , sub M (S n) ∪ sup P n).
  Defined.

  Definition target (n : nat) (G : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
    inversion G as [M P]. exact ( sub P (S n) ∪ sup M n , sup P (S n) ).
  Defined.

  Definition composable (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Prop :=
    target n A === source n B.

  Definition composite (n : nat) (A B : Ensemble carrier * Ensemble carrier) : Ensemble carrier * Ensemble carrier.
   inversion A as [M P].
   inversion B as [N Q].
   exact ((M ∪ (N ∩ √(sub N (S n)))), ((P ∩ √(sub P (S n))) ∪ Q)).
  Defined.

  Definition receptive_x (S : Ensemble carrier) (x : carrier) : Prop :=
    ((Plus (minus x)) ∩ (Plus (plus x)) ⊆ S ->
       (Inhabited (S ∩ (Minus (minus x))) -> False) ->
       (Inhabited (S ∩ (Minus (plus x))) -> False))  /\
    ((Minus (plus x)) ∩ (Minus (minus x)) ⊆ S ->
       (Inhabited (S ∩ (Plus (plus x))) -> False) ->
       (Inhabited (S ∩ (Plus (minus x))) -> False)).

  Definition receptive (S : Ensemble carrier) : Prop := forall x, receptive_x S x.

  Add Parametric Morphism : (receptive_x) with
    signature (@Same_set carrier) ==> (@eq carrier) ==> (iff) as receptive_x_Same_set.
  Proof with intuition.
    unfold receptive_x.
    intros.
    split; intros K. 
      rewrite <- H...
      rewrite    H...
  Qed.

  Add Parametric Morphism : (receptive) with
    signature (@Same_set carrier) ==> (iff) as receptive_Same_set.
  Proof with intuition.
    unfold receptive.
    intros.
    split... 
      rewrite <- H...
      rewrite    H...
  Qed.

  Definition cell_receptive (G : Ensemble carrier * Ensemble carrier) : Prop.
    inversion G as [M P].
    exact (receptive M /\ receptive P).
  Qed.

  Hint Unfold is_a_cell.

  Definition is_a_cell' (S T : Ensemble carrier) := is_a_cell (S, T).

  Hint Unfold is_a_cell'.

  Add Parametric Morphism : (is_a_cell') with
    signature (@Same_set carrier) ==> (@Same_set carrier) ==> (iff) as is_a_cell_Same_set.
  Proof with intuition.
    intuition.
    symmetry in H.
    symmetry in H0.
    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H...
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H).
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...

    unfold is_a_cell', is_a_cell, moves_def in *...
    rewrite H...
    rewrite H0...
    rewrite H...
    rewrite H0...
    apply (Finite_Same_set _ H5 _ H).
    apply (Finite_Same_set _ H6 _ H0).
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
    rewrite H, H0...
  Qed.

  Lemma Same_set_is_a_cell : forall S T,
    is_a_cell (S, T) -> forall S' , S == S' -> forall T', T == T' -> is_a_cell (S', T').
  Proof.
    intros.
    fold (is_a_cell' S T).
    fold (is_a_cell' S' T').
    rewrite <- H0, <- H1.
    intuition.
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results direct from definitions                *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma receptive_x_by_dimension  : forall T x, receptive_x T x -> (forall n, receptive_x (sub T n) x).
  Proof with intuition.
    unfold receptive, receptive_x.
    intros...
    + apply (H0)...
      - apply Included_trans with (sub T n)...
      - apply H2.
        inversion H4; exists x0.
        repeat (basic; intuition)...
        unfold sub, In at 1...
        assert (dim x = S n).
          inversion H3.
          apply In_Intersection in H5...
          assert (S (dim x1) = n)...
          inversion H9; clear H9...
          assert (S (dim x1) = dim x2)...
          assert (S (dim x2) = dim x )...
          rewrite <- H10, H5 in H12...
        inversion H7; clear H7...
        assert (S (dim x1) = dim x )...
        assert (S (dim x0) = dim x1)...
        rewrite H5 in H8.
        assert (dim x1 = n)...
        rewrite H11 in H10...
      - inversion H3; clear H3...
        exists x0...
        repeat (basic; intuition).
    + apply (H1)...
      - apply Included_trans with (sub T n)...
      - apply H2.
        inversion H4; exists x0.
        repeat (basic; intuition)...
        unfold sub, In at 1...
        assert (dim x = S n).
          inversion H3.
          apply In_Intersection in H5...
          assert (S (dim x1) = n)...
          inversion H9; clear H9...
          assert (S (dim x1) = dim x2)...
          assert (S (dim x2) = dim x )...
          rewrite <- H10, H5 in H12...
        inversion H7; clear H7...
        assert (S (dim x1) = dim x )...
        assert (S (dim x0) = dim x1)...
        rewrite H5 in H8.
        assert (dim x1 = n)...
        rewrite H11 in H10...
      - inversion H3; clear H3...
        exists x0...
        repeat (basic; intuition).
  Qed.

  Lemma receptive_x_by_dimension'  :
      forall T x, (forall n, receptive_x (sub T n) x) -> receptive_x T x.
  Proof with intuition.
    unfold receptive, receptive_x.
    intros...
    - inversion H2; clear H2.
      assert (S (S (dim x0)) = dim x)...
        apply In_Intersection in H3...
      specialize H with (S (dim x0))...
      apply (H4)...
      + unfold sub, Included, In at 2...
        apply In_Intersection in H...
        inversion H6...
        assert (S (dim x1) = dim x2)...
        assert (S (dim x2) = dim x )...
        rewrite <- H2 in H10; inversion H10...
      + apply H1.
        apply (Inhabited_Included (sub T (S (dim x0)) ∩ Minus (minus x)))...
        unfold Included; repeat (basic; intuition).
      + exists x0...
        repeat (basic; intuition)...
    - inversion H2; clear H2.
      assert (S (S (dim x0)) = dim x)...
        apply In_Intersection in H3...
      specialize H with (S (dim x0))...
      apply (H5)...
      + unfold sub, Included, In at 2...
        apply In_Intersection in H...
        inversion H6...
        assert (S (dim x1) = dim x2)...
        assert (S (dim x2) = dim x )...
        rewrite <- H2 in H10; inversion H10...
      + apply H1.
        apply (Inhabited_Included (sub T (S (dim x0)) ∩ Plus (plus x)))...
        unfold Included; repeat (basic; intuition).
      + exists x0...
        repeat (basic; intuition)...
  Qed.

  Lemma receptive_by_dimension  :
      forall T, receptive T -> (forall n, receptive (sub T n)).
  Proof with intuition.
    unfold receptive...
    apply receptive_x_by_dimension...
  Qed.

  Lemma receptive_by_dimension'  :
      forall T, (forall n, receptive (sub T n)) -> receptive T.
  Proof with intuition.
    unfold receptive...
    apply receptive_x_by_dimension'...
  Qed.

  Lemma Empty_set_moves : forall M, Empty_set moves M to M.
  Proof with intuition.
    intros...
    unfold moves_def...
    rewrite <- Setminus_is_Intersection_Complement.
    rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
    rewrite <- Setminus_is_Intersection_Complement.
    rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set, Empty_set_ident_right...
  Qed.

  Lemma cell_has_dim : forall M P, is_a_cell (M, P) -> exists m, celldim (M, P) m.
  Proof with repeat basic; auto.
    intros.
    unfold is_a_cell in H...
    assert (Finite (M ∪ P)).
    apply Finite_Union.
    apply all_decidable...
    assumption.
    assumption.
    apply Finite_carrier_have_max_dim_element in H6.
    inversion H6 as [m]; clear H6...
    exists (dim m).
    unfold celldim.
    unfold setdim.
    intros...
    inversion H8; apply H9...
    inversion H0.
    apply (Inhabited_intro _ _ x).
    left...
  Qed.

  Lemma target_dim : forall M P, is_a_cell (M, P) -> forall m,
    (celldim (target m (M, P)) m).
  Proof with intuition.
    intros...
    unfold target, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (S (dim x)))...
  Qed.

  Lemma source_dim : forall M P, is_a_cell (M, P) -> forall m,
    celldim (source m (M, P)) m.
  Proof with intuition.
    intros...
    unfold source, celldim, setdim...
    repeat (basic; intuition).
    assert (dim x = m)... rewrite H1...
    apply (le_trans _ (S (dim x)))...
  Qed.

 Lemma cell_dim_n_property :
    forall M P, is_a_cell (M, P) -> forall n, celldim (M, P) n -> sub M (S n) == sub P (S n).
  Proof with intuition.
    intros M P K n J.
    unfold is_a_cell in K... unfold moves_def in *...
    unfold sub, Same_set, Included, In...

    fold (x ∈ P). rewrite H6.
    repeat basic. left... apply In_Complement. unfold not...
    unfold In, Minus in H7. inversion H7; clear H7... apply minus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...

    fold (x ∈ M). rewrite H9.
    repeat basic. left... apply In_Complement. unfold not...
    unfold In, Plus in H7. inversion H7; clear H7... apply plus_dim in H13.
    assert (dim x0 <= n). unfold celldim, setdim in *. apply J...
    rewrite <- H13 in H12. rewrite H11 in H12. apply (le_Sn_n n)...
  Qed.

  Lemma M_n_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        Inhabited (sub M (S (S n))) ->
        Inhabited (sub M (  (S n))).
  Proof with intuition.
    intros...

    assert (exists m, In (sub M (S (S n))) m /\ (forall y, In (sub M (S (S n))) y -> (triangle_rest (sub M (S (S n))) y m) -> (m = y))).
      refine (minimal_exists' _ _ (S n) _)...
      refine (Finite_sub M _ _). apply H.
      unfold sub, Included... unfold In at 1. unfold In at 1 in H1...
    inversion H1 as [w J]; clear H1...

    assert ( MinusPlus (sub M (S (S n))) ⊆ sub M (S n)).
      assert (MinusPlus M ⊆ M).
        unfold is_a_cell in H...
        apply Prop_2_1...
        exists P...
      unfold MinusPlus.
      rewrite <- Setminus_is_Intersection_Complement.
      repeat (rewrite <- sub_Minus || rewrite <- sub_Plus || rewrite <- sub_Setminus).
      rewrite    Setminus_is_Intersection_Complement.
      fold (MinusPlus M).
      apply sub_Included_compat...

    assert (Finite (sub M (S n))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso.
    assert (MinusPlus (sub M (S (S n))) == Empty_set).
      apply (Included_Empty_set _ (sub M (S n)))...
    assert (forall x, In (Minus (sub M (S (S n)))) x -> (In (Plus (sub M (S (S n))))) x)...
      assert (x ∈ Plus (sub M (S (S n))) \/ ~(x ∈ Plus (sub M (S (S n)))))...
        apply all_decidable...
        apply Plus_Finite. apply Finite_sub... apply H.
      exfalso.
      assert (In (MinusPlus (sub M (S (S n)))) x); unfold MinusPlus...
      rewrite H4 in H7. inversion H7...
    assert (Inhabited (minus w))...
      apply minus_Inhabited. assert (dim w = (S n))... unfold sub in H1... rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Plus (sub M (S (S n)))).
      apply H6... exists w...
    unfold Plus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less z w).
      unfold less. exists p...
    assert (w = z).
      apply H2... apply (tr_trans _ _ w)... left...
    subst. unfold less in H9...
  Qed.

  Lemma P_n_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        Inhabited (sub P (S (S n))) ->
        Inhabited (sub P (  (S n))).
  Proof with intuition.
    intros...

    assert (exists m, In (sub P (S (S n))) m /\ (forall y, In (sub P (S (S n))) y -> (triangle_rest (sub P (S (S n))) m y) -> (m = y))).
      refine (maximal_exists' _ _ (S n) _)...
      refine (Finite_sub P _ _).
      apply H.
    inversion H1 as [w J]; clear H1...

    assert ( PlusMinus (sub P (S (S n))) ⊆ sub P (S n)).
      assert (PlusMinus P ⊆ P).
        unfold is_a_cell in H...
        apply Prop_2_1_dual...
        exists M...
      unfold PlusMinus.
      rewrite <- Setminus_is_Intersection_Complement.
      repeat (rewrite <- sub_Minus || rewrite <- sub_Plus || rewrite <- sub_Setminus).
      rewrite    Setminus_is_Intersection_Complement.
      fold (PlusMinus M).
      apply sub_Included_compat...

    assert (Finite (sub P (S n))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H4...
    exfalso.
    assert (PlusMinus (sub P (S (S n))) == Empty_set).
      apply (Included_Empty_set _ (sub P (S n)))...
    assert (forall x, In (Plus (sub P (S (S n)))) x -> (In (Minus (sub P (S (S n))))) x)...
      assert (x ∈ Minus (sub P (S (S n))) \/ ~(x ∈ Minus (sub P (S (S n)))))...
        apply all_decidable.
        apply Minus_Finite. apply Finite_sub. apply H.
      exfalso.
      assert (In (PlusMinus (sub P (S (S n)))) x); unfold PlusMinus...
      rewrite H4 in H7...
    assert (Inhabited (plus w))...
      apply plus_Inhabited.
      assert (dim w = (S n))...
      rewrite H7...
    inversion H7 as [p Q]; clear H7.
    assert (p ∈ Minus (sub P (S (S n)))).
      apply H6...
      exists w...
    unfold Minus, In at 1 in H7...
    inversion H7 as [z D]; clear H7...
    assert (less w z).
      unfold less. exists p...
    assert (w = z).
      apply H2... apply (tr_trans _ _ z)... left...
    subst.
    unfold less in H9...
  Qed.

  Lemma M_n_Empty_set :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        sub M (  (S n)) == Empty_set ->
        sub M (S (S n)) == Empty_set.
  Proof with intuition.
    intros...
    assert (Finite (sub M (S (S n)))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (M_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma P_n_Empty_set :
    forall M P,
      is_a_cell (M, P) ->
      forall n,
        sub P (  (S n)) == Empty_set ->
        sub P (S (S n)) == Empty_set.
  Proof with intuition.
    intros...
    assert (Finite (sub P (S (S n)))).
      unfold is_a_cell in H...
    apply Finite_Empty_or_Inhabited in H1...
    exfalso.
    apply (P_n_Inhabited M P) in H2...
    inversion H2 as [z W]...
    rewrite H0 in W...
  Qed.

  Lemma M_0_not_empty :
    forall M P,
      is_a_cell (M, P) ->
       ((sub M 1) == Empty_set) -> False.
  Proof with intuition.
    unfold not...
    assert ( forall n, ((sub M (S n)) == Empty_set))...
      induction n...
      apply (M_n_Empty_set M P)...
    unfold is_a_cell in H...
    inversion H2 as [z W]...
    assert (Inhabited (sub M (S (dim z))))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma P_0_not_empty :
    forall M P,
      is_a_cell (M, P) ->
       ((sub P 1) == Empty_set) -> False.
  Proof with intuition.
    unfold not...
    assert ( forall n, ((sub P (S n)) == Empty_set))...
      induction n...
      apply (P_n_Empty_set M P)...
    unfold is_a_cell in H...
    inversion H as [z W]...
    assert (Inhabited (sub P (S (dim z))))...
      exists z...
    specialize H1 with (n := (dim z)).
    inversion H8 as [s D]; rewrite H1 in D; inversion D.
  Qed.

  Lemma M_0_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      exists z, (sub M 1) == Singleton z.
  Proof with intuition.
    intros.
    assert (Inhabited (sub M 1)).
      assert (Finite (sub M 1)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (M_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H2...
      rewrite H1...
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma P_0_Inhabited :
    forall M P,
      is_a_cell (M, P) ->
      exists z, (sub P 1) == Singleton z.
  Proof with intuition.
    intros.
    assert (Inhabited (sub P 1)).
      assert (Finite (sub P 1)).
        apply Finite_sub. apply H.
      apply Finite_Empty_or_Inhabited in H0...
      exfalso. apply (P_0_not_empty M P)...
    inversion H0 as [z J]; clear H0.
    exists z.
    unfold Same_set, Included...
      assert (x = z).
      unfold is_a_cell in H... apply H3...
      rewrite H1...
      inversion H0.  rewrite <- H1...
  Qed.

  Lemma M_0_Inhabited' :
    forall M P,
      is_a_cell (M, P) -> Inhabited (sub M 1).
  Proof with intuition.
    intros.
    assert (Finite (sub M 1))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso.
    apply (M_0_not_empty M P)...
  Qed.

  Lemma P_0_Inhabited' :
    forall M P,
      is_a_cell (M, P) -> Inhabited (sub P 1).
  Proof with intuition.
    intros.
    assert (Finite (sub P 1))...
      apply Finite_sub. apply H.
    apply Finite_Empty_or_Inhabited in H0...
    exfalso.
    apply (P_0_not_empty M P)...
  Qed.

  Lemma source_is_a_cell : forall (M P : Ensemble carrier),
    is_a_cell (M, P) ->
    forall n,
      is_a_cell (source n (M, P)).
  Proof with intuition.
    intros M P MPcell n .
    unfold source.

    destruct n.
    - apply (Same_set_is_a_cell (sub M 1) (sub M 1))...
        apply M_0_Inhabited in MPcell.
        inversion MPcell; clear MPcell.
      apply (Same_set_is_a_cell (Singleton x) (Singleton x))...
      assert (dim x = 0) as dimx.
        assert (In (sub M 1) x)... rewrite H...
      unfold is_a_cell...
        exists x...
        exists x...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

    rewrite (sup_zero P).
    rewrite Empty_set_ident_right...

    - unfold is_a_cell in *...

  + assert (Inhabited (sub M 1)).
      assert (exists z, (sub M 1) == Singleton z). apply (M_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... repeat subsuptac... rewrite H10...

  + assert (Inhabited (sub P 1)).
      assert (exists z, (sub P 1) == Singleton z).
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... right. repeat subsuptac... rewrite H10...

  + apply well_formed_sup...

  + apply well_formed_Union...
      apply well_formed_sub...
      apply well_formed_sup...
      assert (dim x = S n)...
      assert (dim y <= n)...
      rewrite <- H8, H6 in H11...

  + apply Finite_Union...

  + apply moves_by_dim'.
    intros k.
    repeat (rewrite sub_Union).
    assert ({k < (S n)} + {k = S n} + {k = S (S n)} + {S (S n) < k})...
      apply lt_eq_eq_lt_dec.
    * repeat (rewrite sub_sub_Empty_set || rewrite sub_sup_cancel ||
              rewrite Empty_set_ident_left)...
      apply moves_by_dim...
      rewrite <- H6 in a...
    * rewrite b.
      repeat (rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply moves_by_dim...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set  ||
              rewrite (sub_sup_cancel (S (S n)) (S (S n))) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
    * repeat (rewrite sub_sub_Empty_set ||
              rewrite sub_sup_Empty_set ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
  + apply moves_by_dim'.
    intros k.
    repeat (rewrite sub_Union).
    assert ({k < (S n)} + {k = S n} + {k = S (S n)} + {S (S n) < k})...
      apply lt_eq_eq_lt_dec.
    * repeat (rewrite sub_sub_Empty_set || rewrite sub_sup_cancel ||
              rewrite Empty_set_ident_left)...
      apply moves_by_dim...
      rewrite <- H6 in a...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel (S n)) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply moves_by_dim...
    * rewrite b.
      repeat (rewrite sub_idemp ||
              rewrite sub_sub_Empty_set ||
              rewrite (sub_sup_cancel (S (S n)) (S (S n))) ||
              rewrite (sub_sup_Empty_set) ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
    * repeat (rewrite sub_sub_Empty_set ||
              rewrite sub_sup_Empty_set ||
              rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
      apply Empty_set_moves.
  Qed.

  Lemma target_is_a_cell : forall (M P : Ensemble carrier),
    is_a_cell (M, P) ->
    forall n,
    is_a_cell (target n (M, P)).
  Proof with intuition.
    intros M P MPcell n.
    unfold target.

    destruct n.
    - apply (Same_set_is_a_cell (sub P 1) (sub P 1))...
        apply P_0_Inhabited in MPcell.
        inversion MPcell; clear MPcell.
      apply (Same_set_is_a_cell (Singleton x) (Singleton x))...
      assert (dim x = 0) as dimx.
        assert (In (sub P 1) x)... rewrite H...
      unfold is_a_cell...
        exists x...
        exists x...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

      unfold moves_def...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...
      rewrite Plus_Singleton, Minus_Singleton.
      rewrite plus_zero...
      rewrite minus_zero...
      rewrite Empty_set_ident_right.
      rewrite Complement_Empty_set.
      rewrite Full_set_ident_right...

    rewrite (sup_zero M).
    rewrite Empty_set_ident_right...

    - unfold is_a_cell in *...

  + assert (Inhabited (sub M 1)).
      assert (exists z, (sub M 1) == Singleton z).
        apply (M_0_Inhabited M P). unfold is_a_cell...
        inversion H6; clear H6. exists x...
        rewrite H8...
    inversion H6; clear H6.
    exists x...
    right... repeat subsuptac... rewrite H9...

  + assert (Inhabited (sub P 1)).
      assert (exists z, (sub P 1) == Singleton z).
        apply (P_0_Inhabited M P). unfold is_a_cell...
      inversion H6; clear H6. exists x... rewrite H8...
    inversion H6. exists x... repeat subsuptac... rewrite H10...

  + apply well_formed_Union...
      apply well_formed_sub...
      apply well_formed_sup...
      assert (dim x = S n)...
      assert (dim y <= n)...
      rewrite <- H8, H6 in H11...

  + apply well_formed_sup...

  + apply Finite_Union...

  + unfold moves_def in *...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set (S n)) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set (S n)) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

  + unfold moves_def in *...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel ) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
    * apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sup_cancel) || rewrite (sub_sup_Empty_set n (S k))||
                  rewrite sub_sub_Empty_set || rewrite Empty_set_ident_left || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          assert (S n = k)... rewrite <- H10 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel ) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S (S n)) (S (S n))) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
  Qed.

  Lemma maximal_property :
    forall X, Finite X -> Inhabited X -> forall n, Included X (sub Full_set (S n))
      -> exists x, x ∈ X /\ Disjoint (plus x) (Minus X).
  Proof with intuition.
    intros X hyp1 hyp2 n hyp3.
    assert (exists m, m ∈ X /\ (forall y, y ∈ X -> (triangle_rest X m y) -> m = y)) as hyp4.
      refine (maximal_exists' _ _ n _)...
    inversion hyp4 as [m]; clear hyp4...
    exists m...
    apply Disjoint_Intersection_condition.
    unfold Same_set, Included...
      exfalso.
      apply In_Intersection in H...
      unfold Minus, In at 1 in H3...
      inversion H3 as [z]; clear H3...
      assert (less m z). unfold less. exists x...
      assert (m = z). apply H1... apply (tr_trans _ _ z)... left...
      rewrite H5 in H; unfold less in H... pose (plus_minus_Disjoint z)...
      inversion d... inversion H. apply (H6 x0)...
    inversion H.
  Qed.

  Lemma Finite_eq_decidable : forall T, @Finite carrier T -> forall R, Finite R -> ((T == R) \/ ~(T == R)).
  Proof with intuition.
    intros T TFin.
      induction TFin; intros.
      - apply Finite_Empty_or_Inhabited in H...
        right...
        rewrite <- H in H0; inversion H0...
      - assert ((x ∈ R) \/ ~(x ∈ R))...
          apply all_decidable...
        + assert (R == Add (Setminus R (Singleton x)) x).
            apply Add_Setminus_cancel...
          assert (A == (Setminus R (Singleton x)) ∨ (A == (Setminus R (Singleton x)) → False))...
            apply IHTFin...
            apply Setminus_Finite'...
          * left...
            rewrite H4...
          * right...
            apply H4...
            rewrite <- H3...
            unfold Same_set, Included, Setminus...
            unfold In at 1...
            inversion H6; clear H6. apply H; rewrite H7...
            unfold In at 1 in H5...
            unfold Add in H6... apply In_Union in H6...
        + right... apply H2...  rewrite <- H1...
      - rewrite H...
  Qed.

  Lemma well_formed_Setminus : forall S, well_formed S -> forall T, well_formed (Setminus S T).
  Proof with intuition.
    intros.
    apply (well_formed_Included S)...
    crush.
  Qed.

  Lemma well_formed_Empty_set : well_formed Empty_set.
  Proof with intuition.
    unfold well_formed...
    exfalso...
    exfalso...
  Qed.

  Lemma Disjoint_Plus : forall M R T, Disjoint R T ->
     R ⊆ M -> T ⊆ M ->
     well_formed M ->
     Disjoint (Plus R) (Plus T).
  Proof with intuition.
    intros...
    constructor...
    apply In_Intersection in H3...
    inversion H4; clear H4...
    inversion H5; clear H5...
    assert (x0 = x1)...
      unfold well_formed in H2...
      remember (dim x0) as n.
      destruct n...
      exfalso.
      assert (In Empty_set x)...
        rewrite <- (plus_zero x0)...
      refine (H8 _ _ _ n _ _ _)...
      assert (S (dim x) = dim x0)...
      assert (S (dim x) = dim x1)...
      rewrite Heqn, <- H9...
      unfold perp in H2...
      assert (In Empty_set x)...
        rewrite <- H9...
    subst.
    inversion H...
    apply (H3 x1)...
  Qed.

  Lemma Disjoint_Minus : forall M R T, Disjoint R T ->
     R ⊆ M -> T ⊆ M ->
     well_formed M ->
     Disjoint (Minus R) (Minus T).
  Proof with intuition.
    intros...
    constructor...
    apply In_Intersection in H3...
    inversion H4; clear H4...
    inversion H5; clear H5...
    assert (x0 = x1)...
      unfold well_formed in H2...
      remember (dim x0) as n.
      destruct n...
      exfalso.
      assert (In Empty_set x)...
        rewrite <- (minus_zero x0)...
      refine (H8 _ _ _ n _ _ _)...
      assert (S (dim x) = dim x0)...
      assert (S (dim x) = dim x1)...
      rewrite Heqn, <- H9...
      unfold perp in H2...
      assert (In Empty_set x)...
        rewrite <- H10...
    subst.
    inversion H...
    apply (H3 x1)...
  Qed.

Lemma weird_moves_lemma1 : forall M P, forall x, In (Intersection M P) x
                     -> Disjoint M (plus x) -> (minus x) ⊆ M ->
    ((Singleton x) moves M to Setminus (M ∪ plus x) (minus x)).
Proof with intuition.
   unfold moves_def...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Setminus_is_Intersection_Complement...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Union_Setminus_cancel.
        rewrite I_U_dist_r.
        rewrite Empty_set_property.
        rewrite Empty_set_ident_right.
        apply Disjoint_result.
        apply Disjoint_Intersection_condition...
        apply all_decidable...
        apply Union_Included_cancel_right...
Qed.

Lemma weird_moves_lemma2 : forall M P, forall x, In (Intersection M P) x
                     -> Disjoint P (minus x) -> Included (plus x) P ->
    ((Singleton x) moves Setminus (P ∪ minus x) (plus x) to P).
Proof with intuition.
   unfold moves_def...
        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Union_Setminus_cancel.
        rewrite I_U_dist_r.
        rewrite Empty_set_property.
        rewrite Empty_set_ident_right.
        apply Disjoint_result.
        apply Disjoint_Intersection_condition...
        apply all_decidable...
        apply Union_Included_cancel_right...

        rewrite Plus_Singleton, Minus_Singleton.
        rewrite Setminus_is_Intersection_Complement...
Qed.

Lemma P_moves_Mx_to_Px : forall M P, is_a_cell (M, P) ->
               forall x, In (Intersection M P) x ->
               P moves Setminus M (Singleton x) to Setminus P (Singleton x).
  Proof with intuition.
    intros M P cellcond x Inters.
    unfold moves_def.
      repeat (rewrite Setminus_is_Intersection_Complement).
      repeat (rewrite U_I_dist_r).
      repeat (rewrite Intersection_trans).
      rewrite (Intersection_comm _ (√Minus P)).
      rewrite (Intersection_comm _ (√Plus P)).
      repeat (rewrite <- Intersection_trans).
      assert (P == (M ∪ Plus P) ∩ √Minus P).
        apply cellcond.
      rewrite <- H; clear H.
      assert (M == (P ∪ Minus P) ∩ √Plus P).
        apply cellcond.
      rewrite <- H; clear H.
      unfold Same_set, Included; repeat (basic; intuition)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint M (Plus P)).
          apply Prop_2_1.
        apply cellcond. exists P; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint P (Minus P)).
          apply Prop_2_1_dual.
        apply cellcond. exists M; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
Qed.

Lemma M_moves_Mx_to_Px : forall M P, is_a_cell (M, P) ->
               forall x, In (Intersection M P) x ->
               M moves Setminus M (Singleton x) to Setminus P (Singleton x).
  Proof with intuition.
    intros M P cellcond x Inters.
    unfold moves_def.
      repeat (rewrite Setminus_is_Intersection_Complement).
      repeat (rewrite U_I_dist_r).
      repeat (rewrite Intersection_trans).
      rewrite (Intersection_comm _ (√Minus M)).
      rewrite (Intersection_comm _ (√Plus M)).
      repeat (rewrite <- Intersection_trans).
      assert (P == (M ∪ Plus M) ∩ √Minus M).
        apply cellcond.
      rewrite <- H; clear H.
      assert (M == (P ∪ Minus M) ∩ √Plus M).
        apply cellcond.
      rewrite <- H; clear H.
      unfold Same_set, Included; repeat (basic; intuition)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint M (Plus M)).
          apply Prop_2_1.
        apply cellcond. exists P; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
        apply In_Complement...
        inversion H1; clear H1; subst...
        assert (Disjoint P (Minus M)).
          apply Prop_2_1_dual.
        apply cellcond. exists M; apply cellcond.
        inversion H1; clear H1.
        apply (H4 x0)...
Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*)


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 3                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma Prop_3_1 :
    forall x M P,
      (plus x) moves M to P ->
      receptive M ->
      (minus x) moves M to P.
  Proof with intuition.
    intros.
    assert (exists P', plus x moves M to P').
      exists P...
    apply Prop_2_1 in H1...
    assert (MinusPlus (minus x) == MinusPlus (plus x)).
      remember (Prop_1_1 x) as prop_1_1.
      apply (Same_set_trans _ (Minus (minus x) ∩ Minus (plus x))). apply prop_1_1. apply prop_1_1.
    assert (MinusPlus (minus x) ⊆ M). unfold Included...
    assert (Disjoint M (Plus(minus x))).
      unfold receptive, receptive_x in H0... 
      specialize H0 with x... 
      constructor...
      apply (H6).
      Focus 3. apply (Inhabited_intro _ _ x0)...
      Focus 2. intros... inversion H7; clear H7...
      unfold moves_def in H... rewrite H9 in H8...
        rewrite Intersection_trans in H8. repeat basic...
      unfold moves_def in H... unfold Included...
        assert ((In (Plus (plus x)) x1) \/ ~(In (Plus (plus x)) x1))... apply all_decidable...
        pose (Prop_1_1 x)... exfalso. assert (In (Empty_set) x1). rewrite <- H12...
        apply In_Intersection... apply In_Intersection in H... inversion H14.
        rewrite H8... apply In_Intersection... right... apply In_Intersection in H...
    assert (exists Y, minus x moves M to Y).
      apply Prop_2_1...
    inversion H6 as [P']; clear H6.
    assert (P == P').
      unfold moves_def in H7...
      rewrite H6.
      symmetry.
      rewrite I_U_dist_r.
      pose (Prop_1_1 x)...
      unfold PlusMinus in H7. rewrite H7.
      unfold moves_def in H...
      rewrite H12.
      rewrite I_U_dist_r.
      assert ((Plus (plus x) ∩ √Minus (plus x)) == (Plus (minus x) ∩ Plus (plus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... assert (In (Empty_set) x0)... rewrite H11. apply In_Intersection...
      assert ((M ∩ √Minus (plus x)) == (M ∩ √Minus (plus x) ∩ √Plus (minus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
          apply In_Complement... apply (H17 x0)...
      assert ((M ∩ √Minus (minus x)) == (M ∩ √Minus (minus x) ∩ √Plus (plus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... apply (H5 x0). apply In_Intersection...
      rewrite H, H16, H17.
      repeat rewrite (Intersection_trans M _ _).
      repeat rewrite Union_Complement_compat.
      rewrite (Union_comm (Minus (minus x)) _).
      rewrite (axiom1 x).
      rewrite (Union_comm _ (Minus (plus x)))...

    unfold moves_def in *...
      rewrite H6...
      rewrite H6...
  Qed.

  Lemma Prop_3_1_dual :
    forall x M P,
      (minus x) moves M to P ->
      receptive P ->
      (plus x) moves M to P.
  Proof with intuition.
    intros.
    assert (exists M', minus x moves M' to P).
      exists M...
    apply Prop_2_1_dual in H1... 
    assert (PlusMinus (minus x) == PlusMinus (plus x)).
      remember (Prop_1_1 x) as prop_1_1.
      apply (Same_set_trans _ (Plus (minus x) ∩ Plus (plus x))). apply prop_1_1. apply prop_1_1.
    assert (PlusMinus (minus x) ⊆ P). unfold Included...
    assert (Disjoint P (Minus (plus x))).
      unfold receptive, receptive_x in H0... 
      specialize H0 with x... 
      constructor...
      apply (H5).
      Focus 3. apply (Inhabited_intro _ _ x0)...
      Focus 2. intros... inversion H7; clear H7...
      unfold moves_def in H... rewrite H7 in H8...
        rewrite Intersection_trans in H8. repeat basic...
      unfold moves_def in H... unfold Included...
        assert ((In (Minus (minus x)) x1) \/ ~(In (Minus (minus x)) x1))... apply all_decidable...
        pose (Prop_1_1 x)... 
        rewrite H7... apply In_Intersection... right... apply In_Intersection in H...
    assert (exists Y, plus x moves Y to P).
      apply Prop_2_1_dual...
    inversion H6 as [M']; clear H6.
    assert (M == M').
      unfold moves_def in H7...
      rewrite H8.
      symmetry.
      rewrite I_U_dist_r.
      fold (MinusPlus (plus x)).
      unfold moves_def in H...
      rewrite H9.
      rewrite I_U_dist_r.
      fold (MinusPlus (minus x)).
      pose (Prop_1_1 x)... 
      rewrite H10, H14.
      assert ((P ∩ √Plus (plus x)) == (P ∩ √Plus (plus x) ∩ √Minus (minus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
          apply In_Complement... apply (H5 x0)...
      assert ((P ∩ √Plus (minus x)) == (P ∩ √Plus (minus x) ∩ √Minus (plus x))).
        unfold Same_set; unfold Included; repeat (basic; intuition).
        apply In_Complement... apply (H17 x0)...
      rewrite H13, H16. 
      repeat rewrite (Intersection_trans P _ _).
      repeat rewrite Union_Complement_compat.
      rewrite (axiom1 x)...

    unfold moves_def in *...
      rewrite H6...
      rewrite H6...
  Qed.

  Definition Lemma_3_2_b_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)), (sup P n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)) )
    /\ (Minus X ∩ (sub M (S n))) == Empty_set))).

  Definition Lemma_3_2_c_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((PlusMinus X) ⊆ (sub M (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub M (S n)) ∪ Minus X) ∩ √(Plus X)) ∪ X, P ∪ X)
    ))).

  Definition Lemma_3_2_b_dual_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((MinusPlus X) ⊆ (sub P (S n)))) ->
    is_a_cell ( (sup M n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)), (sup P n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)) )
    /\ (Plus X ∩ (sub P (S n))) == Empty_set))).

  Definition Lemma_3_2_c_dual_st : nat -> nat -> Prop :=
    (fun n => (fun m =>
    forall (X : Ensemble carrier),
    Cardinal X m ->
    (forall M P, (is_a_cell (M, P) /\ celldim (M, P) n) ->
    ((X ⊆ (sub (Full_set) (S (S n)))) /\ well_formed X /\ ((MinusPlus X) ⊆ (sub P (S n)))) ->
    is_a_cell ( M ∪ X, (sup P n) ∪ (((sub P (S n)) ∪ Plus X) ∩ √(Minus X)) ∪ X)
    ))).

  Definition Prop_3_3_st : nat -> Prop := 
    fun n => forall M P, is_a_cell (M, P) -> 
    celldim (M, P) n ->
    receptive M /\ receptive P.

  Lemma dim_Prop_3_3 : forall n m, n <= m -> Prop_3_3_st m -> Prop_3_3_st n.
  Proof with intuition.
    unfold Prop_3_3_st, celldim, setdim; intros. 
    apply H0...
    apply le_trans with n...
  Qed.

  Lemma Lemma_3_2_b_n_0 : forall n, Lemma_3_2_b_st n 0.
  Proof with intuition.
    intros n.
    unfold Lemma_3_2_b_st.
    intros X Xcard.
    assert (X == Empty_set) as XEmpty.
      apply Cardinality_zero_Empty_set; assumption.
    assert (Finite X) as XFinite.
      apply (Cardinal_are_Finite 0)...
    intros M P H.
    inversion H as [MPcell MPdim]; clear H.
    intros H.
    inversion H as [Xdim K]; clear H.
    inversion K as [Xwf Xcond]; clear K.
    split.

    (* is_a_cell' *)
    assert (Minus X == Empty_set) as MXE.
      rewrite XEmpty.
      unfold Minus, Same_set, Included, In... inversion H...
    assert (Plus X == Empty_set) as PXE.
      rewrite XEmpty.
      unfold Plus, Same_set, Included, In... inversion H...
    assert (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X) == M) as MM.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    assert (sup P n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X) == P) as PP.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      rewrite (cell_dim_n_property M P).
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    assumption.
    assumption.
    symmetry in MM; symmetry in PP.
    apply (Same_set_is_a_cell M P)...

    (* Disjoint *)
    apply Disjoint_Intersection_condition.
    constructor.
    unfold not; intros.
    basic...
    unfold In, Minus in H0...
    inversion H0 as [z J]...
    assert (In Empty_set z). rewrite <- XEmpty...
    inversion H3.
  Qed.

  Lemma Lemma_3_2_b_dual_n_0 : forall n, Lemma_3_2_b_dual_st n 0.
  Proof with intuition.
    intros n.
    unfold Lemma_3_2_b_dual_st.
    intros X Xcard.
    assert (X == Empty_set) as XEmpty.
      apply Cardinality_zero_Empty_set; assumption.
    assert (Finite X) as XFinite.
      apply (Cardinal_are_Finite 0)...
    intros M P H.
    inversion H as [MPcell MPdim]; clear H.
    intros H.
    inversion H as [Xdim K]; clear H.
    inversion K as [Xwf Xcond]; clear K.
    split.

    (* is_a_cell' *)
    assert (Minus X == Empty_set) as MXE.
      rewrite XEmpty.
      unfold Minus, Same_set, Included, In... inversion H...
    assert (Plus X == Empty_set) as PXE.
      rewrite XEmpty.
      unfold Plus, Same_set, Included, In... inversion H...
    assert (sup M n ∪ ((sub P (S n) ∪ Plus X) ∩ √Minus X) == M) as MM.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      rewrite <- (cell_dim_n_property M P)...
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    assert (sup P n ∪ ((sub P (S n) ∪ Plus X) ∩ √Minus X) == P) as PP.
      rewrite MXE, PXE.
      rewrite Complement_Empty_set.
      rewrite Empty_set_ident_right.
      rewrite Full_set_ident_right.
      unfold sup, sub, Same_set, Included, In...
        crush. crush. crush.
        assert (dim x <= n).
          unfold celldim in *...
        inversion H0; [right | left]...
    symmetry in MM; symmetry in PP.
    apply (Same_set_is_a_cell M P)...

    (* Disjoint *)
    apply Disjoint_Intersection_condition.
    constructor.
    unfold not; intros.
    basic...
    unfold In, Minus in H0...
    inversion H0 as [z J]...
    assert (In Empty_set z). rewrite <- XEmpty...
    inversion H3.
  Qed.

  Lemma Lemma_3_2_b_0_1 : Lemma_3_2_b_st 0 1.
  Proof with intuition.
    unfold Lemma_3_2_b_st.
    intros X Xcard M P J K.
    inversion J as [MPcell MPdim]; clear J.
    inversion K as [Xdim L]; clear K.
    inversion L as [Xwf Xcond]; clear L.
    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    set (Y := ((sub M 1 ∪ Minus X) ∩ √Plus X)).

    assert (dim x = 1) as dimx.
      rewrite Xsing in Xdim.
      autounfold with * in Xdim... assert (S (dim x) = 2)... apply Xdim...
    assert (sub M 1 == plus x) as subM0.
      assert (exists d, sub M 1 == Singleton d).
      apply dim_0_Singleton.
      apply (M_0_Inhabited' M P)...
      apply MPcell. inversion H as [f L]; clear H.
      assert (plus x == Singleton f). apply Included_Singleton.
      apply plus_Inhabited. rewrite dimx...
      rewrite <- L.
      assert (PlusMinus X == plus x).
      unfold PlusMinus. rewrite Xsing.
      assert (Plus (Singleton x) ∩ √Minus (Singleton x) == PlusMinus (Singleton x)).
      unfold PlusMinus...
      rewrite H.
      rewrite PlusMinus_Singleton...
      rewrite <- H... rewrite <- H in L...
    assert (Y == minus x) as Ydef.
      unfold Y.
      rewrite Xsing, subM0, Plus_Singleton, Minus_Singleton.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_left.
      apply Intersection_Included_left.
      apply Disjoint_property_right.
      apply plus_minus_Disjoint.
    assert (sup M 0 ∪ Y == minus x) as HypA.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero M), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.
    assert (sup P 0 ∪ Y == minus x) as HypB.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero P), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.

    split.

    apply (Same_set_is_a_cell (minus x) (minus x))...
    unfold is_a_cell...
        apply minus_Inhabited. rewrite dimx. auto.
        apply minus_Inhabited. rewrite dimx. auto.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H, H0;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.

      rewrite Xsing, Minus_Singleton, subM0.
      apply Disjoint_Intersection_condition.
      apply Disjoint_sym. apply plus_minus_Disjoint.
  Qed.

  Lemma Lemma_3_2_b_dual_0_1 : Lemma_3_2_b_dual_st 0 1.
  Proof with intuition.
    unfold Lemma_3_2_b_st.
    intros X Xcard M P J K.
    inversion J as [MPcell MPdim]; clear J.
    inversion K as [Xdim L]; clear K.
    inversion L as [Xwf Xcond]; clear L.
    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    set (Y := ((sub P 1 ∪ Plus X) ∩ √Minus X)).

    assert (dim x = 1) as dimx.
      rewrite Xsing in Xdim.
      autounfold with * in Xdim... assert (S (dim x) = 2)... apply Xdim...
    assert (sub P 1 == minus x) as subM0.
      assert (exists d, sub P 1 == Singleton d).
      apply dim_0_Singleton.
      apply (P_0_Inhabited' M P)...
      apply MPcell. inversion H as [f L]; clear H.
      assert (minus x == Singleton f). apply Included_Singleton.
      apply minus_Inhabited. rewrite dimx...
      rewrite <- L.
      assert (MinusPlus X == minus x).
      unfold MinusPlus. rewrite Xsing.
      assert (Minus (Singleton x) ∩ √Plus (Singleton x) == MinusPlus (Singleton x)).
      unfold MinusPlus...
      rewrite H.
      rewrite MinusPlus_Singleton...
      rewrite <- H... rewrite <- H in L...
    assert (Y == plus x) as Ydef.
      unfold Y.
      rewrite Xsing, subM0, Plus_Singleton, Minus_Singleton.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_left.
      apply Intersection_Included_left.
      apply Disjoint_property_right.
      apply Disjoint_sym. 
      apply plus_minus_Disjoint.
    assert (sup M 0 ∪ Y == plus x) as HypA.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero M), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.
    assert (sup P 0 ∪ Y == plus x) as HypB.
      unfold is_a_cell in MPcell...
      rewrite (sup_zero P), Ydef.
      rewrite Empty_set_ident_left.
      reflexivity.

    split.

    apply (Same_set_is_a_cell (plus x) (plus x))...
    unfold is_a_cell...
        apply plus_Inhabited. rewrite dimx. auto.
        apply plus_Inhabited. rewrite dimx. auto.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H1, H3;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.
        apply dim_1_properties in dimx...
        unfold moves_def; split; rewrite H1, H3;
          rewrite Empty_set_ident_right; rewrite Complement_Empty_set;
          rewrite Full_set_ident_right; reflexivity.

      rewrite Xsing, Plus_Singleton, subM0.
      apply Disjoint_Intersection_condition.
      apply plus_minus_Disjoint.
  Qed.

  Lemma Lemma_3_2_Step_1 :
    forall n m, (Lemma_3_2_b_st n m) -> (Lemma_3_2_c_st n m).
  Proof with intuition.
    unfold Lemma_3_2_b_st, Lemma_3_2_c_st.
    intros n m Hyp1 X Xcard M P J K.

    assert (Finite X) as XFin.
      apply (Cardinal_are_Finite m)...

    set (Y := ((sub M (S n) ∪ Minus X) ∩ √Plus X))...

    assert (is_a_cell
               (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X),
                sup P n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X))
             ∧ Minus X ∩ sub M (S n) == Empty_set) as Hyp2.
      apply Hyp1...
      intuition.

    assert (X moves Y to (sub M (S n))) as movement_result.
      unfold moves_def...
      unfold Y.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      rewrite I_U_dist_r.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      fold (PlusMinus X).
      assert (sub M (S n) ∩ √Minus X == sub M (S n)).
        unfold Same_set, Included...
        apply In_Intersection in H6...
        apply In_Intersection...
        apply In_Complement...
        assert (In Empty_set x)...
          rewrite <- H5.
          apply In_Intersection...
      rewrite H6.
      rewrite Union_Included_right...

      assert (X == sub X (S (S n))) as dimX.
        unfold Same_set, Included, sub...
        unfold In at 1 in H6...
      assert (Y == sub Y (S n)) as dimY.
        unfold Same_set, Included...
        unfold sub, In at 1... unfold Y in H6.
        apply In_Intersection in H6...
        apply In_Union in H7...
        assert ((dim x) = n)...
        apply (Minus_dim _ _ _ H1)...

    assert ((sub Y (S n)) moves (sub M n) to (sub P n)) as movement_result2.
      unfold is_a_cell in H2...
      fold Y in H11.
      assert ((sub (sup M n ∪ Y) (S n)) moves (sub (sup M n ∪ Y) n) to (sub (sup P n ∪ Y) n)).
        apply moves_by_dim...
      assert (sub Y n == Empty_set).
        rewrite dimY. rewrite sub_sub_Empty_set...
      repeat (rewrite sub_Union in H12 || rewrite H14 in H12 ).
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_Empty_set n) in H12)...
      repeat (rewrite Empty_set_ident_left in H12|| rewrite Empty_set_ident_right in H12).
      trivial.


    unfold is_a_cell in *...
    - apply (Inhabited_Included (sup M n ∪ Y))...

    - apply (Inhabited_Included P)...

    - rewrite dimY, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < n} + {n0 = n} + {n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
          apply eq_add_S in H18. rewrite <- H18 in a0...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S (S n))) ||
                  rewrite Empty_set_ident_right || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
          unfold Y.
          assert (well_formed (sub (sup M n ∪ ((sub M (S n) ∪ Minus X) ∩ √Plus X)) (S n))).
          apply well_formed_sub...
          rewrite sub_Union in H18.
          rewrite sub_sup_Empty_set in H18...
          rewrite Empty_set_ident_left in H18...
          rewrite <- Setminus_is_Intersection_Complement in H18.
          rewrite sub_Setminus in H18.
          rewrite sub_Union in H18.
          rewrite sub_Plus in H18.
          rewrite sub_Minus in H18.
          rewrite sub_idemp in H18.
          rewrite <- dimX in H18.
          rewrite Setminus_is_Intersection_Complement in H18...
          + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S n)) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...


    - assert (P == sup P (S n)) as dimP.
        unfold Same_set, Included, sup, In...
      rewrite dimP, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < S n} + {n0 = S n} + {S n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
        + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_Empty_set.

    - apply Finite_Union...

    - apply Finite_Union...

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        assert (S n = n0)... rewrite <- H21 in a...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_Empty_set n (S n)) ||
                rewrite (sub_sup_cancel) || rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- dimX.
        rewrite Setminus_is_Intersection_Complement. fold Y.
        pose (moves_by_dim _ _ _ H17 n).
        fold Y in m0.
        repeat (rewrite sub_Union in m0).
        rewrite dimY in m0.
        repeat (rewrite sub_idemp in m0).
        rewrite (sub_sup_Empty_set _ (S n)) in m0...
        rewrite dimY.
        rewrite sub_sub_Empty_set in m0.
        rewrite (sub_sup_cancel) in m0...
        rewrite (sub_sup_cancel) in m0...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- (sub_idemp _ M).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        rewrite <- (cell_dim_n_property M P)...
        rewrite <- dimX.
        rewrite <- dimY... unfold is_a_cell...
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite (sub_sub_Empty_set _ (S (n0))) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P n0 == Empty_set).
          unfold sub, Same_set, Included...
          exfalso. unfold In at 1 in H18...
          assert (dim x <= n)...
          assert ( n < n)...
            apply (lt_le_trans _ (dim x))...
            rewrite <- H22 in b...
            inversion H18...
        rewrite (H18).
        rewrite Empty_set_ident_left...
        apply Empty_set_moves.

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        apply eq_add_S in H18... rewrite <- H18 in a...
      + rewrite <- b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_cancel n0 n0) || rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P (S (S n)) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        rewrite H18; rewrite Empty_set_ident_left.
        rewrite <- (sub_idemp _ P).
        rewrite <- (sub_idemp _ M).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        rewrite <- (cell_dim_n_property M P)...
        apply moves_by_dim... unfold is_a_cell...
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set (S (S n)) (S n0)) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub P (S n0) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        assert (sub P (n0) == Empty_set).
          assert (P == sup P (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1... unfold In at 1 in H21...
          rewrite H21.
          rewrite sub_sup_Empty_set...
        rewrite H18, H21. rewrite Empty_set_ident_left.
        apply Empty_set_moves.
  Qed.

  Lemma Lemma_3_2_dual_Step_1 :
    forall n m, (Lemma_3_2_b_dual_st n m) -> (Lemma_3_2_c_dual_st n m).
  Proof with intuition.
    unfold Lemma_3_2_b_st, Lemma_3_2_c_st.
    intros n m Hyp1 X Xcard M P J K.

    assert (Finite X) as XFin.
      apply (Cardinal_are_Finite m)...

    set (Y := ((sub P (S n) ∪ Plus X) ∩ √Minus X))...

    assert (is_a_cell
               (sup M n ∪ Y,
                sup P n ∪ Y)
             ∧ Plus X ∩ sub P (S n) == Empty_set) as Hyp2.
      unfold Y.
      apply Hyp1...
      intuition.

    assert (X moves sub M (S n) to Y) as movement_result. 
      unfold moves_def...
      unfold Y.
      rewrite (cell_dim_n_property M P)...
      unfold Y.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      rewrite I_U_dist_r.
      rewrite I_U_dist_r.
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      fold (MinusPlus X).
      assert (sub P (S n) ∩ √Plus X == sub P (S n)).
        unfold Same_set, Included...
        apply In_Intersection in H6...
        apply In_Intersection...
        apply In_Complement...
        assert (In Empty_set x)...
          rewrite <- H5.
          apply In_Intersection...
      rewrite H6.
      rewrite Union_Included_right...
      rewrite (cell_dim_n_property M P)...

    assert (X == sub X (S (S n))) as dimX.
        unfold Same_set, Included, sub...
        unfold In at 1 in H6...
    assert (Y == sub Y (S n)) as dimY.
        unfold Same_set, Included...
        unfold sub, In at 1... unfold Y in H6.
        apply In_Intersection in H6...
        apply In_Union in H7...
        assert ((dim x) = n)...
        apply (Plus_dim _ _ H1)...

    assert ((sub Y (S n)) moves (sub M n) to (sub P n)) as movement_result2.
      unfold is_a_cell in H2...
      assert ((sub (sup M n ∪ Y) (S n)) moves (sub (sup M n ∪ Y) n) to (sub (sup P n ∪ Y) n)).
        apply moves_by_dim...
      assert (sub Y n == Empty_set).
        rewrite dimY. rewrite sub_sub_Empty_set...
      repeat (rewrite sub_Union in H12 || rewrite H14 in H12 ).
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_cancel n n) in H12)...
      (rewrite (sub_sup_Empty_set n) in H12)...
      repeat (rewrite Empty_set_ident_left in H12|| rewrite Empty_set_ident_right in H12).
      trivial.

    unfold is_a_cell in *...
    - apply (Inhabited_Included M)...

    - apply (Inhabited_Included (sup P n ∪ Y))...

    - assert (M == sup M (S n)) as dimM.
        unfold Same_set, Included, sup, In...
      rewrite dimM, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < S n} + {n0 = S n} + {S n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
        + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_Empty_set.

    - rewrite dimY, dimX.
      apply well_formed_by_dimension...
        repeat (rewrite sub_Union).
        assert ({n0 < n} + {n0 = n} + {n < n0})...
          apply lt_eq_lt_dec.
        + repeat (rewrite (sub_sub_Empty_set) || rewrite Empty_set_ident_right)...
          apply well_formed_sub. apply well_formed_sup...
          apply eq_add_S in H18. rewrite <- H18 in a0...
        + rewrite b.
          repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S (S n))) ||
                  rewrite Empty_set_ident_right || rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...
          unfold Y.
          assert (well_formed (sub (sup M n ∪ ((sub P (S n) ∪ Plus X) ∩ √Minus X)) (S n))).
          apply well_formed_sub...
          rewrite sub_Union in H18.
          rewrite sub_sup_Empty_set in H18...
          rewrite Empty_set_ident_left in H18...
          rewrite <- Setminus_is_Intersection_Complement in H18.
          rewrite sub_Setminus in H18.
          rewrite sub_Union in H18.
          rewrite sub_Plus in H18.
          rewrite sub_Minus in H18.
          rewrite sub_idemp in H18.
          rewrite <- dimX in H18.
          rewrite Setminus_is_Intersection_Complement in H18...
          + repeat (rewrite (sub_sup_Empty_set) || rewrite (sub_sub_Empty_set (S n)) ||
                  rewrite Empty_set_ident_left)...
          apply well_formed_sub. apply well_formed_sub...

    - apply Finite_Union...

    - apply Finite_Union...

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        apply eq_add_S in H18... rewrite <- H18 in a...
      + rewrite <- b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_cancel n0 n0) || rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub M (S (S n)) == Empty_set).
          assert (M == sup M (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        rewrite H18; rewrite Empty_set_ident_left.
        rewrite <- (sub_idemp _ P).
        rewrite <- (sub_idemp _ M).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        apply moves_by_dim... 
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set (S (S n)) (S n0)) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub M (S n0) == Empty_set).
          assert (M == sup M (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1...
            unfold In at 1 in H18...
          rewrite H18.
          rewrite sub_sup_Empty_set...
        assert (sub M (n0) == Empty_set).
          assert (M == sup M (S n))...
            unfold Same_set, Included, sup...
            unfold In at 1... unfold In at 1 in H21...
          rewrite H21.
          rewrite sub_sup_Empty_set...
        rewrite H18, H21. rewrite Empty_set_ident_left.
        apply Empty_set_moves.

    - unfold Y.
      apply moves_by_dim'; intros.
      repeat (rewrite <- Setminus_is_Intersection_Complement || rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
      rewrite dimX.
      assert ({n0 < n} + {n0 = n} + {n0 = S n} + {S n < n0 })...
        apply lt_eq_eq_lt_dec.
      + repeat (rewrite (sub_sup_cancel) || rewrite sub_sub_Empty_set ||
                rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        apply moves_by_dim...
        rewrite <- H18 in a...
        rewrite <- H18 in a...
        assert (S n = n0)... rewrite <- H21 in a...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite (sub_sup_Empty_set n (S n)) ||
                rewrite (sub_sup_cancel) || rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- dimX.
        rewrite Setminus_is_Intersection_Complement. fold Y.
        pose (moves_by_dim _ _ _ H17 n).
        fold Y in m0.
        repeat (rewrite sub_Union in m0).
        rewrite dimY in m0.
        repeat (rewrite sub_idemp in m0).
        rewrite (sub_sup_Empty_set _ (S n)) in m0...
        rewrite dimY.
        rewrite sub_sub_Empty_set in m0.
        rewrite (sub_sup_cancel) in m0...
        rewrite (sub_sup_cancel) in m0...
      + rewrite b.
        repeat (rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                rewrite Empty_set_ident_right ||
                rewrite (sub_sup_Empty_set) ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        rewrite <- (sub_idemp _ P).
        repeat (rewrite <- sub_Minus || rewrite <- sub_Union || rewrite <- sub_Plus || rewrite <- sub_Setminus || rewrite Setminus_is_Intersection_Complement).
        fold Y...
        rewrite <- dimX.
        rewrite <- dimY...
      + repeat (rewrite (sub_sup_Empty_set) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite (sub_sub_Empty_set _ (S (n0))) ||
                rewrite (sub_sub_Empty_set (S n) (n0)) ||
                rewrite (sub_sub_Empty_set _ (S (S n0))) ||
                rewrite Empty_set_ident_right ||
                rewrite Plus_Empty_set || rewrite Empty_set_ident_left ||
                rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
        assert (sub M n0 == Empty_set).
          unfold sub, Same_set, Included...
          exfalso. unfold In at 1 in H18...
          assert (dim x <= n)...
          assert ( n < n)...
            apply (lt_le_trans _ (dim x))...
            rewrite <- H22 in b...
            inversion H18...
        rewrite (H18).
        rewrite Empty_set_ident_left...
        apply Empty_set_moves.
  Qed.

  Lemma Lemma_3_2_Step_2 :
    forall n, ((Lemma_3_2_b_st n 1) -> (forall m, Lemma_3_2_b_st n (S m))).
  Proof with intuition.
    intros n hypothesis_for_1 m.

    induction m. assumption.

    unfold Lemma_3_2_b_st in *.
    intros X Xcard M P H J.
    inversion H as [MPcell MPdim]; clear H.
    inversion J as [Xdim K]; clear J.
    inversion K as [Xwf Xcond]; clear K.

    assert (exists x, x ∈ X /\ Disjoint (plus x) (Minus X)) as R.  (* maximal *)
      apply (wf_maximal_exists X n)...
      apply (Cardinal_are_Finite (S (S m)))...
      apply Cardinal_Sn in Xcard...
    inversion R as [x xcond]; clear R.
    inversion xcond as [xinX disj]; clear xcond.
    assert (dim x = S n) as dimx. idtac...

    assert (plus x ⊆ sub M (S n)) as K.
      apply (Included_trans _ (PlusMinus X))...
        unfold PlusMinus. rewrite <- (Intersection_idemp (plus x)).
        apply Intersection_Included_compat...
          unfold Included, Plus, In... exists x...
        apply Disjoint_property_left...

    assert (is_a_cell
                 (sup M n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
                 sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
               ∧ Minus (Singleton x) ∩ sub M (S n) == Empty_set).
        apply hypothesis_for_1...
        apply Cardinality_Singleton_is_one.
        unfold Included... inversion H; subst...
        rewrite PlusMinus_Singleton...
    inversion H as [LA LB]; clear H.

    set (N :=  sup M n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Q :=  sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))).
    set (Z := Intersection X (Complement (Singleton x))).
    set (Y' := (sub N (S n) ∪ (Minus Z)) ∩ √Plus Z).
    set (Y  := (sub M (S n) ∪ (Minus X)) ∩ √Plus X).
    assert (X == (Singleton x) ∪ Z) as XZrel.
      unfold Z.
      rewrite Union_comm. rewrite U_I_dist_r.
      rewrite Full_set_property. rewrite Full_set_ident_right.
      unfold Same_set, Included... apply In_Union in H... inversion H0. rewrite <- H...
      intuition.

    assert (Cardinal Z (S m) /\ Z ⊆ sub Full_set (S (S n)) /\ well_formed Z) as Zproperties.
      idtac...
      unfold Z. rewrite <- Setminus_is_Intersection_Complement.
      apply (Cardinal_Setminus carrier_decidable_eq (S (S m)))...
      apply (Included_trans _ X _)...
      unfold Z.
      apply Intersection_Included_cancel_right...
        unfold Z. apply (well_formed_Included X)...
        apply Intersection_Included_cancel_right...
    inversion Zproperties as [Zcard T].
    inversion T as [Zdim Zwf]. clear T Zproperties.

    split.

    assert (is_a_cell ((sup N n  ∪ Y'), (sup Q n ∪ Y')) /\ Minus Z ∩ sub N (S n) == Empty_set) as AA.
      apply (IHm Z)...
        (* *)
        unfold celldim, N, Q, setdim...
          apply In_Union in H...
          apply In_Union in H0...
          unfold sup, In at 1 in H...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
          apply In_Union in H0...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Minus_Singleton x) in H.
          apply minus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
        assert (sub N (S n) == Intersection (Union (sub M (S n)) (minus x)) (Complement (plus x))) as JA.
            unfold N.
            rewrite sub_Union.
            rewrite sub_Intersection. rewrite sub_Union.
            rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left...
            rewrite sub_idemp.
            rewrite Minus_Singleton.
            rewrite Plus_Singleton.
            unfold Same_set, Included;
              repeat basic...
              right.
              repeat subsuptac...
        assert (PlusMinus Z ⊆ Intersection ((PlusMinus X) ∪ (minus x)) (Complement (plus x))) as JB.
          unfold PlusMinus.
          rewrite XZrel.
          rewrite Plus_Union.
          rewrite Minus_Union.
          rewrite Plus_Singleton.
          rewrite Minus_Singleton.
          rewrite <- Union_Complement_compat.
          unfold Included; repeat (basic; intuition).
          assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
            assert (Finite (minus x))... assert (decidable (minus x))... apply H3.
            apply In_Complement; unfold not...
            unfold Plus, Z, In at 1 in H1.
            inversion H1 as [d SS]...
            apply In_Intersection in H3...
            unfold well_formed in Xwf...
            assert (x = d).
            refine (H7 _ _ _ n _ _ _)... unfold perp in H8...
            assert (In Empty_set x0). rewrite <- H9. apply In_Intersection... inversion H8. rewrite H8 in H6.
            apply In_Complement in H6; unfold not in H6...

      rewrite JA, JB.
        apply Intersection_Included_compat...
        apply Union_Included_compat...

      assert (sup N n == sup M n) as J1.
        unfold N.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1...
        repeat subsuptac...
        apply In_Intersection in H1...
        apply In_Union in H2...
        repeat subsuptac...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1.
        rewrite H5 in H3. exfalso...

      assert (sup Q n == sup P n) as J2.
        unfold Q.
        rewrite Minus_Singleton, Plus_Singleton.
        rewrite sup_Union, sup_idemp.
        unfold Same_set, Included...
          apply In_Union in H1...
        repeat subsuptac...
        apply In_Intersection in H1...
        apply In_Union in H2...
        assert (dim x0 = n)...  rewrite H2 in H3. exfalso...
        apply minus_dim in H1. rewrite dimx in H1. inversion H1.
        rewrite H5 in H3. exfalso...

      assert (Y == Y') as J3.
        unfold Y, Y', N.
        rewrite XZrel.
        rewrite Minus_Union.
        rewrite Plus_Union.
        rewrite <- Union_Complement_compat.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left.
        rewrite sub_Intersection. rewrite sub_Union. rewrite sub_idemp. rewrite sub_Minus.
        rewrite <- Intersection_trans.
        rewrite <- Union_trans.
        rewrite I_U_dist_r.
        rewrite sub_Singleton...
        rewrite Minus_Singleton, Plus_Singleton.
        unfold Same_set, Included; repeat (basic; intuition).
        left; repeat (basic; intuition).
        left; repeat (basic; intuition).
        right; repeat (basic; intuition).
        apply In_Complement... apply (H2 x0)...
        apply In_Intersection... apply (Minus_Included Z)...
        rewrite XZrel...
      fold (is_a_cell' (sup N n ∪ Y') (sup Q n ∪ Y')) in AA.
      rewrite J1, J2, <- J3 in AA...
      fold N in LA.
      fold Q in LA.

    assert (celldim (N, Q) n) as NQdim.
      unfold celldim, N, Q.
      setdimtac...
      rewrite dimx...
      rewrite dimx...
    assert (sub N (S n) == (sub M (S n) ∪ (minus x)) ∩ √(plus x)).
      unfold N.
      rewrite Minus_Singleton, Plus_Singleton.
      unfold Same_set, Included, sub, sup; repeat (basic; intuition)...
        exfalso. rewrite H2 in H3...
        right; basic...
    assert (Minus Z ∩ sub N (S n) == Empty_set).
      apply (IHm Z Zcard N Q)...
      rewrite H.
      unfold PlusMinus, Z, Included; repeat (basic; intuition)...
        inversion H2; clear H2...
        assert ((In (minus x) x0) \/ ~(In (minus x) x0))...
          apply all_decidable...
          left; apply Xcond...
          unfold PlusMinus; repeat basic... exists x1...
          apply In_Complement...
          apply H3... inversion H2; clear H2...
          exists x2; repeat basic...
          apply In_Complement...
          inversion H7; clear H7...
          rewrite <- H9 in *...
          apply In_Complement...
          inversion H2...
          apply In_Intersection in H5...
          assert (x = x1)... unfold well_formed in Xwf...
          refine (H8 _ _ _ n _ _ _)...
          unfold perp in H9... assert (In (Empty_set) x0)...
          rewrite <- H10...
    assert (Disjoint (sub M (S n)) (minus x)).
      rewrite Disjoint_Intersection_condition.
      rewrite Intersection_comm.
      rewrite Minus_Singleton in LB...
    assert ((sub N (S n) ∪ (plus x)) ∩ √(minus x) == sub M (S n)).
      rewrite H.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property...
      rewrite Empty_set_ident_right.
      assert (Included (minus x) (√(sub M (S n)))).
        apply Disjoint_property_right...
      apply Complement_Included_compat in H2...
      rewrite Complement_Complement_compat in H2...
      assert (Included (minus x) (√(sub M (S n)))).
        apply Disjoint_property_right...
      unfold Same_set, Included; repeat (basic; intuition)...
       apply all_decidable... apply Finite_sub... apply MPcell.
    rewrite <- H2.
    rewrite XZrel.
    rewrite Minus_Union.
    rewrite Minus_Singleton.
    rewrite <- Intersection_trans.
    rewrite I_U_dist_l.
    rewrite (I_U_dist_r (sub N (S n))).
    rewrite (I_U_dist_r (plus x)).
    rewrite H0; clear H0.
    unfold Same_set, Included...
    exfalso; repeat (basic; intuition)...
    apply (H1 x0)... basic...
    apply (Minus_Included Z X)... rewrite XZrel...
  Qed.

  Lemma Lemma_3_2_dual_Step_2 :
    forall n, ((Lemma_3_2_b_dual_st n 1) -> (forall m, Lemma_3_2_b_dual_st n (S m))).
  Proof with intuition.
    intros n hypothesis_for_1 m.

    induction m. assumption.

    unfold Lemma_3_2_b_dual_st in *.
    intros X Xcard M P H J.
    inversion H as [MPcell MPdim]; clear H.
    inversion J as [Xdim K]; clear J.
    inversion K as [Xwf Xcond]; clear K.

    assert (exists x, x ∈ X /\ Disjoint (minus x) (Plus X)) as R. 
      apply (wf_minimal_exists X n)...
      apply (Cardinal_are_Finite (S (S m)))...
      apply Cardinal_Sn in Xcard...
    inversion R as [x xcond]; clear R.
    inversion xcond as [xinX disj]; clear xcond.
    assert (dim x = S n) as dimx. idtac...

    assert (minus x ⊆ sub P (S n)) as K.
      apply (Included_trans _ (MinusPlus X))...
        unfold MinusPlus. rewrite <- (Intersection_idemp (minus x)).
        apply Intersection_Included_compat...
          unfold Included, Minus, In... exists x...
        apply Disjoint_property_left...

    assert (is_a_cell
                 (sup M n ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)),
                 sup P n ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
               ∧ Plus (Singleton x) ∩ sub P (S n) == Empty_set).
        apply hypothesis_for_1...
        apply Cardinality_Singleton_is_one.
        unfold Included... inversion H; subst...
        rewrite MinusPlus_Singleton...
    inversion H as [LA LB]; clear H.

    set (N :=  sup M n ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))).
    set (Q :=  sup P n ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))).
    set (Z := Intersection X (Complement (Singleton x))).
    set (Y' := (sub Q (S n) ∪ (Plus Z)) ∩ √Minus Z).
    set (Y  := (sub P (S n) ∪ (Plus X)) ∩ √Minus X).
    assert (X == (Singleton x) ∪ Z) as XZrel.
      unfold Z.
      rewrite Union_comm. rewrite U_I_dist_r.
      rewrite Full_set_property. rewrite Full_set_ident_right.
      unfold Same_set, Included... apply In_Union in H... inversion H0. rewrite <- H...
      intuition.

    assert (Cardinal Z (S m) /\ Z ⊆ sub Full_set (S (S n)) /\ well_formed Z) as Zproperties.
      idtac...
      unfold Z. rewrite <- Setminus_is_Intersection_Complement.
      apply (Cardinal_Setminus carrier_decidable_eq (S (S m)))...
      apply (Included_trans _ X _)...
      unfold Z.
      apply Intersection_Included_cancel_right...
        unfold Z. apply (well_formed_Included X)...
        apply Intersection_Included_cancel_right...
    inversion Zproperties as [Zcard T].
    inversion T as [Zdim Zwf]. clear T Zproperties.

    split.

    assert (is_a_cell ((sup N n  ∪ Y'), (sup Q n ∪ Y')) /\ Plus Z ∩ sub Q (S n) == Empty_set) as AA.
      unfold Y'.
      apply (IHm Z)...
        (* *)
        unfold celldim, N, Q, setdim...
          apply In_Union in H...
          apply In_Union in H0...
          unfold sup, In at 1 in H...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Plus_Singleton x) in H.
          apply plus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
          apply In_Union in H0...
          apply In_Intersection in H...
          apply In_Union in H0...
          rewrite (Plus_Singleton x) in H.
          apply plus_dim in H. apply le_S_n. rewrite H. rewrite dimx...
        assert (sub Q (S n) == Intersection (Union (sub P (S n)) (plus x)) (Complement (minus x))) as JA.
            unfold Q.
            rewrite <- Setminus_is_Intersection_Complement...
            rewrite <- Setminus_is_Intersection_Complement...
            repeat (rewrite sub_Union || rewrite sub_Setminus|| rewrite sub_Plus ||
              rewrite sub_Minus).
            rewrite sub_Singleton...
            rewrite sub_sup_Empty_set... rewrite Empty_set_ident_left...
            rewrite sub_idemp.
            rewrite Plus_Singleton.
            rewrite Minus_Singleton...
        assert (MinusPlus Z ⊆ Intersection ((MinusPlus X) ∪ (plus x)) (Complement (minus x))) as JB.
          unfold MinusPlus.
          rewrite XZrel.
          rewrite Plus_Union.
          rewrite Minus_Union.
          rewrite Plus_Singleton.
          rewrite Minus_Singleton.
          rewrite <- Union_Complement_compat.
          unfold Included; repeat (basic; intuition).
          assert ((In (plus x) x0) \/ ~(In (plus x) x0))...
            apply Finite_are_decidable...
            apply In_Complement...
            unfold Minus, Z, In at 1 in H1.
            inversion H1 as [d SS]...
            apply In_Intersection in H3...
            unfold well_formed in Xwf...
            assert (x = d).
            refine (H7 _ _ _ n _ _ _)... unfold perp in H8...
            assert (In Empty_set x0). rewrite <- H10. apply In_Intersection... inversion H8. rewrite H8 in H6.
            apply In_Complement in H6; unfold not in H6...

      rewrite JA, JB.
        apply Intersection_Included_compat...
        apply Union_Included_compat...

 Lemma sup_Singleton_Empty_set:
  forall (y : carrier) (k : nat), k <= (dim y) → sup (Singleton y) k == Empty_set.
 Proof with intuition.
   intros...
   crush...
   inversion H1; clear H1; subst.
   assert (S (dim x) <= (dim x))...
   apply le_trans with k...
 Qed.

      assert (sup N n == sup M n) as J1.
        unfold N.
        rewrite <- Setminus_is_Intersection_Complement. 
        repeat (rewrite sup_Union || rewrite sup_Setminus || rewrite sup_idemp
           || rewrite sup_Plus || rewrite sup_Minus).
        rewrite sup_sub_Empty_set...
        rewrite sup_Singleton_Empty_set.
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set. 
        repeat (rewrite Empty_set_ident_right)...
        rewrite dimx...

      assert (sup Q n == sup P n) as J2.
        unfold Q.
        rewrite <- Setminus_is_Intersection_Complement. 
        repeat (rewrite sup_Union || rewrite sup_Setminus || rewrite sup_idemp
           || rewrite sup_Plus || rewrite sup_Minus).
        rewrite sup_sub_Empty_set...
        rewrite sup_Singleton_Empty_set.
        rewrite Plus_Empty_set, Minus_Empty_set, Setminus_Empty_set. 
        repeat (rewrite Empty_set_ident_right)...
        rewrite dimx...

      assert (Y == Y') as J3.
        unfold Y, Y', Q.
        rewrite XZrel.
        rewrite Minus_Union.
        rewrite Plus_Union.
        rewrite <- Union_Complement_compat.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left.
        rewrite sub_Intersection. rewrite sub_Union. rewrite sub_idemp. rewrite sub_Plus.
        rewrite <- Intersection_trans.
        rewrite <- Union_trans.
        rewrite I_U_dist_r.
        rewrite sub_Singleton...
        rewrite Minus_Singleton, Plus_Singleton.
        unfold Same_set, Included; repeat (basic; intuition).
        left; repeat (basic; intuition).
        left; repeat (basic; intuition).
        subsuptac... assert (S (dim x0) = dim x)... rewrite H3...
        right; repeat (basic; intuition).
        apply In_Complement... apply (H2 x0)...
        apply In_Intersection... apply (Plus_Included Z)...
        rewrite XZrel...
      fold (is_a_cell' (sup N n ∪ Y') (sup Q n ∪ Y')) in AA.
      rewrite J1, J2, <- J3 in AA...
      fold N in LA.
      fold Q in LA.

    assert (celldim (N, Q) n) as NQdim.
      unfold celldim, N, Q.
      setdimtac...
      rewrite dimx...
      rewrite dimx...
    assert (sub Q (S n) == (sub P (S n) ∪ (plus x)) ∩ √(minus x)).
      unfold Q.
        rewrite <- Minus_Singleton, <- Plus_Singleton.
        rewrite <- Setminus_is_Intersection_Complement. 
        repeat (rewrite sub_Union || rewrite sub_Setminus || rewrite sub_idemp
           || rewrite sub_Plus || rewrite sub_Minus).
        rewrite sub_sup_Empty_set...
        rewrite sub_Singleton...
    assert (Plus Z ∩ sub Q (S n) == Empty_set).
      apply (IHm Z Zcard N Q)...
      rewrite H.
      unfold MinusPlus, Z, Included; repeat (basic; intuition)...
        inversion H2; clear H2...
        assert ((In (plus x) x0) \/ ~(In (plus x) x0))...
          apply all_decidable...
          left; apply Xcond...
          unfold MinusPlus; repeat basic... exists x1...
          apply In_Complement...
          apply H3... inversion H2; clear H2...
          exists x2; repeat basic...
          apply In_Complement...
          inversion H7; clear H7...
          rewrite <- H9 in *...
          apply In_Complement...
          inversion H2...
          apply In_Intersection in H5...
          assert (x = x1)... unfold well_formed in Xwf...
          refine (H8 _ _ _ n _ _ _)...
          unfold perp in H9... assert (In (Empty_set) x0)...
          rewrite <- H11...
    assert (Disjoint (sub P (S n)) (plus x)).
      rewrite Disjoint_Intersection_condition.
      rewrite Intersection_comm.
      rewrite Plus_Singleton in LB...
    assert ((sub Q (S n) ∪ (minus x)) ∩ √(plus x) == sub P (S n)).
      rewrite H.
      rewrite U_I_dist_r.
      rewrite Full_set_property...
      rewrite Full_set_ident_right.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property...
      rewrite Empty_set_ident_right.
      assert (Included (plus x) (√(sub P (S n)))).
        apply Disjoint_property_right...
      apply Complement_Included_compat in H2...
      rewrite Complement_Complement_compat in H2...
      unfold Same_set, Included; repeat (basic; intuition)...
       apply all_decidable... apply Finite_sub... apply MPcell.
    rewrite <- H2.
    rewrite XZrel.
    rewrite Plus_Union.
    rewrite Plus_Singleton.
    rewrite <- Intersection_trans.
    rewrite I_U_dist_l.
    rewrite (I_U_dist_r (sub Q (S n))).
    rewrite (I_U_dist_r (minus x)).
    rewrite H0; clear H0.
    unfold Same_set, Included...
    exfalso; repeat (basic; intuition)...
    apply (H1 x0)... basic...
    apply (Plus_Included Z X)... rewrite XZrel...
  Qed.

    Lemma maximal_plus_lemma :
      forall S m,
        (forall y : carrier, y ∈ S → triangle_rest S m y -> m = y) ->
        m ∈ S ->
        (plus m) ⊆ (PlusMinus S).
    Proof with intuition.
      intros.
      unfold Included, PlusMinus...
      apply In_Intersection...
      exists m...
      apply In_Complement...
      inversion H2; clear H2...
      assert (m = x0)...
        apply H...
        right with x0...
        exists x...
        left...
      subst.
      intuition.
    Qed.

    Lemma minimal_plus_lemma :
      forall S m,
        (forall y : carrier, y ∈ S → triangle_rest S y m -> m = y) ->
        m ∈ S ->
        (minus m) ⊆ (MinusPlus S).
    Proof with intuition.
      intros.
      unfold Included, MinusPlus...
      apply In_Intersection...
      exists m...
      apply In_Complement...
      inversion H2; clear H2...
      assert (m = x0)...
        apply H...
        right with m...
        exists x...
        left...
      subst.
      intuition.
    Qed.

    Lemma Disjoint_result_p327 :
       forall S x n,
       Cardinal S n ->
       forall m,
       Prop_3_3_st (m) ->
       Lemma_3_2_b_st (m) 1 ->
       forall A B M P,
       is_a_cell (M, P) ->
       A == sub A (1+m) ->
       is_a_cell (sup M m ∪ A, sup P m ∪ A) ->
       is_initial_segment S (sub M (2+m)) ->
       Disjoint S (plus x) ->
       Included (plus x) (sub M (2+m)) ->
       S moves (sub M (1+m)) to A ->
       (plus x) moves A to B ->
       Disjoint (Minus S) (Plus (minus x)).
    Proof with intuition.
      intros S x n Scard m Prop_3_3 Hyp1.
      revert S Scard.
      induction n; intros S Scard A B M P MPcell Adim E E0 E1 E2 E3.
      + apply Cardinality_zero_Empty_set in Scard.
        rewrite Scard.
        constructor...
        rewrite Minus_Empty_set in H0.
        rewrite Empty_set_zero_left in H0...
      + constructor...
        rename x0 into z.
        assert (Finite S) as SFin.
          apply Cardinal_are_Finite in Scard...
        apply In_Intersection in H0...
        inversion H1 as [w [R1 R2]]; clear H1...
        inversion H2 as [v [R3 R4]]; clear H2...
        set (Z := fun y => y ∈ S /\ triangle_rest S w y).
        assert (Z ⊆ S) as ZinS.
          unfold Z, Included, In at 1...
        assert (exists m : carrier, m ∈ Z /\
            (forall y : carrier, y ∈ Z → triangle_rest Z m y -> m = y)) as Q.
          refine (maximal_exists' _ _ (1+m) _)...
          apply Finite_Included with S...
            assert (triangle_rest S w x0 ∨ (triangle_rest S w x0 → False))...
            apply triangle_rest_dec...
            left; unfold Z, In at 1...
            right; intros; apply H2...
            unfold Z, In at 1 in H1...
          exists w... unfold Z, In at 1... left...
          apply Included_trans with S...
          apply Included_trans with (sub M (2 + m))...
          apply E0...
        inversion Q as [u [uinZ umax]]; clear Q...
        set (S' := Setminus S (Singleton u)).
        set (A' := Setminus (Union A (minus u)) (plus u)).
        set (B' := Setminus (Union B (minus u)) (plus u)).
        assert (A' == sub A' (1+m)) as A'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold A' in H0. rewrite Adim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub M (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (u ∈ S) as uinS.
          unfold Z, In at 1 in uinZ...
        assert (Included S' S) as Q0.
          unfold S', Included; repeat (basic; intuition)...
        assert ((plus u) ⊆ (PlusMinus S)).
          unfold Included, PlusMinus; repeat (basic; intuition).
          exists u...
          apply In_Complement...
          inversion H2...
          assert (less u x1)... exists x0...
          assert (u = x1)...
          apply umax...
          unfold Z, In at 1...
          apply triangle_rest_equiv.
          right with u...
          apply triangle_rest_equiv.
          apply uinZ.
          apply triangle_rest_equiv.
          right with u...
          unfold Z, In at 1...
          apply triangle_rest_equiv.
          right with u...
          apply triangle_rest_equiv.
          apply uinZ.
          left...
          rewrite H6 in H1...
        assert (Finite S') as S'Fin.
          apply Finite_Included with S...
          assert ((x0 = u) \/ ~(x0 = u))...
            apply carrier_decidable_eq.
          right; unfold S'...
          repeat (basic; intuition).
          left; unfold S'...
          repeat (basic; intuition).
          inversion H4...
        assert (S' ∪ Singleton u == S) as Q3.
          unfold S'. apply Union_Setminus_cancel...
          apply Singleton_Included...
        assert (S' moves (sub M (1 + m)) to A') as Q.
          unfold S', A'.
          rewrite <- Minus_Singleton.
          rewrite <- Plus_Singleton.
          pose (Prop_2_4_exact S' (Singleton u) (sub M (1 + m)) A). clear a.
          assert ((S' moves (sub M (1 + m)) to ((sub M (1 + m)) ∪ Plus S') ∩ √Minus S')
              ∧ (Singleton u
                 moves (A ∪ Minus (Singleton u)) ∩ √Plus (Singleton u) to A)
                ∧ (A ∪ Minus (Singleton u)) ∩ √Plus (Singleton u) ==
                  ((sub M (1 + m)) ∪ Plus S') ∩ √Minus S') as [F [FF FFF]].
          apply Prop_2_4_exact...
          rewrite Q3...
          apply Included_trans with (PlusMinus S)...
            rewrite PlusMinus_Singleton...
            apply Prop_2_1_dual...
            exists (sub M (1 + m))...
          apply Observation_p322...
            rewrite Q3...
            apply well_formed_Included with (sub M (2 + m))...
             apply well_formed_sub... apply MPcell.
             apply E0.
            unfold S'; constructor; repeat (basic; intuition)...
          repeat (rewrite Setminus_is_Intersection_Complement).
          rewrite FFF.
          rewrite <- Setminus_is_Intersection_Complement.
          apply F.
        assert (plus x moves A' to B') as Q1.
          unfold A', B'.
          rewrite <- Minus_Singleton. rewrite <- Plus_Singleton.
          repeat (rewrite Setminus_is_Intersection_Complement).
          apply Prop_2_2...
          rewrite Plus_Singleton...
          apply Included_trans with (PlusMinus S)...
          apply Prop_2_1_dual... exists (sub M (1 + m))...
          rewrite Plus_Singleton.
          apply Disjoint_impl_mor with (Minus (plus x)) (plus u); unfold Basics.flip...
          unfold MinusPlus...
          apply Intersection_Included_cancel_right...
          apply Disjoint_sym.
          apply Disjoint_Intersection_condition.
          apply Prop_1_2_dual with v...
          right with w... exists z...
          apply (rest_implies_full S).
          apply uinZ.
          rewrite Minus_Singleton.
          (* S is initial, and disjoint from (plus x) *)
          rewrite Plus_Singleton.
          constructor...
          apply In_Intersection in H1...
          inversion H3; clear H3...
          assert (less x1 u)... exists x0...
          assert (x1 ∈ S)...
            unfold is_initial_segment in E0...
            apply H6 with u...
            right with u...
            left...
          apply E1 with x1...
          (* S and plus x are in M, M is well_formed *)
          apply Disjoint_Minus with (sub M (2+m))...
          apply Disjoint_impl_mor with S (plus x)...
          unfold Basics.flip... unfold Included... inversion H1... rewrite <- H2...
          unfold Basics.flip... rewrite Plus_Singleton...
          apply Included_trans with S... apply Singleton_Included...
          apply E0.
          rewrite Plus_Singleton...
          apply well_formed_sub; apply MPcell...
      assert (is_a_cell ((sup M m) ∪ A', (sup P m) ∪ A')) as Q4.
        unfold A'.
        set (AM := sup M m ∪ sub A (1+m)).
        set (AP := sup P m ∪ sub A (1+m)).
        assert (is_a_cell (AM, AP)).
          unfold AM, AP.
          apply (Same_set_is_a_cell _ _ E);
          rewrite <- Adim; reflexivity.
        apply Same_set_is_a_cell with (sup AM m ∪ ((sub AM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))) (sup AP m ∪ ((sub AM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))).
        unfold Lemma_3_2_b_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, AM, AP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub M (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite PlusMinus_Singleton.
          unfold AM.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left.
          rewrite <- Adim...
          apply Included_trans with (PlusMinus S)...
          apply Prop_2_1_dual... exists (sub M (1+m))...
          unfold lt...
        unfold AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
        unfold AP, AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
      assert (Disjoint (Minus S') (Plus (minus x))).
        apply IHn with A' B' M P...
        unfold S'.
          rewrite pred_Sn.
          apply (Cardinal_Setminus)...
        unfold S'.
          apply initial_final_lemma...
          unfold is_final_segment...
          apply Singleton_Included...
          apply Constructive_sets.Singleton_intro.
          apply umax...
          inversion H2; clear H2.
          symmetry in H3; subst.
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
          inversion H2; clear H2. symmetry in H3; subst.
          apply segment_lemma with S...
          apply final_segment_is_a_segment.
          apply ge_final_segment...
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
        apply Disjoint_impl_mor with S (plus x)...
      assert (Disjoint (minus u) (Plus (minus x))).
        apply Disjoint_impl_mor with A' (Plus (minus x)); unfold Basics.flip...
        unfold A'...
        apply Prop_2_1...
        exists B'...
        apply Prop_3_1...
        assert (receptive (sup M m ∪ A') ∧ receptive (sup P m ∪ A')).
        apply Prop_3_3...
        unfold celldim. rewrite A'dim. simpl. unfold setdim; repeat (basic; intuition)... 
        apply le_trans with (1+ (dim x0))...
        assert ((dim x0) = m); simpl in H1... subst...
        apply le_trans with (1+ (dim x0))...
        assert ((dim x0) = m); simpl in H1... subst...
        intuition.
        apply receptive_by_dimension  with (n:= 1+m) in H3.
        rewrite sub_Union, sub_sup_Empty_set, Empty_set_ident_left in H3...
        rewrite <- A'dim in H3...
      assert ((w=u) \/ ~(w=u))...
        apply carrier_decidable_eq.
      - apply H2 with z...
        apply In_Intersection...
        rewrite <- H4...
        exists v...
      - apply H1 with z...
        apply In_Intersection...
        exists w... unfold S', In at 1... unfold Setminus... inversion H3...
        exists v...
    Qed.

    Lemma Disjoint_result_p327_dual :
       forall S x n,
       Cardinal S n ->
       forall m,
       Prop_3_3_st (m) ->
       Lemma_3_2_b_st (m) 1 ->
       forall A B M P,
       is_a_cell (M, P) ->
       A == sub A (1+m) ->
       B == sub B (1+m) ->
       is_a_cell (sup M m ∪ A, sup P m ∪ A) ->
       is_a_cell (sup M m ∪ B, sup P m ∪ B) ->
       is_initial_segment S (sub P (2+m)) ->
       Disjoint S (minus x) ->
       Included (minus x) (sub P (2+m)) ->
       S moves (sub M (1+m)) to A ->
       (minus x) moves A to B ->
       Disjoint (Minus S) (Plus (plus x)).
    Proof with intuition.
      intros S x n Scard m Prop_3_3 Hyp1.
      revert S Scard.
      induction n; intros S Scard A B M P MPcell Adim Bdim E E' E0 E1 E2 E3.
      + apply Cardinality_zero_Empty_set in Scard.
        rewrite Scard.
        constructor...
        rewrite Minus_Empty_set in H0.
        rewrite Empty_set_zero_left in H0...
      + constructor...
        rename x0 into z.
        assert (Finite S) as SFin.
          apply Cardinal_are_Finite in Scard...
        apply In_Intersection in H0...
        inversion H1 as [w [R1 R2]]; clear H1...
        inversion H2 as [v [R3 R4]]; clear H2...
        set (Z := fun y => y ∈ S /\ triangle_rest S w y).
        assert (Z ⊆ S) as ZinS.
          unfold Z, Included, In at 1...
        assert (exists m : carrier, m ∈ Z /\
            (forall y : carrier, y ∈ Z → triangle_rest Z m y -> m = y)) as Q.
          refine (maximal_exists' _ _ (1+m) _)...
          apply Finite_Included with S...
            assert (triangle_rest S w x0 ∨ (triangle_rest S w x0 → False))...
            apply triangle_rest_dec...
            left; unfold Z, In at 1...
            right; intros; apply H2...
            unfold Z, In at 1 in H1...
          exists w... unfold Z, In at 1... left...
          apply Included_trans with S...
          apply Included_trans with (sub P (2 + m))...
          apply E0...
        inversion Q as [u [uinZ umax]]; clear Q...
        set (S' := Setminus S (Singleton u)).
        set (A' := Setminus (Union A (minus u)) (plus u)).
        set (B' := Setminus (Union B (minus u)) (plus u)).
        assert (A' == sub A' (1+m)) as A'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold A' in H0. rewrite Adim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub P (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (B' == sub B' (1+m)) as B'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold B' in H0. rewrite Bdim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub P (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (u ∈ S) as uinS.
          unfold Z, In at 1 in uinZ...
        assert (Included S' S) as Q0.
          unfold S', Included; repeat (basic; intuition)...
        assert ((plus u) ⊆ (PlusMinus S)).
          unfold Included, PlusMinus; repeat (basic; intuition).
          exists u...
          apply In_Complement...
          inversion H2...
          assert (less u x1)... exists x0...
          assert (u = x1)...
          apply umax...
          unfold Z, In at 1...
          apply triangle_rest_equiv.
          right with u...
          apply triangle_rest_equiv.
          apply uinZ.
          apply triangle_rest_equiv.
          right with u...
          unfold Z, In at 1...
          apply triangle_rest_equiv.
          right with u...
          apply triangle_rest_equiv.
          apply uinZ.
          left...
          rewrite H6 in H1...
        assert (Finite S') as S'Fin.
          apply Finite_Included with S...
          assert ((x0 = u) \/ ~(x0 = u))...
            apply carrier_decidable_eq.
          right; unfold S'...
          repeat (basic; intuition).
          left; unfold S'...
          repeat (basic; intuition).
          inversion H4...
        assert (S' ∪ Singleton u == S) as Q3.
          unfold S'. apply Union_Setminus_cancel...
          apply Singleton_Included...
        assert (S' moves (sub M (1 + m)) to A') as Q.
          unfold S', A'.
          rewrite <- Minus_Singleton.
          rewrite <- Plus_Singleton.
          pose (Prop_2_4_exact S' (Singleton u) (sub M (1 + m)) A). clear a.
          assert ((S' moves (sub M (1 + m)) to ((sub M (1 + m)) ∪ Plus S') ∩ √Minus S')
              ∧ (Singleton u
                 moves (A ∪ Minus (Singleton u)) ∩ √Plus (Singleton u) to A)
                ∧ (A ∪ Minus (Singleton u)) ∩ √Plus (Singleton u) ==
                  ((sub M (1 + m)) ∪ Plus S') ∩ √Minus S') as [F [FF FFF]].
          apply Prop_2_4_exact...
          rewrite Q3...
          apply Included_trans with (PlusMinus S)...
            rewrite PlusMinus_Singleton...
            apply Prop_2_1_dual...
            exists (sub M (1 + m))...
          apply Observation_p322...
            rewrite Q3...
            apply well_formed_Included with (sub P (2 + m))...
             apply well_formed_sub... apply MPcell.
             apply E0.
            unfold S'; constructor; repeat (basic; intuition)...
          repeat (rewrite Setminus_is_Intersection_Complement).
          rewrite FFF.
          rewrite <- Setminus_is_Intersection_Complement.
          apply F.
        assert (minus x moves A' to B') as Q1.
          unfold A', B'.
          rewrite <- Minus_Singleton. rewrite <- Plus_Singleton.
          repeat (rewrite Setminus_is_Intersection_Complement).
          apply Prop_2_2...
          rewrite Minus_Singleton...
          apply Included_trans with (PlusMinus S)... rewrite Plus_Singleton...
          apply Prop_2_1_dual... exists (sub M (1 + m))...
          rewrite Plus_Singleton, Minus_Singleton.
          apply Disjoint_impl_mor with (Minus (minus x)) (plus u); unfold Basics.flip...
          unfold MinusPlus...
          apply Intersection_Included_cancel_right...
          apply Disjoint_sym.
          apply Disjoint_Intersection_condition.
          apply Prop_1_2_dual' with v...
          right with w... exists z...
          apply (rest_implies_full S).
          apply uinZ.
          (* S is initial, and disjoint from (minus x) *)
          rewrite Minus_Singleton.
          constructor...
          apply In_Intersection in H1...
          inversion H3; clear H3...
          assert (less x1 u)... exists x0...
          assert (x1 ∈ S)...
            unfold is_initial_segment in E0...
            apply H6 with u...
            right with u...
            left...
          apply E1 with x1...
          (* S and plus x are in M, M is well_formed *)
          rewrite <- Minus_Singleton.
          apply Disjoint_Minus with (sub P (2+m))...
          apply Disjoint_impl_mor with S (minus x)...
          unfold Basics.flip... unfold Included... inversion H1... rewrite <- H2...
          unfold Basics.flip... rewrite Minus_Singleton...
          apply Included_trans with S... apply Singleton_Included...
          apply E0.
          rewrite Minus_Singleton...
          apply well_formed_sub; apply MPcell...
      assert (is_a_cell ((sup M m) ∪ A', (sup P m) ∪ A')) as Q4.
        unfold A'.
        set (AM := sup M m ∪ sub A (1+m)).
        set (AP := sup P m ∪ sub A (1+m)).
        assert (is_a_cell (AM, AP)).
          unfold AM, AP.
          apply (Same_set_is_a_cell _ _ E);
          rewrite <- Adim; reflexivity.
        apply Same_set_is_a_cell with (sup AM m ∪ ((sub AM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))) (sup AP m ∪ ((sub AM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))).
        unfold Lemma_3_2_b_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, AM, AP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub P (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite PlusMinus_Singleton.
          unfold AM.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left.
          rewrite <- Adim...
          apply Included_trans with (PlusMinus S)...
          apply Prop_2_1_dual... exists (sub M (1+m))...
          unfold lt...
        unfold AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
        unfold AP, AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
      assert (is_a_cell ((sup M m) ∪ B', (sup P m) ∪ B')) as Q6.
        unfold B'. 
        set (BM := sup M m ∪ sub B (1+m)).
        set (BP := sup P m ∪ sub B (1+m)).
        assert (is_a_cell (BM, BP)).
          unfold BM, BP.
          apply (Same_set_is_a_cell _ _ E'); 
            rewrite <- Bdim...
        unfold Lemma_3_2_b_st in Hyp1.
        apply Same_set_is_a_cell with (sup BM m ∪ ((sub BM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))) (sup BP m ∪ ((sub BM (1+m) ∪ Minus (Singleton u)) ∩ √(Plus (Singleton u)))).
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, BM, BP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H4...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub P (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite PlusMinus_Singleton.
          unfold BM.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left...
          rewrite <- Bdim... 
          unfold moves_def in H...
          rewrite H2; unfold Included...
          repeat (basic; intuition). left.
          cut ((PlusMinus S) ⊆ A)...
            apply Prop_2_1_dual... exists (sub M (1 + m))...
          apply In_Complement...
          assert (plus u ∩ Minus (minus x) == Empty_set).
            apply Prop_1_2_dual' with v...
            apply clos_rt_rt1n_iff;
            apply rt_trans with w;
            apply clos_rt_rt1n_iff...
            right with w... exists z... left...
            apply rest_implies_full with S...
            apply uinZ...
          assert (In Empty_set x0)... rewrite <- H6...
        unfold BP, BM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
        unfold BP, BM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
      assert (Disjoint (Minus S') (Plus (plus x))).
        apply IHn with A' B' M P...
        unfold S'.
          rewrite pred_Sn.
          apply (Cardinal_Setminus)...
        unfold S'.
          apply initial_final_lemma...
          unfold is_final_segment...
          apply Singleton_Included...
          apply Constructive_sets.Singleton_intro.
          apply umax...
          inversion H2; clear H2.
          symmetry in H3; subst.
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
          inversion H2; clear H2. symmetry in H3; subst.
          apply segment_lemma with S...
          apply final_segment_is_a_segment.
          apply ge_final_segment...
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
        apply Disjoint_impl_mor with S (minus x)...
      assert (Disjoint (minus u) (Plus (plus x))).
        apply Disjoint_impl_mor with A' (Plus (plus x)); unfold Basics.flip...
        unfold A'...
        apply Prop_2_1...
        exists B'...
        apply Prop_3_1_dual...
        assert (receptive (sup M m ∪ B') ∧ receptive (sup P m ∪ B')).
        apply Prop_3_3...
        simpl.
        unfold celldim. rewrite B'dim. simpl. unfold setdim; repeat (basic; intuition)... 
        apply le_trans with (1+ (dim x0))...
        assert ((dim x0) = m); simpl in H1... subst. apply le_refl.
        apply le_trans with (1+ (dim x0))...
        assert ((dim x0) = m); simpl in H1... subst. apply le_refl.
        intuition.
        apply receptive_by_dimension  with (n:= 1+m) in H3.
        rewrite sub_Union, sub_sup_Empty_set, Empty_set_ident_left in H3...
        rewrite <- B'dim in H3...
      assert ((w=u) \/ ~(w=u))...
        apply carrier_decidable_eq.
      - apply H2 with z...
        apply In_Intersection...
        rewrite <- H4...
        exists v...
      - apply H1 with z...
        apply In_Intersection...
        exists w... unfold S', In at 1... unfold Setminus... inversion H3...
        exists v...
    Qed.

    Lemma Disjoint_result_p327' :
       forall T x n,
       Cardinal T n ->
       forall m,
       Prop_3_3_st (m)->
       Lemma_3_2_b_dual_st (m) 1 ->
       forall A B M P,
       is_a_cell (M, P) ->
       A == sub A (1+m) ->
       B == sub B (1+m) ->
       is_a_cell (sup M m ∪ A, sup P m ∪ A) ->
       is_a_cell (sup M m ∪ B, sup P m ∪ B) ->
       is_final_segment T (sub M (2+m)) ->
       Disjoint T (plus x) ->
       Included (plus x) (sub M (2+m)) ->
       T moves B to (sub P (1+m)) ->
       (plus x) moves A to B ->
       Disjoint (Plus T) (Minus (minus x)).
    Proof with intuition.
      intros T x n Tcard m Prop_3_3 Hyp1.
      revert T Tcard.
      induction n; intros T Tcard A B M P MPcell Adim Bdim D E E0 E1 E2 E3.
      + apply Cardinality_zero_Empty_set in Tcard.
        rewrite Tcard.
        constructor...
        rewrite Plus_Empty_set in H0.
        rewrite Empty_set_zero_left in H0...
      + constructor...
        rename x0 into z.
        assert (Finite T) as TFin.
          apply Cardinal_are_Finite in Tcard...
        apply In_Intersection in H0...
        inversion H1 as [w [R1 R2]]; clear H1...
        inversion H2 as [v [R3 R4]]; clear H2...
        set (Z := fun y => y ∈ T /\ triangle_rest T y w).
        assert (Z ⊆ T) as ZinT.
          unfold Z, Included, In at 1...
        assert (exists m : carrier, m ∈ Z /\
            (forall y : carrier, y ∈ Z → triangle_rest Z y m -> m = y)) as Q.
          refine (minimal_exists' _ _ (1+m) _)...
          apply Finite_Included with T...
            assert (triangle_rest T x0 w ∨ (triangle_rest T x0 w → False))...
            apply triangle_rest_dec...
            left; unfold Z, In at 1...
            right; intros; apply H2...
            unfold Z, In at 1 in H1...
          exists w... unfold Z, In at 1... left...
          apply Included_trans with T...
          apply Included_trans with (sub M (2 + m))...
          apply E0...
        inversion Q as [u [uinZ umax]]; clear Q...
        set (T' := Setminus T (Singleton u)).
        set (B' := Setminus (Union B (plus u)) (minus u)).
        set (A' := Setminus (Union A (plus u)) (minus u)).
        assert (B' == sub B' (1+m)) as B'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold B' in H0. rewrite Bdim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub M (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (A' == sub A' (1+m)) as A'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold A' in H0. rewrite Adim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub M (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (u ∈ T) as uinT.
          unfold Z, In at 1 in uinZ...
        assert (Included T' T) as Q0.
          unfold T', Included; repeat (basic; intuition)...
        assert ((minus u) ⊆ (MinusPlus T)).
          unfold Included, MinusPlus; repeat (basic; intuition).
          exists u...
          apply In_Complement...
          inversion H2...
          assert (less x1 u)... exists x0...
          assert (u = x1)...
          apply umax...
          unfold Z, In at 1...
          right with u...
          apply uinZ.
          right with u...
          unfold Z, In at 1...
          right with u...
          apply uinZ.
          left...
          rewrite H6 in H1...
        assert (Finite T') as T'Fin.
          apply Finite_Included with T...
          assert ((x0 = u) \/ ~(x0 = u))...
            apply carrier_decidable_eq.
          right; unfold T'...
          repeat (basic; intuition).
          left; unfold T'...
          repeat (basic; intuition).
          inversion H4...
        assert (T' ∪ Singleton u == T) as Q3.
          unfold T'. apply Union_Setminus_cancel...
          apply Singleton_Included...
        assert (T' moves B' to (sub P (1 + m))) as Q.
          unfold T', B'.
          rewrite <- Minus_Singleton.
          rewrite <- Plus_Singleton.
          pose (Prop_2_4_dual_exact (Singleton u) T' B (sub P (1 + m))). clear a.
          assert ((Singleton u moves B
               to (B ∪ Plus (Singleton u)) ∩ √Minus (Singleton u))
              ∧ (T' moves (sub P (1 + m) ∪ Minus T') ∩ √Plus T'
                 to sub P (1 + m))
                ∧ (sub P (1 + m) ∪ Minus T') ∩ √Plus T' ==
                  (B ∪ Plus (Singleton u)) ∩ √Minus (Singleton u)) as [F [FF FFF]].
          apply Prop_2_4_dual_exact...
          rewrite Union_comm. rewrite Q3...
          apply Included_trans with (MinusPlus T)...
            rewrite MinusPlus_Singleton...
            apply Prop_2_1...
            exists (sub P (1 + m))...
          apply Observation_p322...
            rewrite Union_comm in Q3.
            rewrite Q3...
            apply well_formed_Included with (sub M (2 + m))...
             apply well_formed_sub... apply MPcell.
             apply E0.
            unfold T'; constructor; repeat (basic; intuition)...
          repeat (rewrite Setminus_is_Intersection_Complement).
          rewrite <- FFF.
          rewrite <- Setminus_is_Intersection_Complement.
          apply FF.
        assert (Disjoint (minus u) (Plus (plus x))) as EMEM.
          apply Disjoint_Intersection_condition.
          apply (Prop_1_2' _ v)...
           apply clos_rt_rt1n_iff.
           apply rt_trans with w.
           apply clos_rt_rt1n_iff.
           apply rest_implies_full with T...
             unfold Z, In at 1 in uinZ...
           apply rt_step. exists z...
        assert (plus x moves A' to B') as Q1.
          unfold A', B'.
          rewrite Setminus_is_Intersection_Complement.
          rewrite Setminus_is_Intersection_Complement.
          apply Prop_2_2_dual...
          apply Included_trans with (MinusPlus T)...
          apply Prop_2_1... exists (sub P (1 + m))...
          assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as KK.
            apply Prop_1_1.
          rewrite <- KK.
          apply Disjoint_sym.
          revert EMEM.
          apply Disjoint_impl_mor...
          unfold Basics.flip.
          unfold Included; repeat (basic; intuition).
          (* *)
          rewrite <- Plus_Singleton.
          apply Disjoint_Plus with (sub M (2+m))...
          apply Disjoint_impl_mor with T (plus x)...
          unfold Basics.flip... apply Singleton_Included...
          apply Included_trans with T... apply Singleton_Included...
          apply E0.
          apply well_formed_sub; apply MPcell...
          (* *)
          constructor...
            apply In_Intersection in H1...
             inversion H3; clear H3...
             assert (less u x1).
               exists x0...
             refine (final_property _ (plus x) _ E0 _ _ _ _ _ _ H1)...
             apply Disjoint_sym...
      assert (is_a_cell ((sup M m) ∪ B', (sup P m) ∪ B')) as Q4.
        unfold B'.
        set (BM := sup M m ∪ sub B (1+m)).
        set (BP := sup P m ∪ sub B (1+m)).
        assert (is_a_cell (BM, BP)).
          unfold BM, BP.
          apply (Same_set_is_a_cell _ _ E);
          rewrite <- Bdim; reflexivity.
        apply Same_set_is_a_cell with (sup BM m ∪ ((sub BP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))) (sup BP m ∪ ((sub BP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))).
        unfold Lemma_3_2_b_dual_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, BM, BP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub M (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite MinusPlus_Singleton.
          unfold BP.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left.
          rewrite <- Bdim...
          apply Included_trans with (MinusPlus T)...
          apply Prop_2_1... exists (sub P (1+m))...
          unfold lt...
        unfold BM, BP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
        unfold BP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
      assert (is_a_cell ((sup M m) ∪ A', (sup P m) ∪ A')) as Q6.
        unfold A'. 
        set (AM := sup M m ∪ sub A (1+m)).
        set (AP := sup P m ∪ sub A (1+m)).
        assert (is_a_cell (AM, AP)).
          unfold AM, AP.
          apply (Same_set_is_a_cell _ _ D); 
            rewrite <- Adim...
        apply Same_set_is_a_cell with (sup AM m ∪ ((sub AP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))) (sup AP m ∪ ((sub AP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))).
        unfold Lemma_3_2_b_dual_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, AM, AP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub M (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite MinusPlus_Singleton.
          unfold AP.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left...
          rewrite <- Adim... 
          assert (minus u ∩ Plus (plus x) == Empty_set).
            apply Disjoint_Intersection_condition in EMEM... 
          unfold moves_def in H...
          rewrite H4...
          unfold Included; repeat (basic; intuition)...
          left...
          cut ((MinusPlus T) ⊆ B)...
            apply Prop_2_1... exists (sub P (1 + m))...
          apply In_Complement...
          apply H with x0...
        unfold AP, AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
        unfold AP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
      assert (Disjoint (Plus T') (Minus (minus x))) as Q2.
        apply IHn with A' B' M P...
        unfold T'.
          rewrite pred_Sn.
          apply (Cardinal_Setminus)...
        unfold T'.
          apply final_initial_lemma...
          unfold is_initial_segment...
          apply Singleton_Included...
          apply Constructive_sets.Singleton_intro.
          apply umax...
          inversion H2; clear H2.
          symmetry in H3; subst.
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
          inversion H2; clear H2. symmetry in H3; subst.
          apply segment_lemma with T...
          apply initial_segment_is_a_segment.
          apply le_initial_segment...
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
        apply Disjoint_impl_mor with T (plus x)...
      assert (Disjoint (plus u) (Minus (minus x))) as Q5.
        apply Disjoint_impl_mor with B' (Minus (minus x)); unfold Basics.flip...
        unfold B'...
        apply Prop_2_1_dual...
        exists A'...
        apply Prop_3_1...
        assert (receptive (sup M m ∪ A') ∧ receptive (sup P m ∪ A')).
          apply Prop_3_3...
          unfold celldim. rewrite A'dim. unfold setdim; repeat (basic; intuition).
          apply le_trans with (1+ (dim x0))...
          assert ((dim x0) = m); simpl in H2... subst. apply le_refl.
          apply le_trans with (1+ (dim x0))...
          assert ((dim x0) = m); simpl in H2... subst... 
        intuition.
        apply receptive_by_dimension  with (n:= 1+m) in H2.
        rewrite sub_Union, sub_sup_Empty_set, Empty_set_ident_left in H2...
        rewrite <- A'dim in H2...
      assert ((w=u) \/ ~(w=u))...
        apply carrier_decidable_eq.
      - apply Q5 with z...
        apply In_Intersection...
        rewrite <- H2...
        exists v...
      - apply Q2 with z...
        apply In_Intersection...
        exists w... unfold T', In at 1... unfold Setminus... inversion H1...
        exists v...
    Qed.

    Lemma Disjoint_result_p327_dual' :
       forall T x n,
       Cardinal T n ->
       forall m,
       Prop_3_3_st (m)->
       Lemma_3_2_b_dual_st (m) 1 ->
       forall A B M P,
       is_a_cell (M, P) ->
       A == sub A (1+m) ->
       B == sub B (1+m) ->
       is_a_cell (sup M m ∪ A, sup P m ∪ A) ->
       is_a_cell (sup M m ∪ B, sup P m ∪ B) ->
       is_final_segment T (sub P (2+m)) ->
       Disjoint T (minus x) ->
       Included (minus x) (sub P (2+m)) ->
       T moves B to (sub P (1+m)) ->
       (minus x) moves A to B ->
       Disjoint (Plus T) (Minus (plus x)).
    Proof with intuition.
      intros T x n Tcard m Prop_3_3 Hyp1.
      revert T Tcard.
      induction n; intros T Tcard A B M P MPcell Adim Bdim D E E0 E1 E2 E3.
      + apply Cardinality_zero_Empty_set in Tcard.
        rewrite Tcard.
        constructor...
        rewrite Plus_Empty_set in H0.
        rewrite Empty_set_zero_left in H0...
      + constructor...
        rename x0 into z.
        assert (Finite T) as TFin.
          apply Cardinal_are_Finite in Tcard...
        apply In_Intersection in H0...
        inversion H1 as [w [R1 R2]]; clear H1...
        inversion H2 as [v [R3 R4]]; clear H2...
        set (Z := fun y => y ∈ T /\ triangle_rest T y w).
        assert (Z ⊆ T) as ZinT.
          unfold Z, Included, In at 1...
        assert (exists m : carrier, m ∈ Z /\
            (forall y : carrier, y ∈ Z → triangle_rest Z y m -> m = y)) as Q.
          refine (minimal_exists' _ _ (1+m) _)...
          apply Finite_Included with T...
            assert (triangle_rest T x0 w ∨ (triangle_rest T x0 w → False))...
            apply triangle_rest_dec...
            left; unfold Z, In at 1...
            right; intros; apply H2...
            unfold Z, In at 1 in H1...
          exists w... unfold Z, In at 1... left...
          apply Included_trans with T...
          apply Included_trans with (sub P (2 + m))...
          apply E0...
        inversion Q as [u [uinZ umax]]; clear Q...
        set (T' := Setminus T (Singleton u)).
        set (B' := Setminus (Union B (plus u)) (minus u)).
        set (A' := Setminus (Union A (plus u)) (minus u)).
        assert (B' == sub B' (1+m)) as B'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold B' in H0. rewrite Bdim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub P (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (A' == sub A' (1+m)) as A'dim.
          unfold Same_set, Included...
          unfold sub, In at 1...
          unfold A' in H0. rewrite Adim in H0.
          repeat (basic; intuition).
          assert (Datatypes.S (dim x0) = dim u)... rewrite H2.
          assert (In (sub P (2+m)) u)...
          apply E0. apply uinZ. simpl in H4...
        assert (u ∈ T) as uinT.
          unfold Z, In at 1 in uinZ...
        assert (Included T' T) as Q0.
          unfold T', Included; repeat (basic; intuition)...
        assert ((minus u) ⊆ (MinusPlus T)).
          unfold Included, MinusPlus; repeat (basic; intuition).
          exists u...
          apply In_Complement...
          inversion H2...
          assert (less x1 u)... exists x0...
          assert (u = x1)...
          apply umax...
          unfold Z, In at 1...
          right with u...
          apply uinZ.
          right with u...
          unfold Z, In at 1...
          right with u...
          apply uinZ.
          left...
          rewrite H6 in H1...
        assert (Finite T') as T'Fin.
          apply Finite_Included with T...
          assert ((x0 = u) \/ ~(x0 = u))...
            apply carrier_decidable_eq.
          right; unfold T'...
          repeat (basic; intuition).
          left; unfold T'...
          repeat (basic; intuition).
          inversion H4...
        assert (T' ∪ Singleton u == T) as Q3.
          unfold T'. apply Union_Setminus_cancel...
          apply Singleton_Included...
        assert (T' moves B' to (sub P (1 + m))) as Q.
          unfold T', B'.
          rewrite <- Minus_Singleton.
          rewrite <- Plus_Singleton.
          pose (Prop_2_4_dual_exact (Singleton u) T' B (sub P (1 + m))). clear a.
          assert ((Singleton u moves B
               to (B ∪ Plus (Singleton u)) ∩ √Minus (Singleton u))
              ∧ (T' moves (sub P (1 + m) ∪ Minus T') ∩ √Plus T'
                 to sub P (1 + m))
                ∧ (sub P (1 + m) ∪ Minus T') ∩ √Plus T' ==
                  (B ∪ Plus (Singleton u)) ∩ √Minus (Singleton u)) as [F [FF FFF]].
          apply Prop_2_4_dual_exact...
          rewrite Union_comm. rewrite Q3...
          apply Included_trans with (MinusPlus T)...
            rewrite MinusPlus_Singleton...
            apply Prop_2_1...
            exists (sub P (1 + m))...
          apply Observation_p322...
            rewrite Union_comm in Q3.
            rewrite Q3...
            apply well_formed_Included with (sub P (2 + m))...
             apply well_formed_sub... apply MPcell.
             apply E0.
            unfold T'; constructor; repeat (basic; intuition)...
          repeat (rewrite Setminus_is_Intersection_Complement).
          rewrite <- FFF.
          rewrite <- Setminus_is_Intersection_Complement.
          apply FF.
        assert (Disjoint (minus u) (Plus (minus x))) as EMEM.
          apply Disjoint_Intersection_condition.
          apply (Prop_1_2 _ v)...
           apply clos_rt_rt1n_iff.
           apply rt_trans with w.
           apply clos_rt_rt1n_iff.
           apply rest_implies_full with T...
             unfold Z, In at 1 in uinZ...
           apply rt_step. exists z...
        assert (minus x moves A' to B') as Q1.
          unfold A', B'.
          rewrite Setminus_is_Intersection_Complement.
          rewrite Setminus_is_Intersection_Complement.
          apply Prop_2_2_dual...
          apply Included_trans with (MinusPlus T)...
          apply Prop_2_1... exists (sub P (1 + m))...
          assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (minus x)) as KK.
            symmetry. apply Prop_1_1.
          rewrite <- KK.
          apply Disjoint_sym.
          revert EMEM.
          apply Disjoint_impl_mor...
          unfold Basics.flip.
          unfold Included; repeat (basic; intuition).
          (* *)
          rewrite <- Plus_Singleton.
          apply Disjoint_Plus with (sub P (2+m))...
          apply Disjoint_impl_mor with T (minus x)...
          unfold Basics.flip... apply Singleton_Included...
          apply Included_trans with T... apply Singleton_Included...
          apply E0.
          apply well_formed_sub; apply MPcell...
          (* *)
          constructor...
            apply In_Intersection in H1...
             inversion H3; clear H3...
             assert (less u x1).
               exists x0...
             refine (final_property _ (minus x) _ E0 _ _ _ _ _ _ H1)...
             apply Disjoint_sym...
      assert (is_a_cell ((sup M m) ∪ B', (sup P m) ∪ B')) as Q4.
        unfold B'.
        set (BM := sup M m ∪ sub B (1+m)).
        set (BP := sup P m ∪ sub B (1+m)).
        assert (is_a_cell (BM, BP)).
          unfold BM, BP.
          apply (Same_set_is_a_cell _ _ E);
          rewrite <- Bdim; reflexivity.
        apply Same_set_is_a_cell with (sup BM m ∪ ((sub BP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))) (sup BP m ∪ ((sub BP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))).
        unfold Lemma_3_2_b_dual_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, BM, BP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub P (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite MinusPlus_Singleton.
          unfold BP.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left.
          rewrite <- Bdim...
          apply Included_trans with (MinusPlus T)...
          apply Prop_2_1... exists (sub P (1+m))...
          unfold lt...
        unfold BM, BP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
        unfold BP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Bdim...
      assert (is_a_cell ((sup M m) ∪ A', (sup P m) ∪ A')) as Q6.
        unfold A'. 
        set (AM := sup M m ∪ sub A (1+m)).
        set (AP := sup P m ∪ sub A (1+m)).
        assert (is_a_cell (AM, AP)).
          unfold AM, AP.
          apply (Same_set_is_a_cell _ _ D); 
            rewrite <- Adim...
        apply Same_set_is_a_cell with (sup AM m ∪ ((sub AP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))) (sup AP m ∪ ((sub AP (1+m) ∪ Plus (Singleton u)) ∩ √(Minus (Singleton u)))).
        unfold Lemma_3_2_b_dual_st in Hyp1.
        apply Hyp1...
        apply Cardinality_Singleton_is_one.
        unfold celldim, setdim, AM, AP; intros; repeat (basic; intuition).
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
          assert (1+(dim x0) <= m)...
          simpl in H2...
          assert (dim x0 = m)... rewrite H5...
        unfold Included...
        unfold sub, In at 1...
        inversion H2; clear H2. rewrite <- H3; clear H3 x0.
        assert (dim u = Datatypes.S m)...
        assert (In (sub P (2+m)) u)...
        apply E0. apply uinZ.
        simpl in H2...
        rewrite MinusPlus_Singleton.
          unfold AP.
          rewrite sub_Union.
          rewrite sub_sup_Empty_set, sub_idemp, Empty_set_ident_left...
          rewrite <- Adim... 
          assert (minus u ∩ Plus (minus x) == Empty_set).
            apply Disjoint_Intersection_condition in EMEM... 
          unfold moves_def in H...
          rewrite H4...
          unfold Included; repeat (basic; intuition)...
          left...
          cut ((MinusPlus T) ⊆ B)...
            apply Prop_2_1... exists (sub P (1 + m))...
          apply In_Complement...
          apply H with x0...
        unfold AP, AM.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
        unfold AP.
          rewrite sup_Union, sub_Union.
          rewrite sup_idemp, sub_idemp.
          rewrite sub_sup_Empty_set, sup_sub_Empty_set...
          rewrite Minus_Singleton, Plus_Singleton.
          rewrite Empty_set_ident_left, Empty_set_ident_right.
          rewrite <- Setminus_is_Intersection_Complement.
          rewrite <- Adim...
      assert (Disjoint (Plus T') (Minus (plus x))) as Q2.
        apply IHn with A' B' M P...
        unfold T'.
          rewrite pred_Sn.
          apply (Cardinal_Setminus)...
        unfold T'.
          apply final_initial_lemma...
          unfold is_initial_segment...
          apply Singleton_Included...
          apply Constructive_sets.Singleton_intro.
          apply umax...
          inversion H2; clear H2.
          symmetry in H3; subst.
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
          inversion H2; clear H2. symmetry in H3; subst.
          apply segment_lemma with T...
          apply initial_segment_is_a_segment.
          apply le_initial_segment...
          unfold Z, In at 1...
          apply triangle_rest_in_set in H1...
          apply triangle_rest_trans with u...
          apply uinZ.
        apply Disjoint_impl_mor with T (minus x)... 
      assert (Disjoint (plus u) (Minus (plus x))) as Q5. 
        apply Disjoint_impl_mor with B' (Minus (plus x)); unfold Basics.flip...
        unfold B'...
        apply Prop_2_1_dual...
        exists A'...
        apply Prop_3_1_dual...
        assert (receptive (sup M m ∪ B') ∧ receptive (sup P m ∪ B')).
          apply Prop_3_3...
          unfold celldim. rewrite B'dim. unfold setdim; repeat (basic; intuition).
          apply le_trans with (1+ (dim x0))...
          assert ((dim x0) = m); simpl in H2... subst. apply le_refl.
          apply le_trans with (1+ (dim x0))...
          assert ((dim x0) = m); simpl in H2... subst... 
        intuition.
        apply receptive_by_dimension  with (n:= 1+m) in H2.
        rewrite sub_Union, sub_sup_Empty_set, Empty_set_ident_left in H2...
        rewrite <- B'dim in H2...
      assert ((w=u) \/ ~(w=u))...
        apply carrier_decidable_eq.
      - apply Q5 with z...
        apply In_Intersection...
        rewrite <- H2...
        exists v...
      - apply Q2 with z...
        apply In_Intersection...
        exists w... unfold T', In at 1... unfold Setminus... inversion H1...
        exists v...
    Qed.

  Lemma Lemma_3_2_Step_3 :
    forall n, (forall m , Lemma_3_2_b_st n m) ->
              (forall m , Lemma_3_2_b_dual_st n m) ->
              Prop_3_3_st (n) ->
              (Lemma_3_2_b_st (S n) 1).
  Proof with intuition.
    intros n Hyp1 Hyp2 Prop_3_3.

    (* n > 0 *)
    intros X Xcard M P K L.
    inversion K as [MPcell MPdim]; clear K.
    inversion L as [Xdim J]; clear L.
    inversion J as [Xwf Xcond]; clear J.
    assert (Finite X) as XFin. apply (Cardinal_are_Finite 1)...

    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    assert (x ∈ X) as xinX. rewrite Xsing...
    assert (dim x = S (S n)) as xdim.
      idtac...

    assert (plus x ⊆ sub M (S (S n))) as plusxdim.
      assert (PlusMinus X == plus x) as K.
        unfold PlusMinus. rewrite Xsing.
        rewrite Plus_Singleton, Minus_Singleton.
        apply Intersection_Included_left. apply Disjoint_property_left.
        apply plus_minus_Disjoint.
      rewrite <- K...
    set (Y := (sub M (S (S n)) ∪ Minus X) ∩ √Plus X).

    set (S' := (fun z =>  ~(In (plus x) z) /\ exists w, In (plus x) w /\ triangle_rest (sub M (S (S n))) z w)).
    assert (Finite S') as S'Fin.
      apply (Finite_Included (sub M (S (S n))))... apply Finite_sub. apply MPcell.
      unfold S', Included, In ... inversion H1; clear H1... inversion H2...
      assert ((In (plus x) x0) \/ ~(In (plus x) x0))... apply Finite_are_decidable...
      right... unfold S', In at 1 in H0...
      assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)))...
        apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left... unfold S', In at 1... right...  apply H2. unfold S', In at 1 in H0...
    assert (sub S' (S (S n)) == S') as S'dim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold S', Setminus in H... unfold In at 1 in H...
      inversion H1; clear H1...
      apply triangle_rest_in_set in H2...
    assert (is_initial_segment S' (sub M (S (S n)))) as S'initial.
      unfold is_initial_segment.
      split. unfold S', Included...
      unfold In at 1 in H... inversion H1; clear H1... induction H2...
      unfold S'... unfold In at 1 in H0... unfold In at 1... apply H1...
      inversion H2 as [w E]; clear H2...
      assert (is_a_segment (plus x) (sub M (S (S n))))... apply Prop_1_3... apply xplus_is_tight.
      apply (well_formed_Included M). apply MPcell. unfold Included, sub, In...
      apply segment_def' in H4...
      refine (H6 y w _ _ _)...
      inversion H2 as [a A]; exists a...
      apply (triangle_rest_trans _ _ z)...
    assert (Disjoint (plus x) S') as DisjMS'.
      unfold S', Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    set (T  := Setminus ((Setminus (sub M (S (S n)))) S') (plus x)).
    assert (Finite T) as TFin.
      unfold T. apply Setminus_Finite'...
      apply Setminus_Finite'...
      apply Finite_sub. apply MPcell.
    assert (sub T (S (S n)) == T) as Tdim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold T, Setminus in H... unfold In at 1, In at 1 in H...
    assert ((sub M (S (S n))) == S' ∪ (plus x) ∪ T) as DisjUnion.
      unfold Same_set, Included...
        assert (In (plus x) x0 \/ ~(In (plus x) x0))... apply Finite_are_decidable...
        assert (((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ plus x ∧ triangle_rest (sub M (S (S n))) x0 w)))...
          apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left; left. unfold S', In at 1...
        right. unfold T, Setminus... unfold In at 1... unfold In at 1... unfold S', In at 1 in H0...
        apply In_Union in H... apply In_Union in H0... unfold S', In at 1 in H... inversion H1; clear H1...
        inversion H2... unfold T, Setminus in H0; repeat (basic; intuition)...
    assert (Included S' (sub M (S (S n)))) as S'subset.
      rewrite DisjUnion...
    assert (is_final_segment T (sub M (S (S n)))) as Tfinal.
      unfold is_final_segment.
      split. unfold T, Setminus, Included, In...
      unfold T... unfold Setminus, In at 1 in H0... unfold In at 1 in H1...
      unfold Setminus, In at 1... unfold In at 1... apply triangle_rest_in_set in H... apply H3.
      unfold is_initial_segment in S'initial... apply (H5 y z)...
      assert (is_initial_segment (Union S' (plus x)) (sub M (S (S n)))).
        unfold is_initial_segment... rewrite DisjUnion. unfold Included...
        apply In_Union in H5... left.
        unfold is_initial_segment in S'initial... apply (H7 y0 z0)...
        assert ((y0 ∈ plus x) \/ ~(y0 ∈ plus x))... apply Finite_are_decidable... left. unfold S', In at 1... exists z0...
      unfold is_initial_segment in H4... assert (y ∈ S' ∪ plus x). apply (H6 y z)...
      apply In_Union in H4...
    assert (Disjoint (plus x) T) as DisjMT.
      unfold T, Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    assert (Disjoint T S') as DisjTS'.
      unfold T, S', Setminus. constructor...
      apply In_Intersection in H...
      unfold In at 1 in H1...
      unfold In at 1 in H0...
      unfold In at 1 in H1...

    set (B := (sub M (S n) ∪ Plus (S' ∪ plus x)) ∩ √Minus (S' ∪ plus x)).
    assert (sub B (S n) == B) as Bdim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H...
        unfold In at 1...
        unfold B in H...
        repeat (basic; intuition)...
        inversion H; clear H...
        assert (dim x1 = S n)...
          apply In_Union in H...
        assert (S (dim x0) = dim x1)...
        rewrite H3 in H6...

    assert ((S' ∪ plus x moves sub M (S n)
               to B)
              ∧ (T moves (sub P (S n) ∪ Minus T) ∩ √Plus T to sub P (S n))
                ∧ (sub P (S n) ∪ Minus T) ∩ √Plus T == B).
    unfold B.
    apply Prop_2_4_exact... apply Finite_Union...
    rewrite <- DisjUnion...
    apply moves_by_dim... apply MPcell...
    apply (Included_trans _ (PlusMinus (sub M (S (S n))))).
     unfold T, PlusMinus.
     repeat (rewrite Setminus_is_Intersection_Complement)...
     unfold Included; repeat (basic; intuition)...
     inversion H3... exists x1... repeat (basic; intuition)...
     apply In_Complement... apply H4...
     rewrite Intersection_trans.
     rewrite Union_Complement_compat.
     inversion H0... exists x1... repeat (basic; intuition)...
     inversion H3...              repeat (basic; intuition)...
       apply In_Complement... apply In_Union in H5...
       unfold S', In at 1 in H12...
       inversion H13; clear H13...
       apply (H1 x3)... apply In_Intersection...
       unfold is_final_segment in Tfinal...
       refine (H15 x2 _ _ _). apply (tr_trans _ _ x1)... exists x0...
       unfold T, In at 1; repeat (basic; intuition)...
       rewrite DisjUnion in H8; repeat (basic; intuition)...
       assert (x1 ∈ T)...
       unfold is_final_segment in Tfinal...
       refine (H13 x2 _ _ _)... apply (tr_trans _ _ x1)... exists x0...
       left... unfold T, Setminus in H8... unfold In at 1, In at 1 in H8; repeat (basic; intuition)...
    rewrite <- sub_PlusMinus...
    apply sub_Included_compat.
    apply Prop_2_1_dual... apply MPcell... exists M... apply MPcell...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_three...
    apply Disjoint_sym...
    rewrite <- DisjUnion.
    pose (well_formed_by_dimension M).
    inversion i. apply H.
    apply MPcell...
    apply Finite_Union...
    assert (dim b = S n). rewrite <- Tdim in H1...
    assert (dim a = S n). apply In_Union in H0...
    rewrite H, H2...

    inversion H as [movesMtoB [movesBtoP Bdef]].
    clear H. symmetry in Bdef. rewrite <- Bdef in movesBtoP.

    set (A := (sub M (S n) ∪ Plus S') ∩ √Minus S').
    assert (sub A (S n) == A) as Adim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H...
        unfold In at 1...
        unfold A in H...
        repeat (basic; intuition)...
        inversion H; clear H...
        assert (dim x1 = S n)...
          rewrite <- S'dim in H...
        assert (S (dim x0) = dim x1)...
        rewrite H3 in H6...

    assert ((S' moves sub M (S n) to A)
              ∧ (plus x moves (B ∪ Minus (plus x)) ∩ √Plus (plus x) to B)
                ∧ (B ∪ Minus (plus x)) ∩ √Plus (plus x) == A).
    unfold A.
    apply Prop_2_4_exact...
    unfold B, Included, PlusMinus...
      rewrite Plus_Union.
      rewrite Minus_Union.
      rewrite <- Union_Complement_compat.
      repeat (basic; intuition)...
      apply In_Complement...
        inversion H3... inversion H...
        assert (less x1 x2)... exists x0...
        apply (H2 x1)... basic...
        unfold is_initial_segment in S'initial...
        apply (H11 _ x2)... apply (tr_trans _ _ x2)... left...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_sym...
    apply (well_formed_Included M).
    apply MPcell...
    apply (Included_trans _ (sub M (S (S n))))...
    rewrite DisjUnion...
    assert (dim a = S n). rewrite <- S'dim in H0...
    assert (dim b = S n). assert (S (dim b) = dim x)...
    rewrite H, H2...

    inversion H as [movesMtoA [movesAtoB Adef]].
    clear H. symmetry in Adef. rewrite <- Adef in movesAtoB.

    set (tM := sub P (S n) ∪ sup M n).
    set (tP := sup P (S n)).
    assert (is_a_cell (tM, tP)) as tMPcell.
      unfold tM, tP. apply (target_is_a_cell)...
    assert (celldim (tM, tP) n) as tMPdim.
      apply target_dim...
    assert (sub tM (S n) == sub P (S n)) as targetrel.
        unfold tM...
        rewrite sub_Union. rewrite sub_idemp. rewrite sub_sup_Empty_set...
    assert (sup tM n == sup M n) as targetrel2.
        unfold tM...
        rewrite sup_Union. rewrite sup_idemp. rewrite sup_sub_Empty_set...
    assert (sup tP n == sup P n) as targetrel3.
        unfold tP...
        rewrite sup_sup_min...
    assert (sub tP (S n) == sub P (S n)) as targetrel4.
        unfold tP...
        rewrite sub_sup_cancel...

    assert (exists mT, Cardinal T mT). apply Cardinality_exists. assumption.
      inversion H as [mT Tcard]; clear H.

    (* T is an n-cell, from B to P *)
    assert (is_a_cell' (sup M n ∪ B ∪ T) (sup P (S n) ∪ T) ) as T1.
      rewrite Bdef.
      fold tP. rewrite <- targetrel. rewrite <- targetrel2.
      apply (Lemma_3_2_Step_1 _ mT)...
      unfold Included... subsuptac...
      assert (In (sub M (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...

    (* B is an (n-1)-cell, with disjoint condition *)
    assert (is_a_cell' (sup M n ∪ B)  (sup P n ∪ B)
       /\ (Minus T) ∩ sub P (S n) == Empty_set) as T2.
      rewrite Bdef. 
      try rewrite <- targetrel. 
      try rewrite <- targetrel2. 
      try rewrite <- targetrel3. 
      try rewrite <- targetrel4. 
      apply (Hyp1 mT)...
      unfold Included... subsuptac...
      assert (In (sub M (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included M)... apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...

    assert (exists mplusx, Cardinal (plus x) mplusx).
      apply Cardinality_exists...
      inversion H as [mplusx plusxcard]; clear H.

    (* (plus x) is an n-cell, from A to B *)
    assert (is_a_cell' 
             (sup (sup M n ∪ (B)) n ∪ ((sub (sup M n ∪ 
(B)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)) ∪ (plus x))
             ((sup P n ∪ (B)) ∪ (plus x))) as plusx1.
      apply (Lemma_3_2_Step_1 _ mplusx)...
      unfold celldim. rewrite <- Bdim. setdimtac.
        unfold Included, sub... unfold In at 1...
      assert (sub ((sup M n ∪ B)) (S n) == B).
        rewrite sub_Union... rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...
    rewrite sup_Union in plusx1.
    rewrite sub_Union in plusx1.
    rewrite <- Bdim in plusx1.
    rewrite sub_idemp, sup_idemp in plusx1.
    rewrite sub_sup_Empty_set in plusx1; auto.
    rewrite sup_sub_Empty_set in plusx1; auto.
    rewrite Empty_set_ident_right in plusx1.
    rewrite Empty_set_ident_left in plusx1.
    rewrite Bdim in plusx1.
    rewrite <- Adef in plusx1.

    (* A is an (n-1)-cell, with disjoint condition *)
    assert (is_a_cell' 
               (sup (sup M n ∪ (B)) n ∪ ((sub (sup M n ∪ (B)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)))
               (sup (sup P n ∪ (B)) n ∪ ((sub (sup M n ∪ (B)) (S n) ∪ Minus (plus x)) ∩ √Plus (plus x)))
             ∧ Minus (plus x) ∩ sub (sup M n ∪ (B)) (S n) == Empty_set) as plusx2.
      apply (Hyp1 mplusx)...
      unfold celldim. rewrite <- Bdim. setdimtac.
      unfold Included... unfold sub, In at 1...
      assert (sub ((sup M n ∪ B)) (S n) == B).
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...
    rewrite <- Bdim in plusx2.
    repeat (rewrite sup_Union in plusx2 ||
    rewrite sub_Union in plusx2 ||
    rewrite sub_idemp in plusx2 || rewrite sup_idemp in plusx2).
    repeat (rewrite sub_sup_Empty_set in plusx2; auto).
    repeat (rewrite sup_sub_Empty_set in plusx2; auto).
    repeat (rewrite Empty_set_ident_right in plusx2).
    repeat (rewrite Empty_set_ident_left in plusx2).
    rewrite Bdim in plusx2.
    rewrite <- Adef in plusx2.

    assert (exists mS', Cardinal S' mS').
      apply Cardinality_exists...
    inversion H as [mS' S'card]; clear H.

    (* S' is an n-cell *)
    assert (is_a_cell'
        ((sup (sup M n ∪ A) n ∪ ((sub (sup M n ∪ A) (S n) ∪ Minus S') ∩ √Plus S')) ∪ S') ((sup P n ∪ A) ∪ S')) as S'1.
      apply (Lemma_3_2_Step_1 _ mS')...
      unfold celldim. rewrite <- Adim. setdimtac.
        apply (Included_trans _ (sub M (S (S n)))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included M)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ plus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold Included; intros.
      rewrite sub_Union at 1. right.
      assert (PlusMinus S' ⊆ A). apply Prop_2_1_dual...
      exists (sub M (S n))... apply H4 in H3; clear H4.
      rewrite Adim...
    rewrite <- Adim in S'1.
    repeat (rewrite sup_Union in S'1 ||
    rewrite sub_Union in S'1 ||
    rewrite sub_idemp in S'1 || rewrite sup_idemp in S'1).
    repeat (rewrite sub_sup_Empty_set in S'1; auto).
    repeat (rewrite sup_sub_Empty_set in S'1; auto).
    repeat (rewrite Empty_set_ident_right in S'1).
    repeat (rewrite Empty_set_ident_left in S'1).
    rewrite Adim in S'1.

    assert ((minus x) moves A to B) as moves4.
      apply Prop_3_1.
      assumption.
      assert (receptive ((sup M n ∪ A))
           ∧ receptive ((sup P n ∪ A))).
      apply Prop_3_3...
      unfold celldim; rewrite <- Adim; unfold setdim; repeat (basic; intuition).
        assert (S (dim x0) <= n)...
        assert (dim x0 = n)... rewrite H7...
        assert (S (dim x0) <= n)...
        assert (dim x0 = n)... rewrite H7... 
      rewrite <- Adim.
      assert (receptive (sub ((sup (M) n ∪ A)) (S n))).
      apply receptive_by_dimension...
      repeat (rewrite sub_Union in H0).
      rewrite sub_sup_Empty_set in H0...
      rewrite Empty_set_ident_left in H0...

    assert (Disjoint (Minus S') (Plus (minus x))) as HardDisj.
      apply (Disjoint_result_p327) with mS' n A B M P...
      apply Disjoint_sym...

    assert (Disjoint (Minus (minus x)) (Plus T)) as HardDisj2.
      apply Disjoint_sym.
      apply (Disjoint_result_p327') with mT n A B M P...
      apply Disjoint_sym...

    assert ((S' ∪ (minus x)) moves (sub M (S n)) to B) as moves5.
      refine (Prop_2_3 _ _ _ _ _ movesMtoA _ _)...

    assert (((minus x) ∪ T) moves A  to (sub P (S n))) as moves6.
      refine (Prop_2_3 _ _ _ _ _ moves4 _ _)...

    assert (((S' ∪ (minus x)) ∪ T) moves (sub M (S n)) to (sub P (S n))) as moves7.
      refine (Prop_2_3 _ _ _ _ _ moves5 _ _)...
      apply Disjoint_Intersection_condition.
      rewrite Minus_Union.
      rewrite I_U_dist_r.
      assert ((Minus S' ∩ Plus T) == Empty_set).
        unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H3...
        inversion H4. inversion H5...
        refine (final_property _ (S') _ Tfinal _ _ x1 x2 _ _ _)...
        rewrite Disjoint_sym...
        exists x0...
        inversion H3.
        rewrite H3; clear H3. rewrite Empty_set_ident_left.
      apply (Disjoint_Intersection_condition)...

    assert ( Minus S' ∩ Minus (minus x) == Empty_set) as PerpS'minusxB.
      unfold Same_set...
      rewrite <- (Intersection_idemp (Minus (minus x))).
      assert (Minus (minus x) ⊆ Plus (minus x) ∪ Minus (plus x) ).
        rewrite <- axiom1...
      rewrite H3 at 2...
      rewrite <- Intersection_trans...
      rewrite I_U_dist_l...
      unfold Included; intros; exfalso.
      apply In_Union in H4...
      apply In_Intersection in H5...
      apply In_Intersection in H4...
      inversion HardDisj...
      apply (H4 x0)...
      apply In_Intersection in H5...
      apply In_Intersection in H4...
      assert (Disjoint (Minus S') (Minus (plus x))).
      apply (Disjoint_Minus (sub M (S (S n))))...
      apply Disjoint_sym...
      apply well_formed_sub... apply MPcell.
      inversion H4...
      apply (H8 x0)...

    assert ( Plus S' ∩ Plus (minus x) == Empty_set) as PerpS'minusxA.
      assert (Disjoint A (Plus (minus x))).
        apply Prop_2_1...  exists B...
      assert ((PlusMinus S') ⊆ A).
        unfold PlusMinus, A. unfold Included; repeat (basic; intuition).
      assert (Setminus (Plus (minus x)) (Minus S') == Plus (minus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H7 x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_comm (Plus (minus x))).
      rewrite <- Intersection_trans.
      fold (PlusMinus S').
      rewrite H0...

    assert ( Plus T ∩ Plus (minus x) == Empty_set) as PerpTminusxA.
      unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H3...
        assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
        rewrite axiom1...
        apply In_Union in H3...
        assert (Disjoint (Plus (plus x)) (Plus T) ).
        apply (Disjoint_Plus (sub M (S (S n))))...
        rewrite DisjUnion...
        apply well_formed_sub...
        apply MPcell.
        inversion H3...
        apply (H7 x0)...
        inversion HardDisj2.
        apply (H3 x0)...
        inversion H3...

    assert ( Minus T ∩ Minus (minus x) == Empty_set) as PerpTminusxB.
      assert (Disjoint B (Minus (minus x))).
        apply Prop_2_1_dual...  exists A...
      assert ((MinusPlus T) ⊆ B).
        unfold MinusPlus. rewrite Bdef. unfold Included; repeat (basic; intuition).
      assert (Setminus (Minus (minus x)) (Plus T) == Minus (minus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_comm (Minus (minus x))).
      rewrite <- Intersection_trans.
      fold (MinusPlus T).
      rewrite H0...

    assert (well_formed (S' ∪ (minus x))) as WF1.
      assert (Perp S' (minus x))...
      assert (sub (S' ∪ minus x) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          assert (dim x0 = S n)...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H5...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.

    assert (well_formed ((minus x) ∪ T)) as WF2.
      assert (Perp (minus x) T)...
        unfold Perp; split; rewrite Intersection_comm; assumption.
      assert (sub (minus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H5...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H4...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.
        rewrite DisjUnion...

    assert (well_formed ((S' ∪ minus x) ∪ T)) as WF3.
      assert (Perp ((S' ∪ minus x)) T).
        unfold Perp.
        rewrite Plus_Union, Minus_Union.
        split.
        rewrite I_U_dist_r. rewrite (Intersection_comm (Plus (minus x))).
        rewrite PerpTminusxA. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Plus (sub M (S (S n))))...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
        rewrite I_U_dist_r. rewrite (Intersection_comm (Minus (minus x))).
        rewrite PerpTminusxB. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Minus (sub M (S (S n))))...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
      assert (sub (S' ∪ minus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          apply In_Union in H4...
          assert (dim x0 = S n)...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H4...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H4...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub M (S (S n))))...
        apply (well_formed_Included M)...
        apply MPcell.
        rewrite DisjUnion...

    assert (Y == (S' ∪ minus x) ∪ T) as Ycond.
      unfold Y.
      rewrite DisjUnion.
      rewrite Xsing.
      rewrite Minus_Singleton, Plus_Singleton.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      repeat (rewrite <- Disjoint_result)...
      rewrite Union_trans, <- (Union_comm _ T).
      rewrite <- Union_trans...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...

    assert (Y == (sub Y (S (S n)))) as dimY.
      unfold Y, Same_set, Included...
        unfold sub, In at 1...
        repeat (basic; intuition)...
        apply eq_S.
        apply (Minus_dim X Full_set (S n))...

    (* real work begins *)
    split.
    unfold is_a_cell...

    rewrite Ycond. apply (Inhabited_Included (minus x)).
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    rewrite Ycond. apply (Inhabited_Included (minus x)).
      apply minus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    apply well_formed_Union...
    apply (well_formed_Included M).
    apply MPcell. idtac...
    rewrite Ycond...
    unfold Y in H6. assert (dim x0 <= n)...
    apply In_Intersection in H6...
    apply In_Union in H7...
    assert (dim y = S n)... rewrite H4, H7 in H3...
    assert (dim y = S n)... unfold Minus, In at 1 in H6... inversion H6; clear H6...
    assert (dim x1 = S (S n))... rewrite H4, H7 in H3...

    apply well_formed_Union...
    apply (well_formed_Included P).
    apply MPcell. unfold tP. apply sup_Included...
    rewrite Ycond...
    unfold Y in H6. assert (dim x0 <= n)...
    apply In_Intersection in H6...
    apply In_Union in H7...
    assert (dim y = S n)... rewrite H4, H7 in H3...
    assert (dim y = S n)... unfold Minus, In at 1 in H6... inversion H6; clear H6...
    assert (dim x1 = S (S n))... rewrite H4, H7 in H3...

    rewrite Ycond...
    repeat (apply Finite_Union)...
      apply all_decidable. apply Finite_sup... apply MPcell.
      apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    rewrite Ycond...
    repeat (apply Finite_Union)...
    apply all_decidable... apply Finite_sup... apply MPcell.
    apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- dimY || rewrite <- sub_Setminus)...
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond. unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3... rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell. apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...


    rewrite Xsing.
    rewrite Minus_Singleton.
    rewrite DisjUnion.
    repeat (rewrite I_U_dist_l).
    unfold Same_set, Included...
      exfalso.
      repeat (basic; intuition).
      unfold S', In at 1 in H10...
      inversion H11; clear H11...
      assert (triangle x0 x1).
        apply rest_implies_full in H12...
      apply (axiom3b _ _ x) in H10...
      assert (Inhabited (plus x0))...
        apply plus_Inhabited...
        assert (S (dim x0) = dim x)...
        assert (dim x = S (S n))...
        rewrite H11 in H9. inversion H9.
        rewrite H13...
      inversion H9; clear H9...
      assert (In (Plus (minus x)) x1)...
        exists x0...
      assert (In (Plus T) x1)...
        exists x0...
      assert (In (Plus (plus x) ∪ Minus (minus x)) x1)...
        rewrite axiom1...
      apply In_Union in H13...
        inversion H12; clear H12...
        inversion H14; clear H14...
        assert (well_formed (sub M (S (S n))))... apply well_formed_sub. apply MPcell.
        assert (x2 = x3)...
          unfold well_formed in H13...
          refine (H18 _ _ _ n _ _ _)...
          rewrite DisjUnion...
          assert (In (sub M (S (S n))) x2)... rewrite DisjUnion...
          unfold perp in H13...
          assert (In Empty_set x1)...
            rewrite <- H19...
        apply (H7 x2); subst...
        apply (H4 x1)...
    inversion H3...
  Qed.

  Lemma Lemma_3_2_dual_Step_3 :
    forall n, (forall m , Lemma_3_2_b_st n m) ->
              (forall m , Lemma_3_2_b_dual_st n m) ->
              Prop_3_3_st (n) ->
              (Lemma_3_2_b_dual_st (S n) 1).
  Proof with intuition.
    intros n Hyp1 Hyp2 Prop_3_3.

    (* n > 0 *)
    intros X Xcard M P K L.
    inversion K as [MPcell MPdim]; clear K.
    inversion L as [Xdim J]; clear L.
    inversion J as [Xwf Xcond]; clear J.
    assert (Finite X) as XFin. apply (Cardinal_are_Finite 1)...

    apply Cardinality_one_Singleton in Xcard.
    inversion Xcard as [x Xsing]; clear Xcard.
    assert (x ∈ X) as xinX. rewrite Xsing...
    assert (dim x = S (S n)) as xdim.
      idtac...

    assert (minus x ⊆ sub P (S (S n))) as plusxdim.
      assert (MinusPlus X == minus x) as K.
        unfold MinusPlus. rewrite Xsing.
        rewrite Plus_Singleton, Minus_Singleton.
        apply Intersection_Included_left. apply Disjoint_property_left.
        apply Disjoint_sym; apply plus_minus_Disjoint.
      rewrite <- K...
    set (Y := (sub P (S (S n)) ∪ Plus X) ∩ √Minus X).

    set (S' := (fun z =>  ~(In (minus x) z) /\ exists w, In (minus x) w /\ triangle_rest (sub P (S (S n))) z w)).
    assert (Finite S') as S'Fin.
      apply (Finite_Included (sub P (S (S n))))... apply Finite_sub. apply MPcell.
      unfold S', Included, In ... inversion H1; clear H1... inversion H2...
      assert ((In (minus x) x0) \/ ~(In (minus x) x0))... apply Finite_are_decidable...
      right... unfold S', In at 1 in H0...
      assert (((∃ w : carrier, w ∈ minus x ∧ triangle_rest (sub P (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ minus x ∧ triangle_rest (sub P (S (S n))) x0 w)))...
        apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left... unfold S', In at 1... right...  apply H2. unfold S', In at 1 in H0...
    assert (sub S' (S (S n)) == S') as S'dim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold S', Setminus in H... unfold In at 1 in H...
      inversion H1; clear H1...
      apply triangle_rest_in_set in H2...
    assert (is_initial_segment S' (sub P (S (S n)))) as S'initial.
      unfold is_initial_segment.
      split. unfold S', Included...
      unfold In at 1 in H... inversion H1; clear H1... induction H2...
      unfold S'... unfold In at 1 in H0... unfold In at 1... apply H1...
      inversion H2 as [w E]; clear H2...
      assert (is_a_segment (minus x) (sub P (S (S n))))... apply Prop_1_3... 
      apply xminus_is_tight.
      apply (well_formed_Included P). apply MPcell. unfold Included, sub, In...
      apply segment_def' in H4...
      refine (H6 y w _ _ _)...
      inversion H2 as [a A]; exists a...
      apply (triangle_rest_trans _ _ z)...
    assert (Disjoint (minus x) S') as DisjMS'.
      unfold S', Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    set (T  := Setminus ((Setminus (sub P (S (S n)))) S') (minus x)).
    assert (Finite T) as TFin.
      unfold T. apply Setminus_Finite'...
      apply Setminus_Finite'...
      apply Finite_sub. apply MPcell.
    assert (sub T (S (S n)) == T) as Tdim.
      unfold Same_set, Included, sub...
      unfold In at 1 in H...
      unfold In at 1...
      unfold T, Setminus in H... unfold In at 1, In at 1 in H...
    assert ((sub P (S (S n))) == S' ∪ (minus x) ∪ T) as DisjUnion.
      unfold Same_set, Included...
        assert (In (minus x) x0 \/ ~(In (minus x) x0))... apply Finite_are_decidable...
        assert (((∃ w : carrier, w ∈ minus x ∧ triangle_rest (sub P (S (S n))) x0 w)) \/ ~((∃ w : carrier, w ∈ minus x ∧ triangle_rest (sub P (S (S n))) x0 w)))...
          apply Finite_decidable_existence... apply triangle_rest_dec. apply Finite_sub. apply MPcell.
        left; left. unfold S', In at 1...
        right. unfold T, Setminus... unfold In at 1... unfold In at 1... unfold S', In at 1 in H0...
        apply In_Union in H... apply In_Union in H0... unfold S', In at 1 in H... inversion H1; clear H1...
        inversion H2... unfold T, Setminus in H0; repeat (basic; intuition)...
    assert (Included S' (sub P (S (S n)))) as S'subset.
      rewrite DisjUnion...
    assert (is_final_segment T (sub P (S (S n)))) as Tfinal.
      unfold is_final_segment.
      split. unfold T, Setminus, Included, In...
      unfold T... unfold Setminus, In at 1 in H0... unfold In at 1 in H1...
      unfold Setminus, In at 1... unfold In at 1... apply triangle_rest_in_set in H... apply H3.
      unfold is_initial_segment in S'initial... apply (H5 y z)...
      assert (is_initial_segment (Union S' (minus x)) (sub P (S (S n)))).
        unfold is_initial_segment... rewrite DisjUnion. unfold Included...
        apply In_Union in H5... left.
        unfold is_initial_segment in S'initial... apply (H7 y0 z0)...
        assert ((y0 ∈ minus x) \/ ~(y0 ∈ minus x))... apply Finite_are_decidable... left. unfold S', In at 1... exists z0...
      unfold is_initial_segment in H4... assert (y ∈ S' ∪ minus x). apply (H6 y z)...
      apply In_Union in H4...
    assert (Disjoint (minus x) T) as DisjMT.
      unfold T, Setminus. constructor... apply In_Intersection in H...
      unfold In at 1 in H1...
    assert (Disjoint T S') as DisjTS'.
      unfold T, S', Setminus. constructor...
      apply In_Intersection in H...
      unfold In at 1 in H1...
      unfold In at 1 in H0...
      unfold In at 1 in H1...

    set (B := (sub M (S n) ∪ Plus (S' ∪ minus x)) ∩ √Minus (S' ∪ minus x)).
    assert (sub B (S n) == B) as Bdim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H...
        unfold In at 1...
        unfold B in H...
        repeat (basic; intuition)...
        inversion H; clear H...
        assert (dim x1 = S n)...
          apply In_Union in H...
        assert (S (dim x0) = dim x1)...
        rewrite H3 in H6...

    assert ((S' ∪ minus x moves sub M (S n)
               to B)
              ∧ (T moves (sub P (S n) ∪ Minus T) ∩ √Plus T to sub P (S n))
                ∧ (sub P (S n) ∪ Minus T) ∩ √Plus T == B).
    unfold B.
    apply Prop_2_4_exact... apply Finite_Union...
    rewrite <- DisjUnion...
    apply moves_by_dim... apply MPcell...
    apply (Included_trans _ (PlusMinus (sub P (S (S n))))).
     unfold T, PlusMinus.
     repeat (rewrite Setminus_is_Intersection_Complement)...
     unfold Included; repeat (basic; intuition)...
     inversion H3... exists x1... repeat (basic; intuition)...
     apply In_Complement... apply H4...
     rewrite Intersection_trans.
     rewrite Union_Complement_compat.
     inversion H0... exists x1... repeat (basic; intuition)...
     inversion H3...              repeat (basic; intuition)...
       apply In_Complement... apply In_Union in H5...
       unfold S', In at 1 in H12...
       inversion H13; clear H13...
       apply (H1 x3)... apply In_Intersection...
       unfold is_final_segment in Tfinal...
       refine (H15 x2 _ _ _). apply (tr_trans _ _ x1)... exists x0...
       unfold T, In at 1; repeat (basic; intuition)...
       rewrite DisjUnion in H8; repeat (basic; intuition)...
       assert (x1 ∈ T)...
       unfold is_final_segment in Tfinal...
       refine (H13 x2 _ _ _)... apply (tr_trans _ _ x1)... exists x0...
       left... unfold T, Setminus in H8... unfold In at 1, In at 1 in H8; repeat (basic; intuition)...
    rewrite <- sub_PlusMinus...
    apply sub_Included_compat.
    apply Prop_2_1_dual... apply MPcell... exists M... apply MPcell...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_three...
    apply Disjoint_sym...
    rewrite <- DisjUnion.
    pose (well_formed_by_dimension P).
    inversion i. apply H.
    apply MPcell...
    apply Finite_Union...
    assert (dim b = S n). rewrite <- Tdim in H1...
    assert (dim a = S n). apply In_Union in H0...
    rewrite H, H2...

    inversion H as [movesMtoB [movesBtoP Bdef]].
    clear H. symmetry in Bdef. rewrite <- Bdef in movesBtoP.

    set (A := (sub M (S n) ∪ Plus S') ∩ √Minus S').
    assert (sub A (S n) == A) as Adim.
      unfold Same_set, Included, sub...
        unfold In at 1 in H...
        unfold In at 1...
        unfold A in H...
        repeat (basic; intuition)...
        inversion H; clear H...
        assert (dim x1 = S n)...
          rewrite <- S'dim in H...
        assert (S (dim x0) = dim x1)...
        rewrite H3 in H6...

    assert ((S' moves sub M (S n) to A)
              ∧ (minus x moves (B ∪ Minus (minus x)) ∩ √Plus (minus x) to B)
                ∧ (B ∪ Minus (minus x)) ∩ √Plus (minus x) == A).
    unfold A.
    apply Prop_2_4_exact...
    unfold B, Included, PlusMinus...
      rewrite Plus_Union.
      rewrite Minus_Union.
      rewrite <- Union_Complement_compat.
      repeat (basic; intuition)...
      apply In_Complement...
        inversion H3... inversion H...
        assert (less x1 x2)... exists x0...
        apply (H2 x1)... basic...
        unfold is_initial_segment in S'initial...
        apply (H11 _ x2)... apply (tr_trans _ _ x2)... left...
    unfold Perp.
    apply Perp_thing...
    apply Disjoint_sym...
    apply (well_formed_Included P).
    apply MPcell...
    apply (Included_trans _ (sub P (S (S n))))...
    rewrite DisjUnion...
    assert (dim a = S n). rewrite <- S'dim in H0...
    assert (dim b = S n). assert (S (dim b) = dim x)...
    rewrite H, H2...

    inversion H as [movesMtoA [movesAtoB Adef]].
    clear H. symmetry in Adef. rewrite <- Adef in movesAtoB.

    set (tM := sub P (S n) ∪ sup M n).
    set (tP := sup P (S n)).
    assert (is_a_cell (tM, tP)) as tMPcell.
      unfold tM, tP. apply (target_is_a_cell)...
    assert (celldim (tM, tP) n) as tMPdim.
      apply target_dim...
    assert (sub tM (S n) == sub P (S n)) as targetrel.
        unfold tM...
        rewrite sub_Union. rewrite sub_idemp. rewrite sub_sup_Empty_set...
    assert (sup tM n == sup M n) as targetrel2.
        unfold tM...
        rewrite sup_Union. rewrite sup_idemp. rewrite sup_sub_Empty_set...
    assert (sup tP n == sup P n) as targetrel3.
        unfold tP...
        rewrite sup_sup_min...
    assert (sub tP (S n) == sub P (S n)) as targetrel4.
        unfold tP...
        rewrite sub_sup_cancel...

    assert (exists mT, Cardinal T mT). apply Cardinality_exists. assumption.
      inversion H as [mT Tcard]; clear H.

    (* T is an n-cell, from B to P *)
    assert (is_a_cell' (sup M n ∪ B ∪ T) (sup P (S n) ∪ T) ) as T1.
      rewrite Bdef.
      fold tP. rewrite <- targetrel. rewrite <- targetrel2.
      apply (Lemma_3_2_Step_1 _ mT)...
      unfold Included... subsuptac...
      assert (In (sub P (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included P)... apply MPcell.
      apply (Included_trans _ ((S' ∪ minus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...

    (* B is an (n-1)-cell, with disjoint condition *)
    assert (is_a_cell' (sup M n ∪ B)  (sup P n ∪ B)
       /\ (Minus T) ∩ sub P (S n) == Empty_set) as T2.
      rewrite Bdef. 
      try rewrite <- targetrel. 
      try rewrite <- targetrel2. 
      try rewrite <- targetrel3. 
      try rewrite <- targetrel4. 
      apply (Hyp1 mT)...
      unfold Included... subsuptac...
      assert (In (sub P (S (S n))) x0). rewrite DisjUnion. right...
      subsuptac...
      apply (well_formed_Included P)... apply MPcell.
      apply (Included_trans _ ((S' ∪ minus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold tM.
      rewrite sub_Union. left. rewrite sub_idemp.
      assert (PlusMinus T ⊆ (sub P (S n))). apply Prop_2_1_dual...
      exists B... apply H0...

    assert (exists mplusx, Cardinal (minus x) mplusx).
      apply Cardinality_exists...
      inversion H as [mplusx plusxcard]; clear H.

    (* (plus x) is an n-cell, from A to B *)
    assert (is_a_cell' 
             (sup (sup M n ∪ (B)) n ∪ ((sub (sup M n ∪ 
(B)) (S n) ∪ Minus (minus x)) ∩ √Plus (minus x)) ∪ (minus x))
             ((sup P n ∪ (B)) ∪ (minus x))) as plusx1.
      apply (Lemma_3_2_Step_1 _ mplusx)...
      unfold celldim. rewrite <- Bdim. setdimtac.
        unfold Included, sub... unfold In at 1...
      assert (sub ((sup M n ∪ B)) (S n) == B).
        rewrite sub_Union... rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...
    rewrite sup_Union in plusx1.
    rewrite sub_Union in plusx1.
    rewrite <- Bdim in plusx1.
    rewrite sub_idemp, sup_idemp in plusx1.
    rewrite sub_sup_Empty_set in plusx1; auto.
    rewrite sup_sub_Empty_set in plusx1; auto.
    rewrite Empty_set_ident_right in plusx1.
    rewrite Empty_set_ident_left in plusx1.
    rewrite Bdim in plusx1.
    rewrite <- Adef in plusx1.

    (* A is an (n-1)-cell, with disjoint condition *)
    assert (is_a_cell' 
               (sup (sup M n ∪ (B)) n ∪ ((sub (sup M n ∪ (B)) (S n) ∪ Minus (minus x)) ∩ √Plus (minus x)))
               (sup (sup P n ∪ (B)) n ∪ ((sub (sup M n ∪ (B)) (S n) ∪ Minus (minus x)) ∩ √Plus (minus x)))
             ∧ Minus (minus x) ∩ sub (sup M n ∪ (B)) (S n) == Empty_set) as plusx2.
      apply (Hyp1 mplusx)...
      unfold celldim. rewrite <- Bdim. setdimtac.
      unfold Included... unfold sub, In at 1...
      assert (sub ((sup M n ∪ B)) (S n) == B).
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite Empty_set_ident_left...
      rewrite H1.
      apply Prop_2_1_dual...
      exists A...
    rewrite <- Bdim in plusx2.
    repeat (rewrite sup_Union in plusx2 ||
    rewrite sub_Union in plusx2 ||
    rewrite sub_idemp in plusx2 || rewrite sup_idemp in plusx2).
    repeat (rewrite sub_sup_Empty_set in plusx2; auto).
    repeat (rewrite sup_sub_Empty_set in plusx2; auto).
    repeat (rewrite Empty_set_ident_right in plusx2).
    repeat (rewrite Empty_set_ident_left in plusx2).
    rewrite Bdim in plusx2.
    rewrite <- Adef in plusx2.

    assert (exists mS', Cardinal S' mS').
      apply Cardinality_exists...
    inversion H as [mS' S'card]; clear H.

    (* S' is an n-cell *)
    assert (is_a_cell'
        ((sup (sup M n ∪ A) n ∪ ((sub (sup M n ∪ A) (S n) ∪ Minus S') ∩ √Plus S')) ∪ S') ((sup P n ∪ A) ∪ S')) as S'1.
      apply (Lemma_3_2_Step_1 _ mS')...
      unfold celldim. rewrite <- Adim. setdimtac.
        apply (Included_trans _ (sub P (S (S n)))). rewrite DisjUnion...
        apply sub_Included'...
      apply (well_formed_Included P)...       apply MPcell.
      apply (Included_trans _ ((S' ∪ minus x) ∪ T))...
      rewrite <- DisjUnion...
      unfold Included; intros.
      rewrite sub_Union at 1. right.
      assert (PlusMinus S' ⊆ A). apply Prop_2_1_dual...
      exists (sub M (S n))... apply H4 in H3; clear H4.
      rewrite Adim...
    rewrite <- Adim in S'1.
    repeat (rewrite sup_Union in S'1 ||
    rewrite sub_Union in S'1 ||
    rewrite sub_idemp in S'1 || rewrite sup_idemp in S'1).
    repeat (rewrite sub_sup_Empty_set in S'1; auto).
    repeat (rewrite sup_sub_Empty_set in S'1; auto).
    repeat (rewrite Empty_set_ident_right in S'1).
    repeat (rewrite Empty_set_ident_left in S'1).
    rewrite Adim in S'1.

    assert ((plus x) moves A to B) as moves4.
      apply Prop_3_1_dual.
      assumption.
      assert (receptive (sup M n ∪ B)
           ∧ receptive (sup P n ∪ B)).
      apply Prop_3_3...
      unfold celldim; rewrite <- Bdim; unfold setdim; repeat (basic; intuition).
        assert (S (dim x0) <= n)... 
        assert (  (dim x0)  = n)... rewrite H7... 
        assert (S (dim x0) <= n)...
        assert (  (dim x0)  = n)... rewrite H7... 
      rewrite <- Bdim.
      assert (receptive (sub ((sup P n ∪ B)) (S n))).
      apply receptive_by_dimension...
      repeat (rewrite sub_Union in H0).
      rewrite sub_sup_Empty_set in H0...
      rewrite Empty_set_ident_left in H0...

    assert (Disjoint (Minus S') (Plus (plus x))) as HardDisj.
      apply (Disjoint_result_p327_dual) with mS' n A B M P...
      apply Disjoint_sym... 

    assert (Disjoint (Minus (plus x)) (Plus T)) as HardDisj2.
      apply Disjoint_sym. 
      apply (Disjoint_result_p327_dual') with mT n A B M P...
      apply Disjoint_sym...

    assert ((S' ∪ (plus x)) moves (sub M (S n)) to B) as moves5.
      refine (Prop_2_3 _ _ _ _ _ movesMtoA _ _)...

    assert (((plus x) ∪ T) moves A  to (sub P (S n))) as moves6.
      refine (Prop_2_3 _ _ _ _ _ moves4 _ _)...

    assert (((S' ∪ (plus x)) ∪ T) moves (sub M (S n)) to (sub P (S n))) as moves7.
      refine (Prop_2_3 _ _ _ _ _ moves5 _ _)...
      apply Disjoint_Intersection_condition.
      rewrite Minus_Union.
      rewrite I_U_dist_r.
      assert ((Minus S' ∩ Plus T) == Empty_set).
        unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H3...
        inversion H4. inversion H5...
        refine (final_property _ (S') _ Tfinal _ _ x1 x2 _ _ _)...
        rewrite Disjoint_sym...
        exists x0...
        inversion H3.
        rewrite H3; clear H3. rewrite Empty_set_ident_left.
      apply (Disjoint_Intersection_condition)...

    assert ( Minus S' ∩ Minus (plus x) == Empty_set) as PerpS'minusxB.
      unfold Same_set...
      rewrite <- (Intersection_idemp (Minus (plus x))).
      assert (Minus (plus x) ⊆ Plus (plus x) ∪ Minus (minus x) ).
        rewrite axiom1...
      rewrite H3 at 2...
      rewrite <- Intersection_trans...
      rewrite I_U_dist_l...
      unfold Included; intros; exfalso.
      apply In_Union in H4...
      apply In_Intersection in H5...
      apply In_Intersection in H4...
      inversion HardDisj...
      apply (H4 x0)...
      apply In_Intersection in H5...
      apply In_Intersection in H4...
      assert (Disjoint (Minus S') (Minus (minus x))).
      apply (Disjoint_Minus (sub P (S (S n))))...
      apply Disjoint_sym...
      apply well_formed_sub... apply MPcell.
      inversion H4...
      apply (H8 x0)...

    assert ( Plus S' ∩ Plus (plus x) == Empty_set) as PerpS'minusxA.
      assert (Disjoint A (Plus (plus x))).
        apply Prop_2_1...  exists B...
      assert ((PlusMinus S') ⊆ A).
        unfold PlusMinus, A. unfold Included; repeat (basic; intuition).
      assert (Setminus (Plus (plus x)) (Minus S') == Plus (plus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H7 x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_comm (Plus (plus x))).
      rewrite <- Intersection_trans.
      fold (PlusMinus S').
      rewrite H0...

    assert ( Plus T ∩ Plus (plus x) == Empty_set) as PerpTminusxA.
      unfold Same_set, Included...
        exfalso.
        apply In_Intersection in H3...
        assert (In (Plus (minus x) ∪ Minus (plus x)) x0).
        rewrite <- axiom1...
        apply In_Union in H3...
        assert (Disjoint (Plus (minus x)) (Plus T) ).
        apply (Disjoint_Plus (sub P (S (S n))))...
        rewrite DisjUnion...
        apply well_formed_sub...
        apply MPcell.
        inversion H3...
        apply (H7 x0)...
        inversion HardDisj2.
        apply (H3 x0)...
        inversion H3...

    assert ( Minus T ∩ Minus (plus x) == Empty_set) as PerpTminusxB.
      assert (Disjoint B (Minus (plus x))).
        apply Prop_2_1_dual...  exists A...
      assert ((MinusPlus T) ⊆ B).
        unfold MinusPlus. rewrite Bdef. unfold Included; repeat (basic; intuition).
      assert (Setminus (Minus (plus x)) (Plus T) == Minus (plus x)).
        unfold Same_set, Included; repeat (basic; intuition)... apply (H x0)...
      apply (Included_Empty_set _ Empty_set)...
      apply Disjoint_Intersection_condition in H.
      rewrite <- H; clear H.
      rewrite <- H1 at 1; clear H1.
      rewrite Setminus_is_Intersection_Complement.
      rewrite (Intersection_comm (Minus (plus x))).
      rewrite <- Intersection_trans.
      fold (MinusPlus T).
      rewrite H0...

    assert (well_formed (S' ∪ (plus x))) as WF1.
      assert (Perp S' (plus x))...
      assert (sub (S' ∪ plus x) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          assert (dim x0 = S n)...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H5...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub P (S (S n))))...
        apply (well_formed_Included P)...
        apply MPcell.

    assert (well_formed ((plus x) ∪ T)) as WF2.
      assert (Perp (plus x) T)...
        unfold Perp; split; rewrite Intersection_comm; assumption.
      assert (sub (plus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H5...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H4...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub P (S (S n))))...
        apply (well_formed_Included P)...
        apply MPcell.
        rewrite DisjUnion...

    assert (well_formed ((S' ∪ plus x) ∪ T)) as WF3.
      assert (Perp ((S' ∪ plus x)) T).
        unfold Perp.
        rewrite Plus_Union, Minus_Union.
        split.
        rewrite I_U_dist_r. rewrite (Intersection_comm (Plus (plus x))).
        rewrite PerpTminusxA. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Plus (sub P (S (S n))))...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
        rewrite I_U_dist_r. rewrite (Intersection_comm (Minus (plus x))).
        rewrite PerpTminusxB. rewrite Empty_set_ident_right.
        apply Disjoint_Intersection_condition. apply Disjoint_sym.
        apply (Disjoint_Minus (sub P (S (S n))))...
          rewrite DisjUnion...
          apply well_formed_sub...
          apply MPcell.
      assert (sub (S' ∪ plus x ∪ T) 1 == Empty_set).
        unfold Same_set, Included...
          exfalso.
          unfold sub, In at 1 in H4...
          apply In_Union in H5...
          apply In_Union in H4...
          assert (dim x0 = S n)...
          assert (S (dim x0) = dim x)...
          rewrite xdim in H4...
          assert (dim x0 = S n)...
            rewrite <- Tdim in H4...
          inversion H4...
      apply well_formed_Union_lemma...
        apply (well_formed_Included (sub P (S (S n))))...
        apply (well_formed_Included P)...
        apply MPcell.
        rewrite DisjUnion...

    assert (Y == (S' ∪ plus x) ∪ T) as Ycond.
      unfold Y.
      rewrite DisjUnion.
      rewrite Xsing.
      rewrite Minus_Singleton, Plus_Singleton.
      repeat (rewrite I_U_dist_r).
      rewrite Empty_set_property.
      rewrite Empty_set_ident_right.
      repeat (rewrite <- Disjoint_result)...
      rewrite Union_trans, <- (Union_comm _ T).
      rewrite <- Union_trans...
      apply Disjoint_Intersection_condition...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...
      apply Disjoint_Intersection_condition... apply Disjoint_sym...

    assert (Y == (sub Y (S (S n)))) as dimY.
      unfold Y, Same_set, Included...
        unfold sub, In at 1...
        repeat (basic; intuition)...
        apply eq_S.
        apply (Plus_dim X (S n))...

    (* real work begins *)
    split.
    unfold is_a_cell...

    rewrite Ycond. apply (Inhabited_Included (plus x)).
      apply plus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    rewrite Ycond. apply (Inhabited_Included (plus x)).
      apply plus_Inhabited. rewrite xdim...
      unfold Included; intros; right;left;right...

    apply well_formed_Union...
    apply well_formed_sup...
    apply MPcell. 
    rewrite Ycond...
    unfold Y in H6. assert (dim x0 <= n)...
    apply In_Intersection in H6...
    apply In_Union in H7...
    assert (dim y = S n)... rewrite H4, H7 in H3...
    assert (dim y = S n)... unfold Plus, In at 1 in H6... inversion H6; clear H6... 
    assert (dim x1 = S (S n))... assert (S (dim y) = dim x1)... rewrite H7 in H10... rewrite H4, H7 in H3...

    apply well_formed_Union...
    apply well_formed_sup...
    apply MPcell. 
    rewrite Ycond...
    unfold Y in H6. assert (dim x0 <= n)...
    apply In_Intersection in H6...
    apply In_Union in H7...
    assert (dim y = S n)... rewrite H4, H7 in H3...
    assert (dim y = S n)... unfold Plus, In at 1 in H6... inversion H6; clear H6...
    assert (dim x1 = S (S n))... assert (S (dim y) = dim x1)... rewrite H7 in H10... rewrite H4, H7 in H3... 

    rewrite Ycond...
    repeat (apply Finite_Union)...
      apply all_decidable. apply Finite_sup... apply MPcell.
      apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    rewrite Ycond...
    repeat (apply Finite_Union)...
    apply all_decidable... apply Finite_sup... apply MPcell.
    apply all_decidable. apply Finite_Union... apply Finite_sup... apply MPcell.

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})...
          apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- dimY || rewrite <- sub_Setminus)...
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond. unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3... rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

    unfold moves_def...
      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell. apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

      apply Same_set_by_dimension'.
        intros.
        rewrite <- Setminus_is_Intersection_Complement.
        rewrite dimY.
        unfold tP.
        repeat (rewrite sub_Setminus || rewrite sub_Union || rewrite sub_Minus || rewrite sub_Plus)...
        assert ({k < n} + {k = n} + {k = S n} + {S n < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite sub_sup_cancel || rewrite sub_sub_Empty_set ||
                  rewrite Empty_set_ident_right || rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Union || rewrite <- sub_Minus || rewrite <- sub_Plus)...
          rewrite Setminus_is_Intersection_Complement.
          apply sub_Same_set_Proper... apply MPcell.
          apply eq_add_S in H3.
          rewrite <- H3 in a...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set _ (S (S n))) ||
                  rewrite (sub_sub_Empty_set _ (S n)) || rewrite sub_idemp ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right)...
          repeat (rewrite <- sub_Setminus || rewrite <- dimY).
          rewrite Setminus_is_Intersection_Complement.
          rewrite Ycond.
          unfold moves_def in moves7...
          rewrite b.
          repeat (rewrite (sub_sup_cancel (S n)) || rewrite (sub_sup_Empty_set) ||
                  rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...
          repeat (rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_sub_Empty_set) ||
                  rewrite Empty_set_ident_left || rewrite Empty_set_ident_right ||
                  rewrite Plus_Empty_set ||
                  rewrite Minus_Empty_set || rewrite Setminus_Empty_set)...

    rewrite Xsing.
    rewrite Plus_Singleton.
    rewrite DisjUnion.
    repeat (rewrite I_U_dist_l).
    unfold Same_set, Included...
      exfalso.
      repeat (basic; intuition).
      (**)
      unfold S', In at 1 in H10...
      inversion H11; clear H11...
      assert (triangle x0 x1).
        apply rest_implies_full in H12...
      apply (axiom3b _ _ x) in H10...
      (**)
      assert (Inhabited (plus x0))...
        apply plus_Inhabited...
        assert (S (dim x0) = dim x)...
        assert (dim x = S (S n))...
        rewrite H11 in H9. inversion H9.
        rewrite H13...
      inversion H9; clear H9...
      assert (In (Plus (plus x)) x1)...
        exists x0...
      assert (In (Plus T) x1)...
        exists x0...
      assert (In (Plus (minus x) ∪ Minus (plus x)) x1)...
        rewrite <- axiom1...
      apply In_Union in H13...
        inversion H12; clear H12...
        inversion H14; clear H14...
        assert (well_formed (sub P (S (S n))))... apply well_formed_sub. apply MPcell.
        assert (x2 = x3)...
          unfold well_formed in H13...
          refine (H18 _ _ _ n _ _ _)...
          rewrite DisjUnion...
          assert (In (sub P (S (S n))) x2)... rewrite DisjUnion...
          unfold perp in H13...
          assert (In Empty_set x1)...
            rewrite <- H19...
        apply (H7 x2); subst...
        apply (H4 x1)...
    inversion H3...
  Qed.

(* ~~~~~~~~~~~~   Prop_3_3  ~~~~~~~~~~~~~~~ *)

  Lemma fff : forall T x, receptive_x T x <-> (dim x <= 1 \/ ((2 <= dim x) /\ receptive_x (sub T (pred (dim x))) x)).
  Proof with intuition.
    split; intros.
    assert ({dim x <= 1} + {2 <= dim x})...
      destruct (dim x); [left | idtac]...
      destruct (n); [left | right]...
    right...
    apply receptive_x_by_dimension...
    inversion H; clear H.
    unfold receptive_x...
    inversion H2... apply In_Intersection in H3...
      assert (S (S (dim x0)) = dim  x)...
      rewrite <- H3 in H0; inversion H0; inversion H7...
      inversion H2... apply In_Intersection in H3...
      assert (S (S (dim x0)) = dim  x)...
      rewrite <- H3 in H0; inversion H0; inversion H7...
      unfold receptive_x in *...
    + apply H0...
      - unfold Included, sub, In at 2... apply In_Intersection in H5...
        assert (S (S (dim x0)) = dim x)... rewrite <- H5...
      - apply H3. apply (Inhabited_Included _ H5)...
        apply Intersection_Included_compat...
      - inversion H4... 
        exists x0... repeat (basic; intuition)... unfold sub, In at 1... 
        assert (S (S (dim x0)) = dim x)... rewrite <- H5...
    + apply H2...
      - unfold Included, sub, In at 2... apply In_Intersection in H5...
        assert (S (S (dim x0)) = dim x)... rewrite <- H5...
      - apply H3. apply (Inhabited_Included _ H5)...
        apply Intersection_Included_compat...
      - inversion H4... 
        exists x0... repeat (basic; intuition)... unfold sub, In at 1... 
        assert (S (S (dim x0)) = dim x)... rewrite <- H5...
  Qed.

  Definition n_receptive : nat -> Prop := 
    fun n => forall M P, is_a_cell (M, P) -> 
    celldim (M, P) n -> forall x,
     receptive_x M x /\ receptive_x P x.

 Lemma ggg : forall P Q : carrier -> Prop, (forall x, (P x) /\ (Q x)) <-> ((forall x, P x) /\ (forall x, Q x)).
 Proof with intuition.
 intuition. apply H... apply H...
 Qed.

  Lemma n_receptive_zero : Prop_3_3_st 0.
  Proof with intuition.
    unfold Prop_3_3_st, receptive. 
    intros M P MPcell MPdim.
    apply ggg; intros x.
    assert (sub M (S 0) == sub P (S 0)) as K.
      apply cell_dim_n_property...
    assert (M == sub M 1) as Mdim. 
      unfold Same_set, Included, sub, In at 2... 
      apply eq_S.
      assert (dim x0 <= 0)... unfold In in H...
    assert (P == sub P 1) as Pdim. 
      unfold Same_set, Included, sub, In at 2... 
      apply eq_S.
      assert (dim x0 <= 0)... unfold In in H...
    assert ((sub M 1) == Empty_set ∨ Inhabited (sub M 1)) as K2. 
      apply Finite_Empty_or_Inhabited...
      apply Finite_sub. apply MPcell.
    rewrite Mdim, Pdim, <- K.
    assert (forall m : Prop, m -> (m /\ m)). intuition. apply H; clear H. 
    inversion K2; clear K2.
    + rewrite H; unfold receptive_x; intuition;
      rewrite Empty_set_zero_left in H2; inversion H2...
    + assert (∃ d : carrier, sub M 1 == Singleton d). 
        apply dim_0_Singleton...
        apply MPcell. clear H. 
      inversion H0; clear H0.
      rewrite H; unfold receptive_x...
      - assert (dim x = 2) as xdim. 
          assert (S (S (dim x0)) = dim x)...
            inversion H2...
            apply In_Intersection in H3...
            inversion H4; clear H4; subst...
          assert (dim x0 <= 0).
            apply MPdim. left. rewrite Mdim. rewrite H...
          inversion H4...
        inversion H2. apply In_Intersection in H3; intuition.
        inversion H4; subst; clear H4.
        assert (Plus (minus x) ∩ Plus (plus x) == Singleton x1). 
          apply Included_Singleton... 
          cut (PlusMinus (minus x) == Plus (minus x) ∩ Plus (plus x))... 
            rewrite <- H3. apply PlusMinus_Inhabited with 0... 
            unfold Included, sub, In at 2...
            apply minus_Inhabited. rewrite xdim... apply Prop_1_1.
        assert (In (Plus (minus x) ∩ Plus (plus x)) x1).
          rewrite H3...
        apply In_Intersection in H4...
        assert (In (Plus (minus x) ∩ Minus (plus x)) x1). 
          apply In_Intersection... 
        pose (Prop_1_1 x). intuition. rewrite <- H11 in H4...
      - assert (dim x = 2) as xdim. 
          assert (S (S (dim x0)) = dim x)...
            inversion H2...
            apply In_Intersection in H3...
            inversion H4; clear H4; subst...
          assert (dim x0 <= 0).
            apply MPdim. left. rewrite Mdim. rewrite H...
          inversion H4...
        inversion H2. apply In_Intersection in H3; intuition.
        inversion H4; subst. clear H4.
        assert (Minus (plus x) ∩ Minus (minus x) == Singleton x1). 
          apply Included_Singleton... 
          cut (MinusPlus (minus x) == Minus (plus x) ∩ Minus (minus x)). 
            intros. 
            rewrite<- H3. apply MinusPlus_Inhabited with 0... 
            unfold Included, sub, In at 2...
            apply minus_Inhabited. rewrite xdim... rewrite Intersection_comm. apply Prop_1_1.
        assert (In (Minus (plus x) ∩ Minus (minus x)) x1).
          rewrite H3...
        apply In_Intersection in H4...
        assert (In (Plus (minus x) ∩ Minus (plus x)) x1). 
          apply In_Intersection... 
        pose (Prop_1_1 x). intuition. rewrite <- H11 in H4...
  Qed.

  Lemma receptive_x_Empty_set : forall x, receptive_x Empty_set x.
  Proof with intuition.
    unfold receptive_x...
    inversion H1; repeat (basic; intuition). 
    inversion H1; repeat (basic; intuition). 
  Qed.

  Lemma n_receptive_ind : forall n, (Prop_3_3_st n) -> (forall m, Lemma_3_2_b_st (S n) m) -> (forall m, Lemma_3_2_b_dual_st (S n) m) -> Prop_3_3_st (S n).
  Proof with intuition.
    intros n H L1 L2.
    unfold Prop_3_3_st, receptive... 
    + apply fff. 
      assert ({dim x <= 1} + {2 <= dim x})...
        apply le_le_S_dec.
      right...
      assert ({dim x < (S (S (S n)))} + {dim x = (S (S (S n)))} + {(S (S (S n))) < dim x})...
        apply lt_eq_lt_dec.
      - unfold Prop_3_3_st, receptive in H.
        assert (is_a_cell (source n (M, P))).
          apply source_is_a_cell...
        unfold source in H2.
        apply (H) in H2...
        Focus 2. apply source_dim...
        assert (receptive_x ((sub (sup M (S n))) (pred (dim x))) x).
          apply receptive_x_by_dimension... 
        rewrite sub_sup_cancel in H2...
        fold (pred (S (S n))). 
          apply le_pred.
        unfold lt in a0...
      - rename b0 into H4. rewrite H4; simpl. 
        unfold receptive_x...
        * assert (Finite (plus x)) as mXFin...
          apply Cardinality_exists in mXFin. 
          inversion mXFin as [mx' Xcard]; clear mXFin.
          assert (Minus (plus x) ∩ sub M (S (S n)) == Empty_set).
            unfold Lemma_3_2_b_st in L1. 
            apply (L1 mx' (plus x)) with (P:=P) (M:=M)...
            unfold Included, sub, In at 2... rewrite <- H4...
            assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as JJ.
              apply Prop_1_1.
            rewrite <- JJ...
          inversion H5.
          apply In_Intersection in H7... 
          assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
            rewrite axiom1. 
            right... 
          apply In_Union in H7...
          assert (In Empty_set x0)...
          rewrite <- H6; apply In_Intersection...
          apply H3; exists x0...
        * assert (sub M (S (S n)) == sub P (S (S n))) as DD.
            apply cell_dim_n_property... 
          assert (Finite (minus x)) as mXFin...
          apply Cardinality_exists in mXFin. 
          inversion mXFin as [mx' Xcard]; clear mXFin.
          assert (Plus (minus x) ∩ sub P (S (S n)) == Empty_set).
            unfold Lemma_3_2_b_dual_st in L2. 
            apply (L2 mx' (minus x)) with (P:=P) (M:=M)...
            unfold Included, sub, In at 2...
            assert (Minus (minus x) ∩ Minus (plus x) == MinusPlus (minus x)) as JJ.
              symmetry.
              apply Prop_1_1.
            rewrite <- JJ...
            rewrite <- DD... rewrite Intersection_comm...
          inversion H5.
          apply In_Intersection in H7... 
          assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
            rewrite axiom1. 
            left... 
          apply In_Union in H7...
          apply H3; exists x0...
          assert (In Empty_set x0)...
          rewrite <- H6; apply In_Intersection...
      - assert (sub M (pred (dim x)) == Empty_set).
          unfold celldim, setdim in H1. 
          unfold Same_set, Included, sub...
          unfold In at 1 in H2...
          exfalso.
          assert (dim x0 <= S n)...
          apply le_n_S in H2; rewrite H4 in H2.
          unfold lt in b0. apply le_pred in b0.
          assert (S (S (S n)) <= S (S n))...
          apply le_trans with (pred (dim x))...
          inversion H2.
        rewrite H2.
        apply receptive_x_Empty_set.
    + apply fff. 
      assert ({dim x <= 1} + {2 <= dim x})...
        apply le_le_S_dec.
      right...
      assert ({dim x < (S (S (S n)))} + {dim x = (S (S (S n)))} + {(S (S (S n))) < dim x})...
        apply lt_eq_lt_dec.
      - unfold Prop_3_3_st, receptive in H.
        assert (is_a_cell (target n (M, P))).
          apply target_is_a_cell...
        unfold target in H2.
        apply (H) in H2...
        Focus 2. apply target_dim...
        assert (receptive_x ((sub (sup P (S n))) (pred (dim x))) x).
          apply receptive_x_by_dimension... 
        rewrite sub_sup_cancel in H2...
        fold (pred (S (S n))). 
          apply le_pred.
        unfold lt in a0...
      - rename b0 into H4. rewrite H4; simpl. 
        assert (sub M (S (S n)) == sub P (S (S n))) as DD.
          apply cell_dim_n_property... 
        rewrite <- DD.
        unfold receptive_x...
        * assert (Finite (plus x)) as mXFin...
          apply Cardinality_exists in mXFin. 
          inversion mXFin as [mx' Xcard]; clear mXFin.
          assert (Minus (plus x) ∩ sub M (S (S n)) == Empty_set).
            unfold Lemma_3_2_b_st in L1. 
            apply (L1 mx' (plus x)) with (P:=P) (M:=M)...
            unfold Included, sub, In at 2... rewrite <- H4...
            assert (Plus (minus x) ∩ Plus (plus x) == PlusMinus (plus x)) as JJ.
              apply Prop_1_1.
            rewrite <- JJ...
          inversion H5.
          apply In_Intersection in H7... 
          assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
            rewrite axiom1. 
            right... 
          apply In_Union in H7...
          assert (In Empty_set x0)...
          rewrite <- H6; apply In_Intersection...
          apply H3; exists x0...
        * assert (Finite (minus x)) as mXFin...
          apply Cardinality_exists in mXFin. 
          inversion mXFin as [mx' Xcard]; clear mXFin.
          assert (Plus (minus x) ∩ sub P (S (S n)) == Empty_set).
            unfold Lemma_3_2_b_dual_st in L2. 
            apply (L2 mx' (minus x)) with (P:=P) (M:=M)...
            unfold Included, sub, In at 2...
            assert (Minus (minus x) ∩ Minus (plus x) == MinusPlus (minus x)) as JJ.
              symmetry.
              apply Prop_1_1.
            rewrite <- JJ...
            rewrite <- DD... rewrite Intersection_comm...
          inversion H5.
          apply In_Intersection in H7... 
          assert (In (Plus (plus x) ∪ Minus (minus x)) x0).
            rewrite axiom1. 
            left... 
          apply In_Union in H7...
          apply H3; exists x0...
          assert (In Empty_set x0)...
          rewrite <- H6; apply In_Intersection...      - assert (sub P (pred (dim x)) == Empty_set).
          unfold celldim, setdim in H1. 
          unfold Same_set, Included, sub...
          unfold In at 1 in H2...
          exfalso.
          assert (dim x0 <= S n)...
          apply le_n_S in H2; rewrite H4 in H2.
          unfold lt in b0. apply le_pred in b0.
          assert (S (S (S n)) <= S (S n))...
          apply le_trans with (pred (dim x))...
          inversion H2.
        rewrite H2.
        apply receptive_x_Empty_set.
  Qed.

  Lemma hhh : forall M x, (2 <= dim x -> receptive_x M x) -> receptive_x M x.
  Proof with intuition.
    intros.
    assert ({2 <= dim x} + {dim x < 2})...
    clear H.
    inversion b; clear b...
    + apply dim_1_properties in H0... 
      unfold receptive_x...
      rewrite H3, Empty_set_zero_right in H5; inversion H5...
      rewrite H,  Empty_set_zero_right in H5; inversion H5...
    + clear H m.
      apply le_S_n in H0.
      inversion H0; clear H0.
      unfold receptive_x...
      inversion H2... apply In_Intersection in H3...
      assert (S (S (dim x0)) = dim  x)...
      rewrite H1 in H3; inversion H3.
      inversion H2... apply In_Intersection in H3...
      assert (S (S (dim x0)) = dim  x)...
      rewrite H1 in H3; inversion H3.
  Qed.    

  Lemma Prop_all_receptive : 
    (forall n, Prop_3_3_st n) -> 
      forall M P, is_a_cell (M, P) -> receptive M /\ receptive P.
  Proof with intuition.
    unfold n_receptive...
    + unfold receptive... 
      apply hhh...
      set (n := pred (pred (dim x))).
      assert (is_a_cell (source n (M, P))).
        apply source_is_a_cell...
      unfold Prop_3_3_st, receptive in H.
      apply (H n) in H2... 
      Focus 2. apply source_dim... 
      apply fff...     
      right... 
      assert (receptive_x (sub (sup M (S n)) (pred (dim x))) x).
        apply receptive_x_by_dimension...
      rewrite sub_sup_cancel in H2...
      unfold n.
      rewrite <- S_pred with (m:=0)...
    + unfold receptive... 
      apply hhh...
      set (n := pred (pred (dim x))).
      assert (is_a_cell (target n (M, P))).
        apply target_is_a_cell...
      unfold Prop_3_3_st, receptive in H.
      apply (H n) in H2... 
      Focus 2. apply target_dim... 
      apply fff...     
      right... 
      assert (receptive_x (sub (sup P (S n)) (pred (dim x))) x).
        apply receptive_x_by_dimension...
      rewrite sub_sup_cancel in H2...
      unfold n.
      rewrite <- S_pred with (m:=0)...
  Qed.

  Lemma all_the_work :
    forall n, (Prop_3_3_st n) /\ (forall m, (Lemma_3_2_b_st n m /\ Lemma_3_2_b_dual_st n m)).
  Proof with intuition.
    intros.
    induction n.
    + split. 
      - apply n_receptive_zero. 
      - intros; split. 
        * destruct m... 
          apply Lemma_3_2_b_n_0.
          apply Lemma_3_2_Step_2.
          apply Lemma_3_2_b_0_1.
        * destruct m... 
          apply Lemma_3_2_b_dual_n_0.
          apply Lemma_3_2_dual_Step_2.
          apply Lemma_3_2_b_dual_0_1.
    + split. 
      - intuition. 
        apply n_receptive_ind...
        destruct m...
          apply Lemma_3_2_b_n_0.
        apply Lemma_3_2_Step_2.
        apply Lemma_3_2_Step_3; [apply H0 | apply H0 | assumption ].
        destruct m...
          apply Lemma_3_2_b_dual_n_0.
        apply Lemma_3_2_dual_Step_2.
        apply Lemma_3_2_dual_Step_3; [apply H0 | apply H0 | assumption ]. 
      - intuition.
        * destruct m...
            apply Lemma_3_2_b_n_0.
          apply Lemma_3_2_Step_2.
          apply Lemma_3_2_Step_3; [apply H0 | apply H0 | assumption ].
        * destruct m...
            apply Lemma_3_2_b_dual_n_0.
          apply Lemma_3_2_dual_Step_2.
          apply Lemma_3_2_dual_Step_3; [apply H0 | apply H0 | assumption ].
  Qed.

  Lemma Prop_3_3 : forall M P,
    is_a_cell (M, P) -> receptive M /\ receptive P.
  Proof with intuition.
    intros.
    apply Prop_all_receptive...
    apply all_the_work. 
  Qed. 

  Lemma Lemma_3_2_b :
    forall n m, (Lemma_3_2_b_st n m).
  Proof.
    apply all_the_work. 
  Qed.

  Lemma Lemma_3_2_b_dual :
    forall n m, (Lemma_3_2_b_dual_st n m).
  Proof.
    apply all_the_work. 
  Qed.

  Lemma Lemma_3_2_c :
    forall n m, (Lemma_3_2_c_st n m).
  Proof.
    intros.
    apply Lemma_3_2_Step_1.
    apply Lemma_3_2_b.
  Qed.

  Lemma Lemma_3_2_c_dual :
    forall n m, (Lemma_3_2_c_dual_st (S n) m).
  Proof.
    intros.
    apply Lemma_3_2_dual_Step_1.
    apply Lemma_3_2_b_dual.
  Qed.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* mu and pi                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Function mu' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier :=
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => MinusPlus (mu' x (S n))
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x.
      induction (dim x).
        - induction n...
            + inversion teq0.
            + inversion teq.
        - induction n0...
            + rewrite Sn_minus_1...
            + apply IHn. simpl in teq... simpl in teq0...
     Qed.

  Definition mu (x : carrier) := fun y => exists n, In (mu' x n) y.

  Function pi' (x : carrier) (n : nat) {measure (fun s => (dim x) - s) n} : Ensemble carrier :=
    match leb n (dim x) with
    | true => match beq_nat n (dim x) with
              | true => Singleton x
              | false => PlusMinus (pi' x (S n))
              end
    | false => Empty_set
    end.
    Proof with intuition.
      unfold lt.
      intros x.
      induction (dim x).
        - induction n...
            + inversion teq0.
            + inversion teq.
        - induction n0...
            + rewrite Sn_minus_1...
            + apply IHn. simpl in teq... simpl in teq0...
     Qed.

  Definition pi (x : carrier) := fun y => exists n, In (pi' x n) y.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Basic results from definitions                       *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Lemma mu'_Singleton : forall x, (mu' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x.
    rewrite mu'_equation.
    assert (leb (dim x) (dim x) = true).
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true).
      induction (dim x)...
    rewrite H, H0...
  Qed.

  Lemma mu'_Empty_set : forall n x, S (dim x) <= n -> (mu' x n) = Empty_set.
  Proof with intuition.
    intros...
    rewrite mu'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H.
        - induction n0...
           + inversion H.
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0...
  Qed.

  Lemma mu'_MinusPlus : forall n x, (S n <= (dim x)) -> (mu' x n) = MinusPlus (mu' x (S n)).
  Proof with intuition.
    intros n x...
    rewrite mu'_equation.
    assert (leb n (dim x) = true).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
         simpl in H0...
    rewrite H0, H1...
  Qed.

  Lemma mu'_ind' :
     ∀ (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (mu' x (S n)) → P n (MinusPlus (mu' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e...
       apply beq_nat_false in e0...
       induction e...
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Hint Resolve le_not_gt.

  Lemma mu'_Finite : forall n x, Finite (mu' x n).
  Proof with intuition.
    intros.
    apply mu'_ind'...
  Qed.

  Lemma mu'_dim : forall x n y, In (mu' x n) y -> dim y = n.
  Proof with intuition.
    intros x n.
    apply mu'_ind'...
     - inversion H...
     - unfold MinusPlus in H1...
       apply In_Intersection in H1...
       unfold Minus, In at 1 in H2...
       inversion H2; clear H2...
       assert (dim x0 = S n0)...
     - inversion H0...
  Qed.

  Lemma sub_mu : forall x n, sub (mu x) (S n) == mu' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold mu, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply mu'_dim in H...
       apply eq_add_S in H1.
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply mu'_dim in H...
  Qed.

  Lemma pi'_Singleton : forall x, (pi' x (dim x)) = Singleton x.
  Proof with intuition.
    intros x.
    rewrite pi'_equation.
    assert (leb (dim x) (dim x) = true).
      apply leb_correct...
    assert (beq_nat (dim x) (dim x) = true).
      induction (dim x)...
    rewrite H, H0...
  Qed.

  Lemma pi'_Empty_set : forall n x, S (dim x) <= n -> (pi' x n) = Empty_set.
  Proof with intuition.
    intros...
    rewrite pi'_equation.
    assert (leb n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        - induction n... inversion H.
        - induction n0...
           + inversion H.
           + simpl. apply IHn. apply le_S_n... -
    rewrite H0...
  Qed.

  Lemma pi'_PlusMinus : forall n x, S n <= (dim x) -> (pi' x n) = PlusMinus (pi' x (S n)).
  Proof with intuition.
    intros n x...
    rewrite pi'_equation.
    assert (leb n (dim x) = true).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
    assert (beq_nat n (dim x) = false).
      generalize dependent n.
      induction (dim x)...
        inversion H...
        induction n0...
         simpl. apply IHn. apply le_S_n...
         simpl in H0...
    rewrite H0, H1...
  Qed.

  Lemma pi'_ind' :
     forall (x : carrier) (P : nat → Ensemble carrier → Prop),
       (P (dim x) (Singleton x))
       → (∀ n : nat, n < (dim x)
            → P (S n) (pi' x (S n)) → P n (PlusMinus (pi' x (S n))))
         → (∀ n : nat, (dim x) < n → P n Empty_set)
           → ∀ n : nat, P n (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind...
     - apply beq_nat_true in e0...
       rewrite e0...
     - apply H0...
       apply leb_complete in e...
       apply beq_nat_false in e0...
       induction e...
     - apply H1...
       apply leb_complete_conv in e...
   Qed.

  Lemma pi'_Finite : forall n x, Finite (pi' x n).
  Proof with intuition.
    intros.
    apply pi'_ind'...
  Qed.

  Lemma pi'_dim : forall x n y, In (pi' x n) y -> dim y = n.
  Proof with intuition.
    intros x n.
    apply pi'_ind'...
     - inversion H...
     - unfold PlusMinus in H1...
       apply In_Intersection in H1...
       unfold Plus, In at 1 in H2...
       inversion H2; clear H2...
       assert (dim x0 = S n0)...
       assert (S (dim y) = dim x0)...
       rewrite H1 in H5...
     - inversion H0...
  Qed.

  Lemma sub_pi : forall x n, sub (pi x) (S n) == pi' x n.
  Proof with intuition.
    intros...
    unfold Same_set, Included...
     - unfold sub, In at 1 in H...
       unfold pi, In at 1 in H0.
       inversion H0; clear H0...
       assert (dim x0 = x1). apply pi'_dim in H...
       apply eq_add_S in H1.
       rewrite <- H1, H0...
     - unfold sub, In at 1...
       exists n...
       apply pi'_dim in H...
  Qed.

  Lemma mu'_Inhabited : forall x, forall n, n <= dim x -> Inhabited (mu' x n).
  Proof with intuition.
    intros x.
    refine (mu'_ind' x (fun m => fun W => (m <= dim x -> Inhabited W)) _ _ _)...
    + exists x...
    + apply (MinusPlus_Inhabited _ n)...
      - rewrite <- sub_mu.
        crush.
      - apply mu'_Finite.
    + exfalso.
      apply le_not_gt in H0...
  Qed.

  Lemma pi'_Inhabited : forall x, forall n, n <= dim x -> Inhabited (pi' x n).
  Proof with intuition.
    intros x.
    refine (pi'_ind' x (fun m => fun W => (m <= dim x -> Inhabited W)) _ _ _)...
    + exists x...
    + apply (PlusMinus_Inhabited _ n)...
      - rewrite <- sub_pi.
        crush.
      - apply pi'_Finite.
    + exfalso.
      apply le_not_gt in H0...
  Qed.

  Lemma perp_sym : forall a b, perp a b -> perp b a.
  Proof with intuition.
    unfold perp; intuition; rewrite Intersection_comm; assumption.
  Qed.

 Lemma well_formed_shortcut : forall A B,
  well_formed A ->
  well_formed B ->
  (forall a b n, a ∈ A -> b ∈ B -> dim a = S n -> dim b = S n -> (~ perp a b) -> a = b) ->
  (forall a b  , a ∈ A -> b ∈ B -> dim a = 0 -> dim b = 0 -> a = b) ->
  well_formed (A ∪ B).
 Proof with intuition.
   intros.
   unfold well_formed in H.
   unfold well_formed in H0.
   unfold well_formed; intuition; repeat (basic; intuition).
   symmetry. apply H2...
   refine (H4 _ _ _ n _ _ _)...
   symmetry. apply (H1 _ _ n)... apply perp_sym in H6...
   apply (H1 _ _ n)...
   refine (H5 _ _ _ n _ _ _)...
 Qed.

  Notation "'<<' x '>>'" := ((mu x), (pi x)) (at level 85).

  Lemma atom_dim : forall x, celldim (<< x >>) (dim x).
  Proof with intuition.
    intros.
    unfold celldim, setdim...
    apply In_Union in H.
    inversion H; clear H.
    + unfold mu, In at 1 in H0.
      inversion H0; clear H0.
      assert (x0 ∈ mu' x x1)...
      rewrite <- sub_mu in H0.
      unfold sub, In at 1 in H0...
      rewrite mu'_equation in H.
      remember (leb x1 (dim x)) as Q.
      destruct Q...
      symmetry in HeqQ. apply leb_complete in HeqQ.
      assert (dim x0 = x1)...
      rewrite H0...
      inversion H.
    + unfold pi, In at 1 in H0.
      inversion H0; clear H0.
      assert (x0 ∈ pi' x x1)...
      rewrite <- sub_pi in H0.
      unfold sub, In at 1 in H0...
      rewrite pi'_equation in H.
      remember (leb x1 (dim x)) as Q.
      destruct Q...
      symmetry in HeqQ. apply leb_complete in HeqQ.
      assert (dim x0 = x1)...
      rewrite H0...
      inversion H.
  Qed.

  Lemma Prop_3_5 : forall M P N Q n,
    is_a_cell (M, P) ->
    is_a_cell (N, Q) ->
    celldim (M, P) (S n) ->
    celldim (N, Q) (S n) ->
      sup M n == sup N n ->
      sup P n == sup Q n ->
      sub P (S n) == sub N (S n) ->
      is_a_cell (composite n (M, P) (N, Q)) /\ (Disjoint (Minus (sub M (S n))) (Plus (sub N (S n)))).
  Admitted.

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* Section 4                                            *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  Definition mu_is_tight : Prop := forall x n, tight (sub (mu x) n).
  Definition pi_is_tight : Prop := forall x n, tight (sub (pi x) n).

  Lemma Same_pair_dec : forall A B C D, Finite A ->
                                      Finite B ->
                                      Finite C ->
                                      Finite D ->
                                      (((A, B) === (C, D)) \/ ~((A, B) === (C, D))).
  Proof with intuition.
    intros.
    assert ((A == C) \/ ~(A == C))... apply Finite_eq_decidable...
    assert ((B == D) \/ ~(B == D))... apply Finite_eq_decidable...
      right; unfold Same_pair...
      right; unfold Same_pair...
  Qed.

  Lemma Same_pair_by_dim' : forall A B C D, (forall k, (sub A (S k), sub B (S k)) === (sub C (S k), sub D (S k)))
                               -> ((A, B) === (C, D)).
  Proof with intuition.
    unfold Same_pair...
    apply Same_set_by_dimension... apply H...
    apply Same_set_by_dimension... apply H...
  Qed.

  Lemma notatomic_lemma :
    forall M P n, is_a_cell (M, P) -> celldim (M, P) n -> (0 < n) ->
    forall u, u ∈ (sub M (S n)) -> ~((M, P) === << u >>) ->
      (exists k, k < n /\
        ~((sub M (S (S k)), sub P (S (S k))) === (sub (mu u) (S (S k)), sub (pi u) (S (S k))))).
  Proof with intuition.
    intros.
    set (Z := (fun k => k < n /\
       ¬((sub M (S (S k)), sub P (S (S k))) === (sub (mu u) (S (S k)), sub (pi u) (S (S k)))))).
    assert (Finite Z).
      apply (Finite_Included (fun k => k < n))...
        apply lt_n_is_Finite.
        unfold Z, Same_set, Included...
          unfold In at 1 in H4. unfold In at 1...
        unfold In at 1 in H4...
        rename x into k.
        assert ((((sub M (S (S k)), sub P (S (S k))) ===
        (sub (mu u) (S (S k)), sub (pi u) (S (S k)))) \/ ~(((sub M (S (S k)), sub P (S (S k))) ===
        (sub (mu u) (S (S k)), sub (pi u) (S (S k))))))).
          apply Same_pair_dec.
            apply Finite_sub; apply H.
            apply Finite_sub; apply H.
            rewrite sub_mu. apply mu'_Finite.
            rewrite sub_pi. apply pi'_Finite.
        intuition.
        right; unfold Z, In at 1...
        left; unfold Z, In at 1...
    apply (Finite_Empty_or_Inhabited) in H4...
    exfalso.
    apply H3.
    assert (forall j, j < n ->
        ((sub M (S (S j)), sub P (S (S j))) ===
        (sub (mu u) (S (S j)), sub (pi u) (S (S j))))).
      intros.
      assert (((sub M (S (S j)), sub P (S (S j))) ===
      (sub (mu u) (S (S j)), sub (pi u) (S (S j)))) \/ ~((sub M (S (S j)), sub P (S (S j))) ===
      (sub (mu u) (S (S j)), sub (pi u) (S (S j)))))...
        apply Same_pair_dec.
            apply Finite_sub; apply H.
            apply Finite_sub; apply H.
            rewrite sub_mu. apply mu'_Finite.
            rewrite sub_pi. apply pi'_Finite.
      exfalso.
      assert (j ∈ Z).
        unfold Z, In at 1...
      rewrite H5 in H6...
    assert (forall j, n <= j ->
        ((sub M (S (S j)), sub P (S (S j))) ===
        (sub (mu u) (S (S j)), sub (pi u) (S (S j))))).
      intros.
      assert (sub M (S (S j)) == Empty_set) as AA.
        unfold Same_set, Included...
        exfalso. unfold sub, In at 1 in H7...
        unfold celldim, setdim in H0...
        assert (dim x <= n). apply H0...
        assert (dim x = S j)...
        rewrite H10 in H7...
        assert (S j <= j)... apply le_trans with n...
        inversion H7...
      assert (sub P (S (S j)) == Empty_set) as BB.
        unfold Same_set, Included...
        exfalso. unfold sub, In at 1 in H7...
        unfold celldim, setdim in H0...
        assert (dim x <= n). apply H0...
        assert (dim x = S j)...
        rewrite H10 in H7...
        assert (S j <= j)... apply le_trans with n...
        inversion H7...
      assert (dim u = n) as CC...
      unfold Same_pair; rewrite AA, BB...
      clear AA BB.
      rewrite sub_mu, mu'_equation.
      remember (leb (S j) (dim u)) as Q.
      destruct Q; [exfalso | intuition].
        symmetry in HeqQ. apply leb_complete in HeqQ.
        rewrite CC in HeqQ. assert (S j <= j)... apply le_trans with n...
      rewrite sub_pi, pi'_equation.
      remember (leb (S j) (dim u)) as Q.
      destruct Q; [exfalso | intuition].
        symmetry in HeqQ. apply leb_complete in HeqQ.
        rewrite CC in HeqQ. assert (S j <= j)... apply le_trans with n...

      assert ((sub M 1, sub P 1) === (sub (mu u) 1, sub (pi u) 1)).
        unfold Same_pair...
        assert (∃ z : carrier, sub M 1 == Singleton z).
          apply (M_0_Inhabited M P)...
        inversion H7; clear H7.
        assert (Included (sub (mu u) 1) (sub M 1)).
          rewrite sub_mu.
          rewrite mu'_MinusPlus.
          rewrite <- sub_mu.
          assert (sub (mu u) 2 == sub M 2).
            unfold Same_pair in H4.
            symmetry.
            apply H4...
          rewrite H7.
          rewrite <- sub_MinusPlus.
          apply sub_Included'.
          apply Prop_2_1. apply H. exists P; apply H...
          assert (dim u = n)... rewrite H7. inversion H1...
        rewrite H8.
        symmetry.
        apply Included_Singleton...
        rewrite sub_mu. apply mu'_Inhabited. apply le_0_n.
        rewrite H8 in H7...
        assert (∃ z : carrier, sub P 1 == Singleton z).
          apply (P_0_Inhabited M P)...
        inversion H7; clear H7.
        assert (Included (sub (pi u) 1) (sub P 1)).
          rewrite sub_pi.
          rewrite pi'_PlusMinus.
          rewrite <- sub_pi.
          assert (sub (pi u) 2 == sub P 2).
            unfold Same_pair in H4.
            symmetry.
            apply H4...
          rewrite H7.
          rewrite <- sub_PlusMinus.
          apply sub_Included'.
          apply Prop_2_1_dual. apply H. exists M; apply H...
          assert (dim u = n)... rewrite H7. inversion H1...
        rewrite H8.
        symmetry.
        apply Included_Singleton...
        rewrite sub_pi. apply pi'_Inhabited. apply le_0_n.
        rewrite H8 in H7...

      unfold Same_pair.
      split; apply Same_set_by_dimension...
      destruct k. apply H7.
      assert ({k < n} + {n <= k})...
        apply H4... apply H6...
      destruct k. apply H7.
      assert ({k < n} + {n <= k})...
        apply H4... apply H6...
    inversion H5; clear H5...
    exists x...
  Qed.

Lemma Lemma_3_2_b_dual_corr : forall n, 
                          forall x, forall M P,
                          is_a_cell (M, P) /\ celldim (M, P) n ->
                          dim x = (S n) /\ minus x ⊆ sub P (S n) ->
                          well_formed ((sub M (S n) ∪ plus x) ∩ √minus x).
Proof with intuition.
  intros n...
  pose (Lemma_3_2_b_dual n 1).
  unfold Lemma_3_2_b_dual_st in l.
  assert (is_a_cell
            (sup M n
             ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)),
            sup P n
            ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
          ∧ Plus (Singleton x) ∩ sub P (S n) == Empty_set).
  apply l...
  apply Cardinality_Singleton_is_one...
  unfold Included; repeat (basic; intuition)...
    inversion H0. rewrite <- H4. unfold sub, In at 1...
  rewrite MinusPlus_Singleton...
  clear l.
  unfold is_a_cell in H0...
  assert ((∀ n0 : nat,
          well_formed
            (sub
               (sup P n
                ∪ ((sub P (S n) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
               (S n0)))).
               apply well_formed_by_dimension...
  specialize H11 with n.
  rewrite sub_Union in H11.
  rewrite sub_sup_Empty_set in H11...
  rewrite Empty_set_ident_left in H11...
  rewrite <- Setminus_is_Intersection_Complement in H11.
  rewrite sub_Setminus in H11.
  rewrite sub_Minus in H11.
  rewrite sub_Union in H11.
  rewrite sub_Plus in H11.
  rewrite sub_idemp in H11.
  rewrite sub_Singleton in H11...
  rewrite Minus_Singleton in H11.
  rewrite Plus_Singleton in H11.
  rewrite Setminus_is_Intersection_Complement in H11.
  rewrite (cell_dim_n_property M P)...
Qed.

Lemma Lemma_3_2_b_corr : forall n, forall x, forall M P,
                          is_a_cell (M, P) /\ celldim (M, P) n ->
                          dim x = (S n) /\ plus x ⊆ sub M (S n) ->
                          well_formed ((sub P (S n) ∪ minus x) ∩ √plus x).
Proof with intuition.
  intros n...
  pose (Lemma_3_2_b n 1 (Singleton x)).
  assert (is_a_cell
            (sup M n
             ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)),
            sup P n
            ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x)))
          ∧ Minus (Singleton x) ∩ sub M (S n) == Empty_set).
  apply a...
  apply Cardinality_Singleton_is_one...
  unfold Included; repeat (basic; intuition)...
    inversion H0. rewrite <- H4. unfold sub, In at 1...
  rewrite PlusMinus_Singleton...
  clear a.
  unfold is_a_cell in H0...
  assert ((∀ n0 : nat,
          well_formed (sub (sup P n ∪ ((sub M (S n) ∪ Minus (Singleton x)) ∩ √Plus (Singleton x))) (S n0)))).
               apply well_formed_by_dimension...
  specialize H11 with n.
  rewrite sub_Union in H11.
  rewrite sub_sup_Empty_set in H11...
  rewrite Empty_set_ident_left in H11...
  rewrite <- Setminus_is_Intersection_Complement in H11.
  rewrite sub_Setminus in H11.
  rewrite sub_Plus in H11.
  rewrite sub_Union in H11.
  rewrite sub_Minus in H11.
  rewrite sub_idemp in H11.
  rewrite sub_Singleton in H11...
  rewrite Minus_Singleton in H11.
  rewrite Plus_Singleton in H11.
  rewrite Setminus_is_Intersection_Complement in H11.
  rewrite <- (cell_dim_n_property M P)...
Qed.

  Lemma Theorem_4_1 :
    mu_is_tight ->
    forall n, 
    forall M P, is_a_cell (M, P) -> celldim (M, P) n -> (0 < n) ->
    forall u, u ∈ (sub M (S n)) -> ~((M, P) === << u >>) ->
    exists N Q L R m,
      is_a_cell (N, Q) /\
      is_a_cell (L, R) /\
      (m < n) /\
      ((M, P) === composite m (N, Q) (L, R)).
  Proof with intuition.
    intros mu_is_tight n M P cellcond dimcond nsize u udim notatomic.

    set (Z := (fun m => (m < n) /\ ~((sub M (S (S m)), sub P (S (S m))) === (sub (mu u) (S (S m)), sub (pi u) (S (S m)))))).
    assert (Finite Z) as FinZ.
      apply (Finite_Included (fun m => (m < n)))...
      apply lt_n_is_Finite...
      unfold Z, Included, In...
      assert ({x < n} + {n <= x})...
        assert (((sub M (S (S x)), sub P (S (S x))) ===
             (sub (mu u) (S (S x)), sub (pi u) (S (S x))))
            ∨ ¬((sub M (S (S x)), sub P (S (S x))) ===
                (sub (mu u) (S (S x)), sub (pi u) (S (S x)))))...
        apply Same_pair_dec.
        apply Finite_sub; apply cellcond.
        apply Finite_sub; apply cellcond.
        rewrite sub_mu; apply mu'_Finite...
        rewrite sub_pi; apply pi'_Finite...
        right; unfold Z, In at 1...
        left; unfold Z, In at 1...
        right; unfold Z, In at 1...
        apply le_not_gt in b...

    assert (Inhabited Z) as Zinhab.
      apply Finite_Empty_or_Inhabited in FinZ...
      apply (notatomic_lemma _ _ n) in notatomic...
      inversion notatomic. exists x...
      unfold Z, In at 1...

    assert (exists m, (m ∈ Z /\ forall r, r ∈ Z -> r <= m)) as max_exists.
      apply Finite_nat_have_maximum_le_element...
    inversion max_exists as [m H]; clear max_exists; inversion H as [minZ mmax]; clear H.

    assert (m < n) as mltn.
      unfold Z, In at 1 in minZ...
    assert (~((sub M (S (S m)), sub P (S (S m))) === (sub (mu u) (S (S m)), sub (pi u) (S (S m))))) as maxprop1.
      unfold Z, In at 1 in minZ...
    assert (forall r, S m < r ->  ((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)))) as maxprop2.
      intros.
      assert (((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)))
            ∨ ((sub M (S r), sub P (S r)) === (sub (mu u) (S r), sub (pi u) (S r)) → False))...
        apply Same_pair_dec...
     apply Finite_sub; apply cellcond.
     apply Finite_sub; apply cellcond.
     rewrite sub_mu; apply mu'_Finite.
     rewrite sub_pi; apply pi'_Finite.
     destruct r. inversion H.
     assert ({r < n} + {n <= r})...
     assert (r ∈ Z).
     unfold Z, In at 1...
     assert (r <= m). apply mmax...
     exfalso... assert (m < r)... apply lt_not_le in H3...
     assert (dim u = n)...
     unfold Same_pair.
      rewrite sub_mu. rewrite mu'_Empty_set.
      rewrite sub_pi. rewrite pi'_Empty_set.
      assert (M == sup M (S n)).
        unfold Same_set, Included... unfold sup, In at 1...
      rewrite H2; rewrite sub_sup_Empty_set.
      assert (P == sup P (S n)).
        unfold Same_set, Included... unfold sup, In at 1...
      rewrite H3; rewrite sub_sup_Empty_set.
      idtac... idtac... intuition. rewrite H0... rewrite H0...

    assert ((sub M (S (S m))) == (sub (mu u) (S (S m))) ∪ ((sub M (S (S m))) ∩ (sub P (S (S m))))) as Mcond.
      inversion mltn...
      rewrite H.
      assert (dim u = n)...
      rewrite <- H0.
      rewrite sub_mu. rewrite mu'_Singleton.
      rewrite <- (cell_dim_n_property M P)...
      rewrite Intersection_idemp.
      symmetry.
      apply Union_Included_left. unfold Included...
      inversion H1... rewrite <- H2, H0... rewrite H0...
      rewrite <- (Full_set_ident_right M) at 1.
      rewrite <- (Full_set_property P).
      rewrite Union_comm at 1.
      rewrite I_U_dist_l at 1.
      rewrite sub_Union at 1.
      rewrite Union_comm at 1.
      rewrite (sub_Intersection M P).
      apply Union_Same_set_compat...
      unfold is_a_cell in cellcond...
      unfold moves_def in H7...
      rewrite H10.
      repeat (rewrite I_U_dist_r).
      rewrite (Intersection_comm _ (√P)).
      rewrite <- (Intersection_trans).
      rewrite (Intersection_comm _ P).
      rewrite Empty_set_property.
      rewrite Empty_set_zero_left.
      rewrite Empty_set_ident_left.
      fold (MinusPlus M).
      assert (sub (mu u) (S (S m)) == sub (MinusPlus M) (S (S m))).
        rewrite sub_mu.
        rewrite mu'_MinusPlus.
        rewrite <- sub_mu.
        rewrite sub_MinusPlus.
        assert (sub M (S (S (S m))) == sub (mu u) (S (S (S m)))).
          apply maxprop2...
        rewrite H7... assert (dim u = n)... rewrite H7, <- H0...
      rewrite H7.
      apply sub_Same_set...
      symmetry.
      apply Disjoint_result.
      apply Disjoint_Intersection_condition.
      assert (Disjoint P (Minus M))...
      apply Prop_2_1_dual... exists M...
      unfold MinusPlus; inversion H11; constructor...
      apply (H12 x)... apply (In_Intersection); repeat basic...
      apply all_decidable... apply cellcond.

    assert ((sub P (S (S m))) == (sub (pi u) (S (S m))) ∪ ((sub M (S (S m))) ∩ (sub P (S (S m))))) as Pcond.
      inversion mltn...
      rewrite H.
      assert (dim u = n)...
      rewrite <- H0.
      rewrite sub_pi. rewrite pi'_Singleton.
      rewrite <- (cell_dim_n_property M P)...
      rewrite Intersection_idemp.
      symmetry.
      apply Union_Included_left. unfold Included...
      inversion H1... rewrite <- H2, H0... rewrite H0...
      rewrite <- (Full_set_ident_right P) at 1.
      rewrite <- (Full_set_property M).
      rewrite Union_comm at 1.
      rewrite I_U_dist_l at 1.
      rewrite sub_Union at 1.
      rewrite Union_comm at 1.
      rewrite (Intersection_comm P M).
      rewrite (sub_Intersection M P).
      apply Union_Same_set_compat...
      unfold is_a_cell in cellcond...
      unfold moves_def in H9...
      rewrite H8.
      repeat (rewrite I_U_dist_r).
      rewrite (Intersection_comm _ (√M)).
      rewrite <- (Intersection_trans).
      rewrite (Intersection_comm _ M).
      rewrite Empty_set_property.
      rewrite Empty_set_zero_left.
      rewrite Empty_set_ident_left.
      fold (PlusMinus P).
      assert (sub (pi u) (S (S m)) == sub (PlusMinus P) (S (S m))).
        rewrite sub_pi.
        rewrite pi'_PlusMinus.
        rewrite <- sub_pi.
        rewrite sub_PlusMinus.
        assert (sub P (S (S (S m))) == sub (pi u) (S (S (S m)))).
          apply maxprop2...
        rewrite H9...
        assert (dim u = n)... rewrite H9, <- H0...
      rewrite H9.
      apply sub_Same_set...
      symmetry.
      apply Disjoint_result.
      apply Disjoint_Intersection_condition.
      assert (Disjoint M (Plus P))...
      apply Prop_2_1... exists P...
      unfold PlusMinus; constructor; inversion H11...
      apply (H12 x); repeat (basic; constructor)...
      repeat basic...
      repeat basic...
      apply all_decidable... apply cellcond.

    assert (Inhabited ((sub M (S (S m))) ∩ (sub P (S (S m))))) as MPInhab.
      assert (((sub M (S (S m))) ∩ (sub P (S (S m)))) == Empty_set \/ Inhabited ((sub M (S (S m))) ∩ (sub P (S (S m)))))...
        apply Finite_Empty_or_Inhabited.
        apply Finite_Intersection... apply Finite_sub... apply cellcond...
        apply all_decidable. apply Finite_sub... apply cellcond...
      exfalso.
      apply maxprop1...
      unfold Same_pair... rewrite Mcond, H0... rewrite Pcond, H0...
    inversion MPInhab as [w winMP]; clear MPInhab.

    set (X := fun k => triangle_rest (sub M (S (S m))) k w).
    assert (exists x, (x ∈ X /\ forall r, r ∈ X -> (triangle_rest X r x) -> x = r)) as Xhasmin.
      refine (minimal_exists' _ _ (S m) _ )...
      apply (Finite_Included (sub M (S (S m)))). apply Finite_sub. apply cellcond.
      unfold X. unfold Included... unfold In at 1 in H... inversion H...
      idtac... unfold X, In. apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold X, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S (S m))))...
      unfold X, Included... unfold In in H. inversion H...
    inversion Xhasmin as [x xismin]; clear Xhasmin.

    set (Y := fun k => triangle_rest (sub M (S (S m))) w k).
    assert (exists x, (x ∈ Y /\ forall r, r ∈ Y -> (triangle_rest Y x r) -> x = r)) as Yhasmax.
      refine (maximal_exists' _ _ (S m) _ )...
      apply (Finite_Included (sub M (S (S m)))). apply Finite_sub. apply cellcond.
      unfold Y. unfold Included... unfold In at 1 in H1... apply triangle_rest_in_set in H1...
      idtac... unfold Y, In. apply triangle_rest_dec. apply Finite_sub. apply cellcond.
      exists w... unfold Y, In at 1... left... apply In_Intersection in winMP...
      apply (Included_trans _ (sub M (S (S m))))...
      unfold Y, Included... unfold In in H1. apply triangle_rest_in_set in H1...
    inversion Yhasmax as [y yismax]; clear Yhasmax.

    assert ((minus x ⊆ sub M (S m)) /\ (plus y ⊆ sub P (S m))) as specialcond.
    split.
      apply (Included_trans _ (sub (MinusPlus M) (S m)))...
        unfold Included...
        assert (dim x = S m) as AA.
          unfold X, In at 1 in H...  inversion H...
        assert (S (dim x0) = dim x)...
        unfold sub, In at 1...
        unfold MinusPlus; apply In_Intersection...
          exists x... unfold X, In at 1 in H... inversion H...
          apply In_Complement... inversion H5; clear H5...
          assert (less x1 x). exists x0...
          assert (x1 ∈ X)... unfold X, In...
          right with x... unfold sub, In at 1...
          assert (S (dim x0) = dim x1)...
          rewrite <- H8, H4, AA...
          assert (x = x1). apply H0...
          right with x... left...
        subst...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1 M M)...
      apply cellcond. exists P. apply cellcond.
      apply (Included_trans _ (sub (PlusMinus M) (S m)))...
        unfold Included...
        assert (dim y = S m) as AA.
          unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...
        assert (S (dim x0) = dim y)...
        unfold sub, In at 1...
        unfold PlusMinus; apply In_Intersection...
          exists y... unfold Y, In at 1 in H1... apply triangle_rest_in_set in H1...
          apply In_Complement...
          inversion H5; clear H5...
          assert (less y x1). exists x0...
          assert (x1 ∈ Y)... unfold Y, In...
          apply triangle_rest_equiv.
          right with y... unfold sub, In at 1...
          assert (S (dim x0) = dim x1)...
          rewrite <- H8, H4, AA...
          apply triangle_rest_equiv...
          assert (y = x1). apply H2...
          right with x1... left...
          subst...
          rewrite AA in H4...
        unfold sub, Included...
        unfold In at 1 in H3...
        unfold In at 1...
        apply (Prop_2_1_dual M P)...
      apply cellcond. exists M. apply cellcond.

    assert ((x ∈ ((sub M (S (S m))) ∩ (sub P (S (S m))))) \/ (y ∈ ((sub M (S (S m))) ∩ (sub P (S (S m)))))) as xory.
      inversion mltn.
        left. rewrite H. rewrite <- (cell_dim_n_property M P)...
        rewrite Intersection_idemp. unfold X, In at 1 in H0... apply triangle_rest_in_set in H0... rewrite H in H6...

      assert (S (S m) <= n) as Smltn.
        rewrite <- H0.
        apply le_n_S...
      clear H0 H m0.
      assert (Disjoint (sub (mu u) (S (S m))) (sub M (S (S m)) ∩ sub P (S (S m)))) as JJ.
        rewrite sub_mu.
        rewrite mu'_MinusPlus.
        rewrite <- sub_mu.
        assert ((sub M (S (S (S m))), sub P (S (S (S m)))) === (sub (mu u) (S (S (S m))), sub (pi u) (S (S (S m))))).
          apply (maxprop2 (S (S m)))...
        unfold Same_pair in H...
        rewrite <- H6.
        assert (Disjoint P (Minus M))...
          apply Prop_2_1_dual.
          apply cellcond. exists M; apply cellcond.
        constructor...
        inversion H; clear H. apply (H9 x0)...
        unfold MinusPlus in H8.
        repeat (basic; intuition).
        inversion H10; exists x1...
        assert (dim u = n)...
        rewrite H...
      assert (~(x ∈ (sub (mu u) (S (S m)))) \/ ~(y ∈ (sub (mu u) (S (S m))))) as ASD.
        assert (~((x ∈ (sub (mu u) (S (S m)))) /\ (y ∈ (sub (mu u) (S (S m)))))) as Q.
          unfold not...
          assert (is_a_segment (sub (mu u) (S (S m))) (sub M (S (S m)))).
            apply Prop_1_3...
            rewrite sub_mu. apply mu'_Finite.
            apply well_formed_sub... apply cellcond.
            rewrite Mcond...
          assert (In (sub (mu u) (S (S m))) w).
            apply segment_def' in H...
          apply (H9 x y)...
          inversion JJ; clear JJ.
        apply (H9 w)...
      assert ((x ∈ sub (mu u) (S (S m))) \/ ~(x ∈ sub (mu u) (S (S m)))) as DD.
        apply Finite_are_decidable...
        rewrite sub_mu.
        apply mu'_Finite.
      inversion DD; clear DD; [right |left]...

      inversion ASD as [WER | WER]; clear ASD.
      inversion xismin as [QQQ WWW]; clear xismin.
      assert (In (sub M (S (S m))) x) as OOO. unfold In, X in QQQ. inversion QQQ...
        rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...
      inversion yismax as [QQQ WWW]; clear yismax.
      assert (In (sub M (S (S m))) y) as OOO. unfold In, Y in QQQ.
        apply triangle_rest_in_set in QQQ...
      rewrite Mcond in OOO. apply In_Union in OOO; inversion OOO...

    inversion xory; clear xory.

    - (* x case *)
    assert (dim x = S m) as dimx.
      unfold X, In at 1 in xismin... apply triangle_rest_in_set in H0...
    assert (P moves Setminus M (Singleton x) to Setminus P (Singleton x)) as LLKK'.
      apply P_moves_Mx_to_Px...
      repeat basic; intuition.
    assert (M moves Setminus M (Singleton x) to Setminus P (Singleton x)) as LLKK.
      apply M_moves_Mx_to_Px...
      repeat basic; intuition.
    assert (Setminus M (Singleton x) moves Setminus (M ∪ plus x) (minus x) to P) as HHJJ.
      assert (Singleton x ∪ (M ∩ √Singleton x) == M).
        rewrite Union_comm, <- Setminus_is_Intersection_Complement.
        apply Union_Setminus_cancel.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (M ∩ √Singleton x
                 moves (P ∪ Minus (M ∩ √Singleton x))
                       ∩ √Plus (M ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (M ∩ √Singleton x)) ∩ √Plus (M ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite <- H10...
    assert (Setminus P (Singleton x) moves Setminus (M ∪ plus x) (minus x) to P) as HHJJ'.
      assert (Singleton x ∪ (P ∩ √Singleton x) == P).
        rewrite Union_comm, <- Setminus_is_Intersection_Complement.
        apply Union_Setminus_cancel.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (P ∩ √Singleton x
                 moves (P ∪ Minus (P ∩ √Singleton x))
                       ∩ √Plus (P ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (P ∩ √Singleton x)) ∩ √Plus (P ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite <- H10...
    assert ((Singleton x) moves M to Setminus (M ∪ plus x) (minus x)) as DDFF.
      assert (Singleton x ∪ (P ∩ √Singleton x) == P).
        rewrite Union_comm, <- Setminus_is_Intersection_Complement.
        apply Union_Setminus_cancel.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Singleton x moves M
               to (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x))
              ∧ (P ∩ √Singleton x
                 moves (P ∪ Minus (P ∩ √Singleton x))
                       ∩ √Plus (P ∩ √Singleton x) to P)
                ∧ (P ∪ Minus (P ∩ √Singleton x)) ∩ √Plus (P ∩ √Singleton x) ==
                  (M ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)).
      apply Prop_2_4_dual_exact.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite MinusPlus_Singleton. apply Included_trans with (sub M (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
    assert (sub (Setminus (M ∪ plus x) (minus x)) (S m) moves sub M m to sub P m) as FFGG.
      pose (Lemma_3_2_b_dual m).
      unfold Lemma_3_2_b_dual_st in l.
      assert (is_a_cell
            (sup (sup M (S m)) m ∪ ((sub ((sub M (S m)) ∪ (sup P m)) (S m) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)),
            sup ((sub M (S m)) ∪ (sup P m)) m ∪ ((sub ((sub M (S m)) ∪ (sup P m)) (S m) ∪ Plus (Singleton x)) ∩ √Minus (Singleton x)))
          ∧ Plus (Singleton x) ∩ sub ((sub M (S m)) ∪ (sup P m)) (S m) == Empty_set).
      apply l with 1...
      apply Cardinality_Singleton_is_one.
      apply (source_is_a_cell)...
      unfold celldim, setdim... repeat (basic; intuition)...
        assert (dim x0 = m)... rewrite H10...
        assert (S (dim x0) <= m)...
      unfold Included, sub... unfold In at 1... inversion H6; clear H6; subst...
      rewrite MinusPlus_Singleton.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite sub_idemp.
        rewrite Empty_set_ident_right...
      unfold is_a_cell in H0...
      assert (sub (sup (sup M (S m)) m
      ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
         ∩ √Minus (Singleton x))) (S m) moves sub (sup (sup M (S m)) m
            ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
               ∩ √Minus (Singleton x))) m to sub (sup (sub M (S m) ∪ sup P m) m
         ∪ ((sub (sub M (S m) ∪ sup P m) (S m) ∪ Plus (Singleton x))
            ∩ √Minus (Singleton x))) m).
      apply moves_by_dim...
      clear H15 H13.
      repeat (rewrite <- Setminus_is_Intersection_Complement in H14 ||
              rewrite sub_Union in H14 ||
              rewrite sub_Setminus in H14 ||
              rewrite sub_Plus in H14 ||
              rewrite sub_Minus in H14 ||
              rewrite sup_Union in H14 ||
              rewrite sup_idemp in H14 ||
              rewrite sub_idemp in H14).
      rewrite (sup_sup_min _ (S m) m) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sub_Empty_set (S m) m) in H14...
      rewrite (sub_Singleton_Empty_set _ (S m)) in H14...
      repeat (rewrite Plus_Empty_set in H14 ||
              rewrite Minus_Empty_set in H14 ||
              rewrite Empty_set_ident_left in H14 ||
              rewrite Empty_set_ident_right in H14 ||
              rewrite Setminus_Empty_set in H14).
      repeat (rewrite <- sub_Union in H14 ||
              rewrite <- sub_Setminus in H14 ||
              rewrite <- sub_Plus in H14 ||
              rewrite <- sub_Minus in H14).
      repeat (rewrite Minus_Singleton in H14 ||
              rewrite Plus_Singleton in H14||
              rewrite Empty_set_ident_right in H14 ).
      assumption.
      rewrite dimx in H13...

      set (R := (P ∩ (√(Singleton x)))).
      set (L := ((M ∩ √(Singleton x)) ∪ plus x) ∩ √minus x).
      set (Q := ((((sub M (S m)) ∪ (plus x)) ∩ √(minus x))) ∪ (sup P m) ∪ (Singleton x)).
      set (N := ((sup M (S m)) ∪ ((Singleton x)))).
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      + unfold N, Q.
        unfold is_a_cell...
        * exists x...
        * exists x...
        * apply well_formed_Union...
          apply well_formed_sup...
          apply cellcond. inversion H9; clear H9; subst. assert ( (dim x0) <= m)...
          rewrite H7, dimx in H6...
        * rewrite <- Setminus_is_Intersection_Complement.
          apply well_formed_Union...
          apply well_formed_Union...
          rewrite Setminus_is_Intersection_Complement.
          assert (well_formed ((sub (sup M (S m)) (S m) ∪ plus x) ∩ √minus x)).
          apply (Lemma_3_2_b_dual_corr m) with (sub M (S m) ∪ sup P m)...
          apply (source_is_a_cell M P)...
          apply source_dim...
          rewrite sub_Union. rewrite sub_idemp.
          rewrite sub_sup_Empty_set...
          rewrite sub_sup_cancel in H6...
          apply well_formed_sup... apply cellcond.
          assert (dim x0 = m).
            repeat (basic; intuition)...
            assert (S (dim x0) = dim x)... rewrite dimx in H12...
          assert (S (dim y0) <= m).
            repeat (basic; intuition)...
          rewrite <- H7, H6 in H10...
          assert ((dim x0) <= m).
            repeat (basic; intuition)...
            assert (dim x0 = m)... rewrite H8...
            assert (S (dim x0) = dim x)... assert (dim x0 = m)...
            rewrite dimx in H8... rewrite H14...
            apply le_trans with (S (dim x0))...
          assert ((dim y0) = S m).
            inversion H9... rewrite <- H10...
          rewrite <- H7 in H10. rewrite H10 in H6...
        * rewrite Union_comm.
          apply Finite_Union...
          apply Finite_sup... apply cellcond...
        * rewrite <- Setminus_is_Intersection_Complement.
          rewrite Union_comm. rewrite (Union_comm _ (sup P m)). rewrite (Union_comm _ (plus x)).
          repeat (apply Finite_Union)... apply all_decidable... apply Finite_sup...
          apply cellcond.
          apply Setminus_Finite'... apply Finite_Union...  apply Finite_sub...
          apply cellcond.
          apply Finite_sup... apply cellcond.
        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite <- H6 in a...
            assert (S m = k)... rewrite <- H7 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite sub_idemp ||
                    rewrite (sub_sup_cancel (S m) (S m)) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ). (**)
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (sub_sub_Empty_set)
                    ); try (rewrite dimx in *)...
            apply Empty_set_moves.

        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (sub_sub_Empty_set) ||
                    rewrite (sub_sup_cancel) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite <- H6 in a...
            assert (S m = k)... rewrite <- H7 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite sub_idemp || rewrite (sub_sub_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (sub_sup_cancel m) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- sub_Plus || rewrite <- sub_Minus ||
                    rewrite <- sub_Union || rewrite <- sub_Setminus). (**)
            repeat (rewrite Plus_Singleton || rewrite Minus_Singleton).
            assumption.
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite sub_idemp || rewrite sub_sub_Empty_set ||
                    rewrite (sub_sup_cancel (S m) (S m)) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- sub_Plus || rewrite <- sub_Minus ||
                    rewrite <- sub_Union || rewrite <- sub_Setminus ||
                    rewrite Minus_Singleton || rewrite Plus_Singleton).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S k))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set) ||
                    rewrite (sub_sup_Empty_set) ||
                    rewrite (sub_sub_Empty_set)
                    ); try (rewrite dimx in *)...
            apply Empty_set_moves.

      + unfold L, R.
        unfold is_a_cell...
        * assert (Inhabited (plus x))... apply plus_Inhabited...
          assert (dim x = S m).
            rewrite <- sub_Intersection in H...
          rewrite H6...
          inversion H6; clear H6... exists x0...
        * assert (Inhabited (sub P 1)).
            apply (P_0_Inhabited' M P)...
          inversion H6; clear H6...
          unfold sub, In at 1 in H7...
          inversion H8...
          exists x0...
          apply In_Intersection...
          apply In_Complement... inversion H7; clear H7; subst...
        * apply (well_formed_Included ((M ∪ plus x) ∩ √minus x)).
          apply well_formed_by_dimension. intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Setminus || rewrite sub_Union ||
                  rewrite <- Minus_Singleton || rewrite <- Plus_Singleton ||
                  rewrite sub_Minus || rewrite sub_Plus).
          assert ({k = m} + {~(k = m)})... apply eq_nat_dec.
            rename a into H7.
            rewrite H7...
          repeat (rewrite sub_Singleton || rewrite Minus_Singleton ||
                  rewrite Plus_Singleton).
                  rewrite Setminus_is_Intersection_Complement.
                  assert (well_formed ((sub (sup M (S m)) (S m) ∪ plus x) ∩ √minus x)).
                  apply (Lemma_3_2_b_dual_corr m) with (sub M (S m) ∪ sup P m)...
                  apply (source_is_a_cell)...
                  apply source_dim...
                  repeat (rewrite sub_Union || rewrite sub_idemp ||
                          rewrite sub_sup_Empty_set || rewrite Empty_set_ident_right)...
                  rewrite sub_sup_cancel in H6... assumption.
            repeat (rewrite sub_Singleton_Empty_set ||
                    rewrite Minus_Empty_set ||
                    rewrite Plus_Empty_set ||
                    rewrite Setminus_Empty_set); try rewrite dimx...
                    rewrite Empty_set_ident_right.
                    apply well_formed_sub. apply cellcond.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          unfold Included; repeat (basic; intuition).
        * apply (well_formed_Included P)... apply cellcond.
          apply Intersection_Included_cancel_right...
        * repeat (rewrite <- Setminus_is_Intersection_Complement).
          rewrite Union_comm.
          apply Setminus_Finite'... apply Finite_Union... apply Setminus_Finite'... apply cellcond.
        * rewrite <- Setminus_is_Intersection_Complement.
          apply Setminus_Finite'... apply cellcond.
        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k m); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            apply eq_add_S in H6. rewrite <- H6 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (sub_Singleton_Empty_set _ m) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ).
            assumption.
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton
                    ).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set _ (S k)) ||
                    rewrite (sub_Singleton_Empty_set _ (S (S k))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            inversion b; clear b.
            repeat (rewrite <- (sub_Setminus)).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Setminus_Empty_set))...
            apply moves_by_dim... apply cellcond.
            rewrite dimx in H8. rewrite H8 in H6...

        * apply moves_by_dim'.
          intros k.
            repeat (rewrite <- Setminus_is_Intersection_Complement).
            rewrite <- Plus_Singleton.
            rewrite <- Minus_Singleton.
            repeat (rewrite (sub_Setminus) ||
                    rewrite (sub_Union) ||
                    rewrite (sub_Plus) ||
                    rewrite (sub_Minus)).
            pose (lt_eq_eq_lt_dec k (S m)); intuition.
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim... apply cellcond.
            rewrite <- H6 in a...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus) ||
                    rewrite Plus_Singleton ||
                    rewrite Minus_Singleton ).
            apply moves_by_dim...
            rewrite b.
            repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            repeat (rewrite <- (sub_Setminus) ||
                    rewrite <- (sub_Union) ||
                    rewrite <- (sub_Plus) ||
                    rewrite <- (sub_Minus)).
            apply moves_by_dim...
            repeat (rewrite (sub_Singleton_Empty_set) ||
                    rewrite (Plus_Empty_set) ||
                    rewrite (Minus_Empty_set) ||
                    rewrite (Empty_set_ident_left) ||
                    rewrite (Empty_set_ident_right) ||
                    rewrite (Setminus_Empty_set)
                    ); try (rewrite dimx in *)...
            apply moves_by_dim, cellcond.

      + split.

        * unfold N, L...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (Setminus_Empty_set)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set ) ||
                  rewrite (sub_minus_Empty_set ) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite dimx in *)...
          assert (S m = k)... rewrite <- H7 in a...
          rewrite b in *.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_Singleton_Empty_set x (S m)) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_right...
          rewrite dimx in H6...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite sub_sub_Empty_set ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set x ) ||
                  rewrite (sub_minus_Empty_set x ) ||
                  rewrite sub_Singleton ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          rewrite Union_comm.
          apply Add_Setminus_Singleton... apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite dimx in H6...
          rewrite dimx in H6...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set) ||
                  rewrite (sub_minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite dimx in * )...
          rewrite dimx in H6...

        * unfold Q, R...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (sub_idemp).
          rewrite (sub_sup_Empty_set m (S m))...
          rewrite (Empty_set_ident_right)...
          rewrite (Empty_set_ident_right)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set ) ||
                  rewrite (sub_minus_Empty_set ) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite dimx in *)...
          assert (S m = k)... rewrite <- H7 in a...
          rewrite b in *.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_Singleton_Empty_set x (S m)) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left...
          rewrite dimx in H6...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite sub_sub_Empty_set ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set x ) ||
                  rewrite (sub_minus_Empty_set x ) ||
                  rewrite sub_Singleton ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          rewrite Union_comm.
          apply Add_Setminus_Singleton...
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite dimx in H6...
          rewrite dimx in H6...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set) ||
                  rewrite (sub_minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite dimx in * )...
                    rewrite dimx in H6...

      (* y case *)
    -
    assert (dim y = S m) as ydim.
      unfold Y, In at 1 in yismax... apply triangle_rest_in_set in H2...
    assert (P moves Setminus M (Singleton y) to Setminus P (Singleton y)) as LLKK'.
      apply P_moves_Mx_to_Px... repeat (basic; intuition)...
    assert (M moves Setminus M (Singleton y) to Setminus P (Singleton y)) as LLKK.
      apply M_moves_Mx_to_Px... repeat (basic; intuition)...
    assert (Setminus M (Singleton y) moves M to Setminus (P ∪ minus y) (plus y)) as HHJJ.
      assert (Setminus M (Singleton y) ∪ Singleton y == M).
        apply Union_Setminus_cancel.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Setminus M (Singleton y) moves M
               to (M ∪ Plus (Setminus M (Singleton y)))
                  ∩ √Minus (Setminus M (Singleton y)))
              ∧ (Singleton y
                 moves (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) to P)
                ∧ (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) ==
                  (M ∪ Plus (Setminus M (Singleton y)))
                  ∩ √Minus (Setminus M (Singleton y))).
      apply Prop_2_4_exact.
      apply Finite_Singleton.
      rewrite Setminus_is_Intersection_Complement.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite PlusMinus_Singleton. apply Included_trans with (sub P (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite H10...
      rewrite <- Setminus_is_Intersection_Complement...
    assert (Setminus P (Singleton y) moves M to Setminus (P ∪ minus y) (plus y)) as HHJJ'.
      assert (Setminus P (Singleton y) ∪ Singleton y == P).
        apply Union_Setminus_cancel.
        apply all_decidable...
        unfold Included... inversion H6; clear H6; subst. apply In_Intersection in H...
      assert ((Setminus P (Singleton y) moves M
               to (M ∪ Plus (Setminus P (Singleton y)))
                  ∩ √Minus (Setminus P (Singleton y)))
              ∧ (Singleton y
                 moves (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) to P)
                ∧ (P ∪ Minus (Singleton y)) ∩ √Plus (Singleton y) ==
                  (M ∪ Plus (Setminus P (Singleton y)))
                  ∩ √Minus (Setminus P (Singleton y))).
      apply Prop_2_4_exact.
      apply Finite_Singleton.
      rewrite Setminus_is_Intersection_Complement.
      apply Setminus_Finite. intuition. apply cellcond. apply Finite_Singleton.
      rewrite H0. apply cellcond.
      rewrite PlusMinus_Singleton. apply Included_trans with (sub P (S m))...
      apply Observation_p322... rewrite H0. apply cellcond.
      constructor; repeat (basic; intuition).
      rewrite <- Minus_Singleton, <- Plus_Singleton.
      repeat (rewrite Setminus_is_Intersection_Complement)...
      rewrite H10...
      rewrite <- Setminus_is_Intersection_Complement...
    assert (sub (Setminus (P ∪ minus y) (plus y)) (S m) moves sub M m to sub P m) as FFGG.
      pose (Lemma_3_2_b m).
      unfold Lemma_3_2_b_st in l.
      assert (is_a_cell
          (sup (sub P (S m) ∪ sup M m) m ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y)),
            sup (sup P (S m)) m ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y)))
          ∧ Minus (Singleton y) ∩ sub (sub P (S m) ∪ sup M m) (S m) == Empty_set).
      apply l with 1...
      apply Cardinality_Singleton_is_one.
      apply (target_is_a_cell)...
      apply target_dim...
      unfold Included, sub... unfold In at 1... inversion H6; clear H6; subst...
      rewrite PlusMinus_Singleton.
        rewrite sub_Union.
        rewrite sub_sup_Empty_set...
        rewrite sub_idemp.
        rewrite Empty_set_ident_right...
      unfold is_a_cell in H0...
      assert (sub (sup (sup P (S m)) m
      ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
         ∩ √Plus (Singleton y))) (S m)
      moves sub (sup (sub P (S m) ∪ sup M m) m
            ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
               ∩ √Plus (Singleton y))) m
      to sub (sup (sup P (S m)) m
         ∪ ((sub (sub P (S m) ∪ sup M m) (S m) ∪ Minus (Singleton y))
            ∩ √Plus (Singleton y))) m).
      apply moves_by_dim...
      clear H15 H13.
      repeat (rewrite <- Setminus_is_Intersection_Complement in H14 ||
              rewrite sub_Union in H14 ||
              rewrite sub_Setminus in H14 ||
              rewrite sub_Plus in H14 ||
              rewrite sub_Minus in H14 ||
              rewrite sup_Union in H14 ||
              rewrite sup_idemp in H14 ||
              rewrite sub_idemp in H14).
      rewrite (sup_sup_min _ (S m) m) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_Empty_set m (S m)) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sup_cancel m m) in H14...
      rewrite (sub_sub_Empty_set (S m) m) in H14...
      rewrite (sub_Singleton_Empty_set _ (S m)) in H14...
      repeat (rewrite Plus_Empty_set in H14 ||
              rewrite Minus_Empty_set in H14 ||
              rewrite Empty_set_ident_left in H14 ||
              rewrite Empty_set_ident_right in H14 ||
              rewrite Setminus_Empty_set in H14).
      repeat (rewrite <- sub_Union in H14 ||
              rewrite <- sub_Setminus in H14 ||
              rewrite <- sub_Plus in H14 ||
              rewrite <- sub_Minus in H14).
      repeat (rewrite Minus_Singleton in H14 ||
              rewrite Plus_Singleton in H14||
              rewrite Empty_set_ident_right in H14 ).
      assumption.
      rewrite ydim in H13...

      set (N := (M ∩ (√(Singleton y)))).
      set (Q := ((P ∩ √(Singleton y)) ∪ minus y) ∩ √plus y).
      set (L := ((sup M m ∪ (((sub P (S m)) ∪ (minus y)) ∩ √(plus y))) ∪ (Singleton y))).
      set (R := ((sup P (S m)) ∪ ((Singleton y)))).
      assert (sup (sup M m ∪ sub P (S m)) m == sup M m).
        crush. exfalso. rewrite H7 in H8... left...
      assert ((sub (sup M m ∪ sub P (S m)) (S m)) == sub P (S m)).
        crush. exfalso. rewrite H9 in H8... right...
      exists N. exists Q. exists L. exists R. exists m.
      splits...

      (* N and Q case *)
      + unfold N, Q.
        unfold is_a_cell...
        * pose (M_0_Inhabited' _ _ cellcond). inversion i; clear i. exists x0.
          split. apply H8. apply In_Complement...
          inversion H9; clear H9; subst.
          assert (dim x0 = 0)...
        * assert (Inhabited (MinusPlus (Singleton y))). apply (MinusPlus_Inhabited _ m)...
            apply In_Intersection in H... unfold Included... inversion H...
            rewrite <- H10... exists y...
          inversion H8. exists x0. rewrite I_U_dist_r. right.
          unfold MinusPlus in H9. rewrite Plus_Singleton, Minus_Singleton in H9...
        * apply (well_formed_Included M). apply cellcond.
          apply Intersection_Included_cancel_right...
        * apply (well_formed_Included ((P ∪ minus y) ∩ √plus y)).
          apply well_formed_by_dimension. intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Setminus || rewrite sub_Union ||
                  rewrite <- Minus_Singleton || rewrite <- Plus_Singleton ||
                  rewrite sub_Minus || rewrite sub_Plus).
          assert ({k = m} + {k = m -> False})... apply eq_nat_dec.
            rename a into H9.
            rewrite H9...
          repeat (rewrite sub_Singleton || rewrite Minus_Singleton ||
                  rewrite Plus_Singleton).
                  rewrite Setminus_is_Intersection_Complement.
                  assert (well_formed ((sub (sup P (S m)) (S m) ∪ minus y) ∩ √plus y)).
                  apply (Lemma_3_2_b_corr m) with(sub P (S m) ∪ sup M m) ...
                  apply (target_is_a_cell)...
                  apply target_dim...
                  repeat (rewrite sub_Union || rewrite sub_idemp ||
                          rewrite sub_sup_Empty_set || rewrite Empty_set_ident_right)...
                  rewrite sub_sup_cancel in H8... assumption.
            repeat (rewrite sub_Singleton_Empty_set ||
                    rewrite Minus_Empty_set ||
                    rewrite Plus_Empty_set ||
                    rewrite Setminus_Empty_set); try rewrite ydim...
                    rewrite Empty_set_ident_right.
                    apply well_formed_sub. apply cellcond.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          unfold Included; repeat (basic; intuition).
        * rewrite <- Setminus_is_Intersection_Complement...
          apply Setminus_Finite'... apply cellcond.
        * apply Setminus_Finite... rewrite Union_comm.
          apply Finite_Union...
          apply Setminus_Finite... apply cellcond.
        * apply moves_by_dim'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite <- Plus_Singleton || rewrite <- Minus_Singleton).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          repeat (rewrite sub_Plus || rewrite sub_Minus).
          assert ({k < S m} + {k = S m} + {k = S (S m)} + {S (S m) < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
          rewrite <- H8 in a...
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          rewrite Minus_Singleton, Plus_Singleton.
          apply moves_by_dim...
          rewrite b.
          rewrite (sub_Singleton_Empty_set _ (S (S (S m))))...
          rewrite Plus_Empty_set, Minus_Empty_set...
          rewrite Empty_set_ident_right.
          repeat (rewrite Setminus_Empty_set).
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          apply moves_by_dim...
          rewrite ydim in H8...
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
        * apply moves_by_dim'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite <- Plus_Singleton || rewrite <- Minus_Singleton).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          repeat (rewrite sub_Plus || rewrite sub_Minus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim. apply cellcond.
          rewrite <- H8 in a...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y m) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          rewrite Minus_Singleton, Plus_Singleton.
          assumption.
          rewrite b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S m)) ||
                  rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          rewrite Minus_Singleton, Plus_Singleton.
          apply moves_by_dim...
          inversion b; clear b.
          repeat (rewrite (sub_Singleton_Empty_set _ (S (S (S m)))) ||
                  rewrite (sub_Singleton_Empty_set _ (S (S (S (S m))))) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          repeat (rewrite <- sub_Setminus || rewrite <- sub_Plus ||
                  rewrite <- sub_Minus || rewrite <- sub_Union)...
          apply moves_by_dim...
          repeat (rewrite (sub_Singleton_Empty_set) ||
                  rewrite (Plus_Empty_set) ||
                  rewrite (Minus_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          apply moves_by_dim, cellcond.
          rewrite H10 in H8...
          rewrite H10 in H8...
          rewrite H10 in H8...

      (* L and R case *)
      + unfold L, R.
        apply (Same_set_is_a_cell ((sup M m ∪ ((sub P (S m) ∪ Minus (Singleton y)) ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P (S m) ∪ Singleton y))...
        apply (Same_set_is_a_cell ((sup (sup M m ∪ sub P (S m)) m
        ∪ ((sub (sup M m ∪ sub P (S m)) (S m) ∪ Minus (Singleton y))
        ∩ √Plus (Singleton y))) ∪ Singleton y) (sup P (S m) ∪ Singleton y))...
        apply (Lemma_3_2_c) with 1.
        apply Cardinality_Singleton_is_one.
        split.
        assert (is_a_cell (target m (M, P))) as QRQR.
          apply (target_is_a_cell)...
        unfold target in QRQR. eapply (Same_set_is_a_cell). exact QRQR.
          rewrite Union_comm... reflexivity.
        unfold celldim, setdim...
          inversion H8; clear H8; subst.
          inversion H9; clear H9; subst.
          apply (le_trans _ (S (dim x0)))...
          unfold sub, In at 1 in H8...
          apply eq_add_S in H10.
          rewrite H10; left.
          unfold sup, In at 1 in H9...
        split.
        unfold Included...
          inversion H8; clear H8; subst.
          unfold In, sub...
          constructor.
        apply well_formed_Singleton.
        rewrite sub_Union.
        rewrite sub_idemp.
        rewrite sub_sup_Empty_set.
        rewrite Empty_set_ident_left.
        unfold Included...
          apply H7...
          unfold PlusMinus in H8. rewrite Plus_Singleton in H8...
          apply In_Intersection in H8... idtac...
        rewrite H0, H1...
        rewrite (Minus_Singleton y), (Plus_Singleton y)...

      + split.

        * unfold L, N...
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          rewrite (sub_Singleton_Empty_set _ (S m))...
          rewrite (sub_idemp).
          rewrite (sub_sup_Empty_set m (S m))...
          rewrite (Empty_set_ident_left)...
          rewrite (Empty_set_ident_right)...
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = (S m)} + {S m < k})...
            apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite b.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y m) ||
                  rewrite (sub_minus y m) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_Singleton_Empty_set y (S m)) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_right...
          rewrite ydim in H8...
          rewrite b.
          repeat (rewrite (sub_sub_Empty_set (S m) (S (S m))) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set y (S m)) ||
                  rewrite (sub_minus_Empty_set y (S m)) ||
                  rewrite (sub_Singleton y (S m)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          apply Add_Setminus_Singleton...
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite ydim in H8...
          rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in * )...
          rewrite ydim in H8...

        * unfold Q, R.
          apply Same_set_by_dimension'.
          intros k.
          repeat (rewrite <- Setminus_is_Intersection_Complement).
          repeat (rewrite sub_Union || rewrite sub_Setminus).
          assert ({k < m} + {k = m} + {k = S m} + {S m < k})... apply lt_eq_eq_lt_dec.
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (sub_Singleton_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite (Empty_set_ident_left) ||
                  rewrite (Empty_set_ident_right)); try (rewrite ydim in *)...
          assert (S m = k)... rewrite <- H9 in a...
          rewrite <- b.
          repeat (rewrite (sub_idemp) ||
                  rewrite (sub_plus y k) ||
                  rewrite (sub_minus y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite (sub_sup_cancel) ||
                  rewrite (Setminus_Empty_set) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right)...
          rewrite Setminus_cancel.
          rewrite Empty_set_ident_left...
          rewrite ydim in H8... rewrite b... rewrite b...
          repeat (rewrite (sub_sub_Empty_set (S m) (S k)) ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton y k) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite Setminus_Empty_set); try (rewrite b)...
          apply Add_Setminus_Singleton.
          apply carrier_decidable_eq.
          apply In_Intersection in H...
          rewrite ydim in H8...
          rewrite ydim in H8...
          repeat (rewrite (sub_sub_Empty_set) ||
                  rewrite (sub_plus_Empty_set y k) ||
                  rewrite (sub_minus_Empty_set y k) ||
                  rewrite (sub_Singleton_Empty_set y (S k)) ||
                  rewrite Empty_set_ident_left ||
                  rewrite Empty_set_ident_right ||
                  rewrite (sub_sup_Empty_set) ||
                  rewrite Setminus_Empty_set); try (rewrite ydim in * )...
 Qed.

End ParityComplexTheory.

    

